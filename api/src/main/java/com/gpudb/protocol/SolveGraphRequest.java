/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb.protocol;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.avro.Schema;
import org.apache.avro.SchemaBuilder;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;


/**
 * A set of parameters for {@link
 * com.gpudb.GPUdb#solveGraph(SolveGraphRequest)}.
 * <p>
 * Solves an existing graph for a type of problem (e.g., shortest path, page
 * rank, travelling salesman, etc.) using source nodes, destination nodes, and
 * additional, optional weights and restrictions. See <a
 * href="../../../../../graph_solver/network_graph_solver.html"
 * target="_top">Network Graph Solvers</a> for more information.
 */
public class SolveGraphRequest implements IndexedRecord {
    private static final Schema schema$ = SchemaBuilder
            .record("SolveGraphRequest")
            .namespace("com.gpudb")
            .fields()
                .name("graphName").type().stringType().noDefault()
                .name("weightsOnEdges").type().array().items().stringType().noDefault()
                .name("restrictions").type().array().items().stringType().noDefault()
                .name("solverType").type().stringType().noDefault()
                .name("sourceNodeId").type().longType().noDefault()
                .name("destinationNodeIds").type().array().items().longType().noDefault()
                .name("nodeType").type().stringType().noDefault()
                .name("sourceNode").type().stringType().noDefault()
                .name("destinationNodes").type().array().items().stringType().noDefault()
                .name("solutionTable").type().stringType().noDefault()
                .name("options").type().map().values().stringType().noDefault()
            .endRecord();


    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     * 
     * @return  the schema for the class.
     * 
     */
    public static Schema getClassSchema() {
        return schema$;
    }


    /**
     * The type of solver to use for the graph.
     * Supported values:
     * <ul>
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.SolverType#SHORTEST_PATH
     * SHORTEST_PATH}: Solves for the optimal (shortest) path based on weights
     * and restrictions from one source to destinations nodes. Also known as
     * the Dijkstra solver.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.SolverType#PAGE_RANK PAGE_RANK}:
     * Solves for the probability of each destination node being visited based
     * on the links of the graph topology. Weights are not required to use this
     * solver.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.SolverType#PROBABILITY_RANK
     * PROBABILITY_RANK}: Solves for the transitional probability (Hidden
     * Markov) for each node based on the weights (probability assigned over
     * given edges).
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.SolverType#CENTRALITY CENTRALITY}:
     * Solves for the degree of a node to depict how many pairs of individuals
     * that would have to go through the node to reach one another in the
     * minimum number of hops. Also known as betweenness.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.SolverType#MULTIPLE_ROUTING
     * MULTIPLE_ROUTING}: Solves for finding the minimum cost cumulative path
     * for a round-trip starting from the given source and visiting each given
     * destination node once then returning to the source. Also known as the
     * travelling salesman problem.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.SolverType#INVERSE_SHORTEST_PATH
     * INVERSE_SHORTEST_PATH}: Solves for finding the optimal path cost for
     * each destination node to route to the source node. Also known as inverse
     * Dijkstra or the service man routing problem.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.SolverType#BACKHAUL_ROUTING
     * BACKHAUL_ROUTING}: Solves for optimal routes that connect remote asset
     * nodes to the fixed (backbone) asset nodes. When {@code BACKHAUL_ROUTING}
     * is invoked, the {@code destinationNodes} or {@code destinationNodeIds}
     * array is used for both fixed and remote asset nodes and the {@code
     * sourceNodeId} represents the number of fixed asset nodes contained in
     * {@code destinationNodes} / {@code destinationNodeIds}.
     * </ul>
     * The default value is {@link
     * com.gpudb.protocol.SolveGraphRequest.SolverType#SHORTEST_PATH
     * SHORTEST_PATH}.
     * A set of string constants for the parameter {@code solverType}.
     */
    public static final class SolverType {

        /**
         * Solves for the optimal (shortest) path based on weights and
         * restrictions from one source to destinations nodes. Also known as
         * the Dijkstra solver.
         */
        public static final String SHORTEST_PATH = "SHORTEST_PATH";

        /**
         * Solves for the probability of each destination node being visited
         * based on the links of the graph topology. Weights are not required
         * to use this solver.
         */
        public static final String PAGE_RANK = "PAGE_RANK";

        /**
         * Solves for the transitional probability (Hidden Markov) for each
         * node based on the weights (probability assigned over given edges).
         */
        public static final String PROBABILITY_RANK = "PROBABILITY_RANK";

        /**
         * Solves for the degree of a node to depict how many pairs of
         * individuals that would have to go through the node to reach one
         * another in the minimum number of hops. Also known as betweenness.
         */
        public static final String CENTRALITY = "CENTRALITY";

        /**
         * Solves for finding the minimum cost cumulative path for a round-trip
         * starting from the given source and visiting each given destination
         * node once then returning to the source. Also known as the travelling
         * salesman problem.
         */
        public static final String MULTIPLE_ROUTING = "MULTIPLE_ROUTING";

        /**
         * Solves for finding the optimal path cost for each destination node
         * to route to the source node. Also known as inverse Dijkstra or the
         * service man routing problem.
         */
        public static final String INVERSE_SHORTEST_PATH = "INVERSE_SHORTEST_PATH";

        /**
         * Solves for optimal routes that connect remote asset nodes to the
         * fixed (backbone) asset nodes. When {@code BACKHAUL_ROUTING} is
         * invoked, the {@code destinationNodes} or {@code destinationNodeIds}
         * array is used for both fixed and remote asset nodes and the {@code
         * sourceNodeId} represents the number of fixed asset nodes contained
         * in {@code destinationNodes} / {@code destinationNodeIds}.
         */
        public static final String BACKHAUL_ROUTING = "BACKHAUL_ROUTING";

        private SolverType() {  }
    }


    /**
     * Source and destination node identifier type.
     * Supported values:
     * <ul>
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_ID NODE_ID}: The
     * graph's nodes were identified as integers, e.g., 1234.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_WKTPOINT
     * NODE_WKTPOINT}: The graph's nodes were identified as geospatial
     * coordinates, e.g., 'POINT(1.0 2.0)'.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_NAME NODE_NAME}: The
     * graph's nodes were identified as strings, e.g., 'Arlington'.
     * </ul>
     * The default value is {@link
     * com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_ID NODE_ID}.
     * A set of string constants for the parameter {@code nodeType}.
     */
    public static final class NodeType {

        /**
         * The graph's nodes were identified as integers, e.g., 1234.
         */
        public static final String NODE_ID = "NODE_ID";

        /**
         * The graph's nodes were identified as geospatial coordinates, e.g.,
         * 'POINT(1.0 2.0)'.
         */
        public static final String NODE_WKTPOINT = "NODE_WKTPOINT";

        /**
         * The graph's nodes were identified as strings, e.g., 'Arlington'.
         */
        public static final String NODE_NAME = "NODE_NAME";

        private NodeType() {  }
    }


    /**
     * Additional parameters
     * <ul>
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#MAX_SOLUTION_RADIUS
     * MAX_SOLUTION_RADIUS}: For {@code SHORTEST_PATH} and {@code
     * INVERSE_SHORTEST_PATH} solvers only. Sets the maximum solution cost
     * radius, which ignores the {@code destinationNodeIds} list and instead
     * outputs the nodes within the radius sorted by ascending cost. If set to
     * '0.0', the setting is ignored.  The default value is '0.0'.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#MIN_SOLUTION_RADIUS
     * MIN_SOLUTION_RADIUS}: For {@code SHORTEST_PATH} and {@code
     * INVERSE_SHORTEST_PATH} solvers only. Applicable only when {@code
     * max_solution_radius} is set. Sets the minimum solution cost radius,
     * which ignores the {@code destinationNodeIds} list and instead outputs
     * the nodes within the radius sorted by ascending cost. If set to '0.0',
     * the setting is ignored.  The default value is '0.0'.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#MAX_SOLUTION_TARGETS
     * MAX_SOLUTION_TARGETS}: For {@code SHORTEST_PATH} and {@code
     * INVERSE_SHORTEST_PATH} solvers only. Sets the maximum number of solution
     * targets, which ignores the {@code destinationNodeIds} list and instead
     * outputs no more than n number of nodes sorted by ascending cost where n
     * is equal to the setting value. If set to 0, the setting is ignored.  The
     * default value is '0'.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#EXPORT_SOLVE_RESULTS
     * EXPORT_SOLVE_RESULTS}: Returns solution results inside the {@code
     * resultPerDestinationNode} array in the response if set to {@code true}.
     * Supported values:
     * <ul>
     *         <li> {@link com.gpudb.protocol.SolveGraphRequest.Options#TRUE
     * TRUE}
     *         <li> {@link com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     * FALSE}
     * </ul>
     * The default value is {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#REMOVE_PREVIOUS_RESTRICTIONS
     * REMOVE_PREVIOUS_RESTRICTIONS}: Ignore the restrictions applied to the
     * graph during the creation stage and only use the restrictions specified
     * in this request if set to {@code true}.
     * Supported values:
     * <ul>
     *         <li> {@link com.gpudb.protocol.SolveGraphRequest.Options#TRUE
     * TRUE}
     *         <li> {@link com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     * FALSE}
     * </ul>
     * The default value is {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#RESTRICTION_THRESHOLD_VALUE
     * RESTRICTION_THRESHOLD_VALUE}: Value-based restriction comparison. Any
     * node or edge with a RESTRICTIONS_VALUECOMPARED value greater than the
     * {@code restriction_threshold_value} will not be included in the
     * solution.
     *         <li> {@link
     * com.gpudb.protocol.SolveGraphRequest.Options#UNIFORM_WEIGHTS
     * UNIFORM_WEIGHTS}: When specified, assigns the given value to all the
     * edges in the graph. Note that weights provided in {@code weightsOnEdges}
     * will override this value.
     * </ul>
     * The default value is an empty {@link Map}.
     * A set of string constants for the parameter {@code options}.
     */
    public static final class Options {

        /**
         * For {@code SHORTEST_PATH} and {@code INVERSE_SHORTEST_PATH} solvers
         * only. Sets the maximum solution cost radius, which ignores the
         * {@code destinationNodeIds} list and instead outputs the nodes within
         * the radius sorted by ascending cost. If set to '0.0', the setting is
         * ignored.  The default value is '0.0'.
         */
        public static final String MAX_SOLUTION_RADIUS = "max_solution_radius";

        /**
         * For {@code SHORTEST_PATH} and {@code INVERSE_SHORTEST_PATH} solvers
         * only. Applicable only when {@code max_solution_radius} is set. Sets
         * the minimum solution cost radius, which ignores the {@code
         * destinationNodeIds} list and instead outputs the nodes within the
         * radius sorted by ascending cost. If set to '0.0', the setting is
         * ignored.  The default value is '0.0'.
         */
        public static final String MIN_SOLUTION_RADIUS = "min_solution_radius";

        /**
         * For {@code SHORTEST_PATH} and {@code INVERSE_SHORTEST_PATH} solvers
         * only. Sets the maximum number of solution targets, which ignores the
         * {@code destinationNodeIds} list and instead outputs no more than n
         * number of nodes sorted by ascending cost where n is equal to the
         * setting value. If set to 0, the setting is ignored.  The default
         * value is '0'.
         */
        public static final String MAX_SOLUTION_TARGETS = "max_solution_targets";

        /**
         * Returns solution results inside the {@code resultPerDestinationNode}
         * array in the response if set to {@code true}.
         * Supported values:
         * <ul>
         *         <li> {@link
         * com.gpudb.protocol.SolveGraphRequest.Options#TRUE TRUE}
         *         <li> {@link
         * com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}
         * </ul>
         * The default value is {@link
         * com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}.
         */
        public static final String EXPORT_SOLVE_RESULTS = "export_solve_results";
        public static final String TRUE = "true";
        public static final String FALSE = "false";

        /**
         * Ignore the restrictions applied to the graph during the creation
         * stage and only use the restrictions specified in this request if set
         * to {@code true}.
         * Supported values:
         * <ul>
         *         <li> {@link
         * com.gpudb.protocol.SolveGraphRequest.Options#TRUE TRUE}
         *         <li> {@link
         * com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}
         * </ul>
         * The default value is {@link
         * com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}.
         */
        public static final String REMOVE_PREVIOUS_RESTRICTIONS = "remove_previous_restrictions";

        /**
         * Value-based restriction comparison. Any node or edge with a
         * RESTRICTIONS_VALUECOMPARED value greater than the {@code
         * restriction_threshold_value} will not be included in the solution.
         */
        public static final String RESTRICTION_THRESHOLD_VALUE = "restriction_threshold_value";

        /**
         * When specified, assigns the given value to all the edges in the
         * graph. Note that weights provided in {@code weightsOnEdges} will
         * override this value.
         */
        public static final String UNIFORM_WEIGHTS = "uniform_weights";

        private Options() {  }
    }

    private String graphName;
    private List<String> weightsOnEdges;
    private List<String> restrictions;
    private String solverType;
    private long sourceNodeId;
    private List<Long> destinationNodeIds;
    private String nodeType;
    private String sourceNode;
    private List<String> destinationNodes;
    private String solutionTable;
    private Map<String, String> options;


    /**
     * Constructs a SolveGraphRequest object with default parameters.
     */
    public SolveGraphRequest() {
        graphName = "";
        weightsOnEdges = new ArrayList<>();
        restrictions = new ArrayList<>();
        solverType = "";
        destinationNodeIds = new ArrayList<>();
        nodeType = "";
        sourceNode = "";
        destinationNodes = new ArrayList<>();
        solutionTable = "";
        options = new LinkedHashMap<>();
    }

    /**
     * Constructs a SolveGraphRequest object with the specified parameters.
     * 
     * @param graphName  Name of the graph resource to solve.
     * @param weightsOnEdges  Additional weights to apply to the edges of an
     *                        existing graph. Weights must be specified using
     *                        <a
     *                        href="../../../../../graph_solver/network_graph_solver.html#identifiers"
     *                        target="_top">identifiers</a>; identifiers are
     *                        grouped as <a
     *                        href="../../../../../graph_solver/network_graph_solver.html#id-combos"
     *                        target="_top">combinations</a>. Identifiers can
     *                        be used with existing column names, e.g.,
     *                        'table.column AS WEIGHTS_EDGE_ID', expressions,
     *                        e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED',
     *                        or raw values, e.g., '{4, 15, 2} AS
     *                        WEIGHTS_VALUESPECIFIED'. Any provided weights
     *                        will be added (in the case of
     *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with
     *                        (in the case of 'WEIGHTS_FACTORSPECIFIED') the
     *                        existing weight(s). If using raw values in an
     *                        identifier combination, the number of values
     *                        specified must match across the combination.  The
     *                        default value is an empty {@link List}.
     * @param restrictions  Additional restrictions to apply to the nodes/edges
     *                      of an existing graph. Restrictions must be
     *                      specified using <a
     *                      href="../../../../../graph_solver/network_graph_solver.html#identifiers"
     *                      target="_top">identifiers</a>; identifiers are
     *                      grouped as <a
     *                      href="../../../../../graph_solver/network_graph_solver.html#id-combos"
     *                      target="_top">combinations</a>. Identifiers can be
     *                      used with existing column names, e.g.,
     *                      'table.column AS RESTRICTIONS_EDGE_ID',
     *                      expressions, e.g., 'column/2 AS
     *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g.,
     *                      '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If
     *                      using raw values in an identifier combination, the
     *                      number of values specified must match across the
     *                      combination. If {@code
     *                      remove_previous_restrictions} is set to {@code
     *                      true}, any provided restrictions will replace the
     *                      existing restrictions. If {@code
     *                      remove_previous_restrictions} is set to {@code
     *                      false}, any provided weights will be added (in the
     *                      case of 'RESTRICTIONS_VALUECOMPARED') to or
     *                      replaced (in the case of
     *                      'RESTRICTIONS_ONOFFCOMPARED').  The default value
     *                      is an empty {@link List}.
     * @param solverType  The type of solver to use for the graph.
     *                    Supported values:
     *                    <ul>
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#SHORTEST_PATH
     *                    SHORTEST_PATH}: Solves for the optimal (shortest)
     *                    path based on weights and restrictions from one
     *                    source to destinations nodes. Also known as the
     *                    Dijkstra solver.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#PAGE_RANK
     *                    PAGE_RANK}: Solves for the probability of each
     *                    destination node being visited based on the links of
     *                    the graph topology. Weights are not required to use
     *                    this solver.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#PROBABILITY_RANK
     *                    PROBABILITY_RANK}: Solves for the transitional
     *                    probability (Hidden Markov) for each node based on
     *                    the weights (probability assigned over given edges).
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#CENTRALITY
     *                    CENTRALITY}: Solves for the degree of a node to
     *                    depict how many pairs of individuals that would have
     *                    to go through the node to reach one another in the
     *                    minimum number of hops. Also known as betweenness.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#MULTIPLE_ROUTING
     *                    MULTIPLE_ROUTING}: Solves for finding the minimum
     *                    cost cumulative path for a round-trip starting from
     *                    the given source and visiting each given destination
     *                    node once then returning to the source. Also known as
     *                    the travelling salesman problem.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#INVERSE_SHORTEST_PATH
     *                    INVERSE_SHORTEST_PATH}: Solves for finding the
     *                    optimal path cost for each destination node to route
     *                    to the source node. Also known as inverse Dijkstra or
     *                    the service man routing problem.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#BACKHAUL_ROUTING
     *                    BACKHAUL_ROUTING}: Solves for optimal routes that
     *                    connect remote asset nodes to the fixed (backbone)
     *                    asset nodes. When {@code BACKHAUL_ROUTING} is
     *                    invoked, the {@code destinationNodes} or {@code
     *                    destinationNodeIds} array is used for both fixed and
     *                    remote asset nodes and the {@code sourceNodeId}
     *                    represents the number of fixed asset nodes contained
     *                    in {@code destinationNodes} / {@code
     *                    destinationNodeIds}.
     *                    </ul>
     *                    The default value is {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#SHORTEST_PATH
     *                    SHORTEST_PATH}.
     * @param sourceNodeId  If {@code nodeType} is {@code NODE_ID}, the node ID
     *                      (integer) of the source (starting point) for the
     *                      graph solution. If the {@code solverType} is set to
     *                      {@code BACKHAUL_ROUTING}, this number represents
     *                      the number of fixed asset nodes contained in {@code
     *                      destinationNodes}, e.g., if {@code sourceNodeId} is
     *                      set to 24, the first 24 nodes listed in {@code
     *                      destinationNodes} / {@code destinationNodeIds} are
     *                      the fixed asset nodes and the rest of the nodes in
     *                      the array are remote assets.
     * @param destinationNodeIds  List of destination node indices, or indices
     *                            for pageranks. If the {@code solverType} is
     *                            set to {@code BACKHAUL_ROUTING}, it is the
     *                            list of all fixed and remote asset nodes.
     *                            The default value is an empty {@link List}.
     * @param nodeType  Source and destination node identifier type.
     *                  Supported values:
     *                  <ul>
     *                          <li> {@link
     *                  com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_ID
     *                  NODE_ID}: The graph's nodes were identified as
     *                  integers, e.g., 1234.
     *                          <li> {@link
     *                  com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_WKTPOINT
     *                  NODE_WKTPOINT}: The graph's nodes were identified as
     *                  geospatial coordinates, e.g., 'POINT(1.0 2.0)'.
     *                          <li> {@link
     *                  com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_NAME
     *                  NODE_NAME}: The graph's nodes were identified as
     *                  strings, e.g., 'Arlington'.
     *                  </ul>
     *                  The default value is {@link
     *                  com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_ID
     *                  NODE_ID}.
     * @param sourceNode  If {@code nodeType} is {@code NODE_WKTPOINT} or
     *                    {@code NODE_NAME}, the node (string) of the source
     *                    (starting point) for the graph solution.  The default
     *                    value is ''.
     * @param destinationNodes  If {@code nodeType} is {@code NODE_WKTPOINT} or
     *                          {@code NODE_NAME}, the list of destination node
     *                          or page rank indices (strings) for the graph
     *                          solution. If the {@code solverType} is set to
     *                          {@code BACKHAUL_ROUTING}, it is the list of all
     *                          fixed and remote asset nodes. The string type
     *                          should be consistent with the {@code nodeType}
     *                          parameter.  The default value is an empty
     *                          {@link List}.
     * @param solutionTable  Name of the table to store the solution.  The
     *                       default value is 'graph_solutions'.
     * @param options  Additional parameters
     *                 <ul>
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#MAX_SOLUTION_RADIUS
     *                 MAX_SOLUTION_RADIUS}: For {@code SHORTEST_PATH} and
     *                 {@code INVERSE_SHORTEST_PATH} solvers only. Sets the
     *                 maximum solution cost radius, which ignores the {@code
     *                 destinationNodeIds} list and instead outputs the nodes
     *                 within the radius sorted by ascending cost. If set to
     *                 '0.0', the setting is ignored.  The default value is
     *                 '0.0'.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#MIN_SOLUTION_RADIUS
     *                 MIN_SOLUTION_RADIUS}: For {@code SHORTEST_PATH} and
     *                 {@code INVERSE_SHORTEST_PATH} solvers only. Applicable
     *                 only when {@code max_solution_radius} is set. Sets the
     *                 minimum solution cost radius, which ignores the {@code
     *                 destinationNodeIds} list and instead outputs the nodes
     *                 within the radius sorted by ascending cost. If set to
     *                 '0.0', the setting is ignored.  The default value is
     *                 '0.0'.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#MAX_SOLUTION_TARGETS
     *                 MAX_SOLUTION_TARGETS}: For {@code SHORTEST_PATH} and
     *                 {@code INVERSE_SHORTEST_PATH} solvers only. Sets the
     *                 maximum number of solution targets, which ignores the
     *                 {@code destinationNodeIds} list and instead outputs no
     *                 more than n number of nodes sorted by ascending cost
     *                 where n is equal to the setting value. If set to 0, the
     *                 setting is ignored.  The default value is '0'.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#EXPORT_SOLVE_RESULTS
     *                 EXPORT_SOLVE_RESULTS}: Returns solution results inside
     *                 the {@code resultPerDestinationNode} array in the
     *                 response if set to {@code true}.
     *                 Supported values:
     *                 <ul>
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#TRUE TRUE}
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     *                 FALSE}
     *                 </ul>
     *                 The default value is {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     *                 FALSE}.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#REMOVE_PREVIOUS_RESTRICTIONS
     *                 REMOVE_PREVIOUS_RESTRICTIONS}: Ignore the restrictions
     *                 applied to the graph during the creation stage and only
     *                 use the restrictions specified in this request if set to
     *                 {@code true}.
     *                 Supported values:
     *                 <ul>
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#TRUE TRUE}
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     *                 FALSE}
     *                 </ul>
     *                 The default value is {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     *                 FALSE}.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#RESTRICTION_THRESHOLD_VALUE
     *                 RESTRICTION_THRESHOLD_VALUE}: Value-based restriction
     *                 comparison. Any node or edge with a
     *                 RESTRICTIONS_VALUECOMPARED value greater than the {@code
     *                 restriction_threshold_value} will not be included in the
     *                 solution.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#UNIFORM_WEIGHTS
     *                 UNIFORM_WEIGHTS}: When specified, assigns the given
     *                 value to all the edges in the graph. Note that weights
     *                 provided in {@code weightsOnEdges} will override this
     *                 value.
     *                 </ul>
     *                 The default value is an empty {@link Map}.
     * 
     */
    public SolveGraphRequest(String graphName, List<String> weightsOnEdges, List<String> restrictions, String solverType, long sourceNodeId, List<Long> destinationNodeIds, String nodeType, String sourceNode, List<String> destinationNodes, String solutionTable, Map<String, String> options) {
        this.graphName = (graphName == null) ? "" : graphName;
        this.weightsOnEdges = (weightsOnEdges == null) ? new ArrayList<String>() : weightsOnEdges;
        this.restrictions = (restrictions == null) ? new ArrayList<String>() : restrictions;
        this.solverType = (solverType == null) ? "" : solverType;
        this.sourceNodeId = sourceNodeId;
        this.destinationNodeIds = (destinationNodeIds == null) ? new ArrayList<Long>() : destinationNodeIds;
        this.nodeType = (nodeType == null) ? "" : nodeType;
        this.sourceNode = (sourceNode == null) ? "" : sourceNode;
        this.destinationNodes = (destinationNodes == null) ? new ArrayList<String>() : destinationNodes;
        this.solutionTable = (solutionTable == null) ? "" : solutionTable;
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
    }

    /**
     * 
     * @return Name of the graph resource to solve.
     * 
     */
    public String getGraphName() {
        return graphName;
    }

    /**
     * 
     * @param graphName  Name of the graph resource to solve.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setGraphName(String graphName) {
        this.graphName = (graphName == null) ? "" : graphName;
        return this;
    }

    /**
     * 
     * @return Additional weights to apply to the edges of an existing graph.
     *         Weights must be specified using <a
     *         href="../../../../../graph_solver/network_graph_solver.html#identifiers"
     *         target="_top">identifiers</a>; identifiers are grouped as <a
     *         href="../../../../../graph_solver/network_graph_solver.html#id-combos"
     *         target="_top">combinations</a>. Identifiers can be used with
     *         existing column names, e.g., 'table.column AS WEIGHTS_EDGE_ID',
     *         expressions, e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED',
     *         or raw values, e.g., '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'. Any
     *         provided weights will be added (in the case of
     *         'WEIGHTS_VALUESPECIFIED') to or multiplied with (in the case of
     *         'WEIGHTS_FACTORSPECIFIED') the existing weight(s). If using raw
     *         values in an identifier combination, the number of values
     *         specified must match across the combination.  The default value
     *         is an empty {@link List}.
     * 
     */
    public List<String> getWeightsOnEdges() {
        return weightsOnEdges;
    }

    /**
     * 
     * @param weightsOnEdges  Additional weights to apply to the edges of an
     *                        existing graph. Weights must be specified using
     *                        <a
     *                        href="../../../../../graph_solver/network_graph_solver.html#identifiers"
     *                        target="_top">identifiers</a>; identifiers are
     *                        grouped as <a
     *                        href="../../../../../graph_solver/network_graph_solver.html#id-combos"
     *                        target="_top">combinations</a>. Identifiers can
     *                        be used with existing column names, e.g.,
     *                        'table.column AS WEIGHTS_EDGE_ID', expressions,
     *                        e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED',
     *                        or raw values, e.g., '{4, 15, 2} AS
     *                        WEIGHTS_VALUESPECIFIED'. Any provided weights
     *                        will be added (in the case of
     *                        'WEIGHTS_VALUESPECIFIED') to or multiplied with
     *                        (in the case of 'WEIGHTS_FACTORSPECIFIED') the
     *                        existing weight(s). If using raw values in an
     *                        identifier combination, the number of values
     *                        specified must match across the combination.  The
     *                        default value is an empty {@link List}.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setWeightsOnEdges(List<String> weightsOnEdges) {
        this.weightsOnEdges = (weightsOnEdges == null) ? new ArrayList<String>() : weightsOnEdges;
        return this;
    }

    /**
     * 
     * @return Additional restrictions to apply to the nodes/edges of an
     *         existing graph. Restrictions must be specified using <a
     *         href="../../../../../graph_solver/network_graph_solver.html#identifiers"
     *         target="_top">identifiers</a>; identifiers are grouped as <a
     *         href="../../../../../graph_solver/network_graph_solver.html#id-combos"
     *         target="_top">combinations</a>. Identifiers can be used with
     *         existing column names, e.g., 'table.column AS
     *         RESTRICTIONS_EDGE_ID', expressions, e.g., 'column/2 AS
     *         RESTRICTIONS_VALUECOMPARED', or raw values, e.g., '{0, 0, 0, 1}
     *         AS RESTRICTIONS_ONOFFCOMPARED'. If using raw values in an
     *         identifier combination, the number of values specified must
     *         match across the combination. If {@code
     *         remove_previous_restrictions} is set to {@code true}, any
     *         provided restrictions will replace the existing restrictions. If
     *         {@code remove_previous_restrictions} is set to {@code false},
     *         any provided weights will be added (in the case of
     *         'RESTRICTIONS_VALUECOMPARED') to or replaced (in the case of
     *         'RESTRICTIONS_ONOFFCOMPARED').  The default value is an empty
     *         {@link List}.
     * 
     */
    public List<String> getRestrictions() {
        return restrictions;
    }

    /**
     * 
     * @param restrictions  Additional restrictions to apply to the nodes/edges
     *                      of an existing graph. Restrictions must be
     *                      specified using <a
     *                      href="../../../../../graph_solver/network_graph_solver.html#identifiers"
     *                      target="_top">identifiers</a>; identifiers are
     *                      grouped as <a
     *                      href="../../../../../graph_solver/network_graph_solver.html#id-combos"
     *                      target="_top">combinations</a>. Identifiers can be
     *                      used with existing column names, e.g.,
     *                      'table.column AS RESTRICTIONS_EDGE_ID',
     *                      expressions, e.g., 'column/2 AS
     *                      RESTRICTIONS_VALUECOMPARED', or raw values, e.g.,
     *                      '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If
     *                      using raw values in an identifier combination, the
     *                      number of values specified must match across the
     *                      combination. If {@code
     *                      remove_previous_restrictions} is set to {@code
     *                      true}, any provided restrictions will replace the
     *                      existing restrictions. If {@code
     *                      remove_previous_restrictions} is set to {@code
     *                      false}, any provided weights will be added (in the
     *                      case of 'RESTRICTIONS_VALUECOMPARED') to or
     *                      replaced (in the case of
     *                      'RESTRICTIONS_ONOFFCOMPARED').  The default value
     *                      is an empty {@link List}.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setRestrictions(List<String> restrictions) {
        this.restrictions = (restrictions == null) ? new ArrayList<String>() : restrictions;
        return this;
    }

    /**
     * 
     * @return The type of solver to use for the graph.
     *         Supported values:
     *         <ul>
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.SolverType#SHORTEST_PATH
     *         SHORTEST_PATH}: Solves for the optimal (shortest) path based on
     *         weights and restrictions from one source to destinations nodes.
     *         Also known as the Dijkstra solver.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.SolverType#PAGE_RANK
     *         PAGE_RANK}: Solves for the probability of each destination node
     *         being visited based on the links of the graph topology. Weights
     *         are not required to use this solver.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.SolverType#PROBABILITY_RANK
     *         PROBABILITY_RANK}: Solves for the transitional probability
     *         (Hidden Markov) for each node based on the weights (probability
     *         assigned over given edges).
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.SolverType#CENTRALITY
     *         CENTRALITY}: Solves for the degree of a node to depict how many
     *         pairs of individuals that would have to go through the node to
     *         reach one another in the minimum number of hops. Also known as
     *         betweenness.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.SolverType#MULTIPLE_ROUTING
     *         MULTIPLE_ROUTING}: Solves for finding the minimum cost
     *         cumulative path for a round-trip starting from the given source
     *         and visiting each given destination node once then returning to
     *         the source. Also known as the travelling salesman problem.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.SolverType#INVERSE_SHORTEST_PATH
     *         INVERSE_SHORTEST_PATH}: Solves for finding the optimal path cost
     *         for each destination node to route to the source node. Also
     *         known as inverse Dijkstra or the service man routing problem.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.SolverType#BACKHAUL_ROUTING
     *         BACKHAUL_ROUTING}: Solves for optimal routes that connect remote
     *         asset nodes to the fixed (backbone) asset nodes. When {@code
     *         BACKHAUL_ROUTING} is invoked, the {@code destinationNodes} or
     *         {@code destinationNodeIds} array is used for both fixed and
     *         remote asset nodes and the {@code sourceNodeId} represents the
     *         number of fixed asset nodes contained in {@code
     *         destinationNodes} / {@code destinationNodeIds}.
     *         </ul>
     *         The default value is {@link
     *         com.gpudb.protocol.SolveGraphRequest.SolverType#SHORTEST_PATH
     *         SHORTEST_PATH}.
     * 
     */
    public String getSolverType() {
        return solverType;
    }

    /**
     * 
     * @param solverType  The type of solver to use for the graph.
     *                    Supported values:
     *                    <ul>
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#SHORTEST_PATH
     *                    SHORTEST_PATH}: Solves for the optimal (shortest)
     *                    path based on weights and restrictions from one
     *                    source to destinations nodes. Also known as the
     *                    Dijkstra solver.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#PAGE_RANK
     *                    PAGE_RANK}: Solves for the probability of each
     *                    destination node being visited based on the links of
     *                    the graph topology. Weights are not required to use
     *                    this solver.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#PROBABILITY_RANK
     *                    PROBABILITY_RANK}: Solves for the transitional
     *                    probability (Hidden Markov) for each node based on
     *                    the weights (probability assigned over given edges).
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#CENTRALITY
     *                    CENTRALITY}: Solves for the degree of a node to
     *                    depict how many pairs of individuals that would have
     *                    to go through the node to reach one another in the
     *                    minimum number of hops. Also known as betweenness.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#MULTIPLE_ROUTING
     *                    MULTIPLE_ROUTING}: Solves for finding the minimum
     *                    cost cumulative path for a round-trip starting from
     *                    the given source and visiting each given destination
     *                    node once then returning to the source. Also known as
     *                    the travelling salesman problem.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#INVERSE_SHORTEST_PATH
     *                    INVERSE_SHORTEST_PATH}: Solves for finding the
     *                    optimal path cost for each destination node to route
     *                    to the source node. Also known as inverse Dijkstra or
     *                    the service man routing problem.
     *                            <li> {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#BACKHAUL_ROUTING
     *                    BACKHAUL_ROUTING}: Solves for optimal routes that
     *                    connect remote asset nodes to the fixed (backbone)
     *                    asset nodes. When {@code BACKHAUL_ROUTING} is
     *                    invoked, the {@code destinationNodes} or {@code
     *                    destinationNodeIds} array is used for both fixed and
     *                    remote asset nodes and the {@code sourceNodeId}
     *                    represents the number of fixed asset nodes contained
     *                    in {@code destinationNodes} / {@code
     *                    destinationNodeIds}.
     *                    </ul>
     *                    The default value is {@link
     *                    com.gpudb.protocol.SolveGraphRequest.SolverType#SHORTEST_PATH
     *                    SHORTEST_PATH}.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setSolverType(String solverType) {
        this.solverType = (solverType == null) ? "" : solverType;
        return this;
    }

    /**
     * 
     * @return If {@code nodeType} is {@code NODE_ID}, the node ID (integer) of
     *         the source (starting point) for the graph solution. If the
     *         {@code solverType} is set to {@code BACKHAUL_ROUTING}, this
     *         number represents the number of fixed asset nodes contained in
     *         {@code destinationNodes}, e.g., if {@code sourceNodeId} is set
     *         to 24, the first 24 nodes listed in {@code destinationNodes} /
     *         {@code destinationNodeIds} are the fixed asset nodes and the
     *         rest of the nodes in the array are remote assets.
     * 
     */
    public long getSourceNodeId() {
        return sourceNodeId;
    }

    /**
     * 
     * @param sourceNodeId  If {@code nodeType} is {@code NODE_ID}, the node ID
     *                      (integer) of the source (starting point) for the
     *                      graph solution. If the {@code solverType} is set to
     *                      {@code BACKHAUL_ROUTING}, this number represents
     *                      the number of fixed asset nodes contained in {@code
     *                      destinationNodes}, e.g., if {@code sourceNodeId} is
     *                      set to 24, the first 24 nodes listed in {@code
     *                      destinationNodes} / {@code destinationNodeIds} are
     *                      the fixed asset nodes and the rest of the nodes in
     *                      the array are remote assets.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setSourceNodeId(long sourceNodeId) {
        this.sourceNodeId = sourceNodeId;
        return this;
    }

    /**
     * 
     * @return List of destination node indices, or indices for pageranks. If
     *         the {@code solverType} is set to {@code BACKHAUL_ROUTING}, it is
     *         the list of all fixed and remote asset nodes.  The default value
     *         is an empty {@link List}.
     * 
     */
    public List<Long> getDestinationNodeIds() {
        return destinationNodeIds;
    }

    /**
     * 
     * @param destinationNodeIds  List of destination node indices, or indices
     *                            for pageranks. If the {@code solverType} is
     *                            set to {@code BACKHAUL_ROUTING}, it is the
     *                            list of all fixed and remote asset nodes.
     *                            The default value is an empty {@link List}.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setDestinationNodeIds(List<Long> destinationNodeIds) {
        this.destinationNodeIds = (destinationNodeIds == null) ? new ArrayList<Long>() : destinationNodeIds;
        return this;
    }

    /**
     * 
     * @return Source and destination node identifier type.
     *         Supported values:
     *         <ul>
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_ID NODE_ID}:
     *         The graph's nodes were identified as integers, e.g., 1234.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_WKTPOINT
     *         NODE_WKTPOINT}: The graph's nodes were identified as geospatial
     *         coordinates, e.g., 'POINT(1.0 2.0)'.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_NAME
     *         NODE_NAME}: The graph's nodes were identified as strings, e.g.,
     *         'Arlington'.
     *         </ul>
     *         The default value is {@link
     *         com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_ID NODE_ID}.
     * 
     */
    public String getNodeType() {
        return nodeType;
    }

    /**
     * 
     * @param nodeType  Source and destination node identifier type.
     *                  Supported values:
     *                  <ul>
     *                          <li> {@link
     *                  com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_ID
     *                  NODE_ID}: The graph's nodes were identified as
     *                  integers, e.g., 1234.
     *                          <li> {@link
     *                  com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_WKTPOINT
     *                  NODE_WKTPOINT}: The graph's nodes were identified as
     *                  geospatial coordinates, e.g., 'POINT(1.0 2.0)'.
     *                          <li> {@link
     *                  com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_NAME
     *                  NODE_NAME}: The graph's nodes were identified as
     *                  strings, e.g., 'Arlington'.
     *                  </ul>
     *                  The default value is {@link
     *                  com.gpudb.protocol.SolveGraphRequest.NodeType#NODE_ID
     *                  NODE_ID}.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setNodeType(String nodeType) {
        this.nodeType = (nodeType == null) ? "" : nodeType;
        return this;
    }

    /**
     * 
     * @return If {@code nodeType} is {@code NODE_WKTPOINT} or {@code
     *         NODE_NAME}, the node (string) of the source (starting point) for
     *         the graph solution.  The default value is ''.
     * 
     */
    public String getSourceNode() {
        return sourceNode;
    }

    /**
     * 
     * @param sourceNode  If {@code nodeType} is {@code NODE_WKTPOINT} or
     *                    {@code NODE_NAME}, the node (string) of the source
     *                    (starting point) for the graph solution.  The default
     *                    value is ''.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setSourceNode(String sourceNode) {
        this.sourceNode = (sourceNode == null) ? "" : sourceNode;
        return this;
    }

    /**
     * 
     * @return If {@code nodeType} is {@code NODE_WKTPOINT} or {@code
     *         NODE_NAME}, the list of destination node or page rank indices
     *         (strings) for the graph solution. If the {@code solverType} is
     *         set to {@code BACKHAUL_ROUTING}, it is the list of all fixed and
     *         remote asset nodes. The string type should be consistent with
     *         the {@code nodeType} parameter.  The default value is an empty
     *         {@link List}.
     * 
     */
    public List<String> getDestinationNodes() {
        return destinationNodes;
    }

    /**
     * 
     * @param destinationNodes  If {@code nodeType} is {@code NODE_WKTPOINT} or
     *                          {@code NODE_NAME}, the list of destination node
     *                          or page rank indices (strings) for the graph
     *                          solution. If the {@code solverType} is set to
     *                          {@code BACKHAUL_ROUTING}, it is the list of all
     *                          fixed and remote asset nodes. The string type
     *                          should be consistent with the {@code nodeType}
     *                          parameter.  The default value is an empty
     *                          {@link List}.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setDestinationNodes(List<String> destinationNodes) {
        this.destinationNodes = (destinationNodes == null) ? new ArrayList<String>() : destinationNodes;
        return this;
    }

    /**
     * 
     * @return Name of the table to store the solution.  The default value is
     *         'graph_solutions'.
     * 
     */
    public String getSolutionTable() {
        return solutionTable;
    }

    /**
     * 
     * @param solutionTable  Name of the table to store the solution.  The
     *                       default value is 'graph_solutions'.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setSolutionTable(String solutionTable) {
        this.solutionTable = (solutionTable == null) ? "" : solutionTable;
        return this;
    }

    /**
     * 
     * @return Additional parameters
     *         <ul>
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#MAX_SOLUTION_RADIUS
     *         MAX_SOLUTION_RADIUS}: For {@code SHORTEST_PATH} and {@code
     *         INVERSE_SHORTEST_PATH} solvers only. Sets the maximum solution
     *         cost radius, which ignores the {@code destinationNodeIds} list
     *         and instead outputs the nodes within the radius sorted by
     *         ascending cost. If set to '0.0', the setting is ignored.  The
     *         default value is '0.0'.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#MIN_SOLUTION_RADIUS
     *         MIN_SOLUTION_RADIUS}: For {@code SHORTEST_PATH} and {@code
     *         INVERSE_SHORTEST_PATH} solvers only. Applicable only when {@code
     *         max_solution_radius} is set. Sets the minimum solution cost
     *         radius, which ignores the {@code destinationNodeIds} list and
     *         instead outputs the nodes within the radius sorted by ascending
     *         cost. If set to '0.0', the setting is ignored.  The default
     *         value is '0.0'.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#MAX_SOLUTION_TARGETS
     *         MAX_SOLUTION_TARGETS}: For {@code SHORTEST_PATH} and {@code
     *         INVERSE_SHORTEST_PATH} solvers only. Sets the maximum number of
     *         solution targets, which ignores the {@code destinationNodeIds}
     *         list and instead outputs no more than n number of nodes sorted
     *         by ascending cost where n is equal to the setting value. If set
     *         to 0, the setting is ignored.  The default value is '0'.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#EXPORT_SOLVE_RESULTS
     *         EXPORT_SOLVE_RESULTS}: Returns solution results inside the
     *         {@code resultPerDestinationNode} array in the response if set to
     *         {@code true}.
     *         Supported values:
     *         <ul>
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#TRUE TRUE}
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#REMOVE_PREVIOUS_RESTRICTIONS
     *         REMOVE_PREVIOUS_RESTRICTIONS}: Ignore the restrictions applied
     *         to the graph during the creation stage and only use the
     *         restrictions specified in this request if set to {@code true}.
     *         Supported values:
     *         <ul>
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#TRUE TRUE}
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}
     *         </ul>
     *         The default value is {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#FALSE FALSE}.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#RESTRICTION_THRESHOLD_VALUE
     *         RESTRICTION_THRESHOLD_VALUE}: Value-based restriction
     *         comparison. Any node or edge with a RESTRICTIONS_VALUECOMPARED
     *         value greater than the {@code restriction_threshold_value} will
     *         not be included in the solution.
     *                 <li> {@link
     *         com.gpudb.protocol.SolveGraphRequest.Options#UNIFORM_WEIGHTS
     *         UNIFORM_WEIGHTS}: When specified, assigns the given value to all
     *         the edges in the graph. Note that weights provided in {@code
     *         weightsOnEdges} will override this value.
     *         </ul>
     *         The default value is an empty {@link Map}.
     * 
     */
    public Map<String, String> getOptions() {
        return options;
    }

    /**
     * 
     * @param options  Additional parameters
     *                 <ul>
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#MAX_SOLUTION_RADIUS
     *                 MAX_SOLUTION_RADIUS}: For {@code SHORTEST_PATH} and
     *                 {@code INVERSE_SHORTEST_PATH} solvers only. Sets the
     *                 maximum solution cost radius, which ignores the {@code
     *                 destinationNodeIds} list and instead outputs the nodes
     *                 within the radius sorted by ascending cost. If set to
     *                 '0.0', the setting is ignored.  The default value is
     *                 '0.0'.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#MIN_SOLUTION_RADIUS
     *                 MIN_SOLUTION_RADIUS}: For {@code SHORTEST_PATH} and
     *                 {@code INVERSE_SHORTEST_PATH} solvers only. Applicable
     *                 only when {@code max_solution_radius} is set. Sets the
     *                 minimum solution cost radius, which ignores the {@code
     *                 destinationNodeIds} list and instead outputs the nodes
     *                 within the radius sorted by ascending cost. If set to
     *                 '0.0', the setting is ignored.  The default value is
     *                 '0.0'.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#MAX_SOLUTION_TARGETS
     *                 MAX_SOLUTION_TARGETS}: For {@code SHORTEST_PATH} and
     *                 {@code INVERSE_SHORTEST_PATH} solvers only. Sets the
     *                 maximum number of solution targets, which ignores the
     *                 {@code destinationNodeIds} list and instead outputs no
     *                 more than n number of nodes sorted by ascending cost
     *                 where n is equal to the setting value. If set to 0, the
     *                 setting is ignored.  The default value is '0'.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#EXPORT_SOLVE_RESULTS
     *                 EXPORT_SOLVE_RESULTS}: Returns solution results inside
     *                 the {@code resultPerDestinationNode} array in the
     *                 response if set to {@code true}.
     *                 Supported values:
     *                 <ul>
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#TRUE TRUE}
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     *                 FALSE}
     *                 </ul>
     *                 The default value is {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     *                 FALSE}.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#REMOVE_PREVIOUS_RESTRICTIONS
     *                 REMOVE_PREVIOUS_RESTRICTIONS}: Ignore the restrictions
     *                 applied to the graph during the creation stage and only
     *                 use the restrictions specified in this request if set to
     *                 {@code true}.
     *                 Supported values:
     *                 <ul>
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#TRUE TRUE}
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     *                 FALSE}
     *                 </ul>
     *                 The default value is {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#FALSE
     *                 FALSE}.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#RESTRICTION_THRESHOLD_VALUE
     *                 RESTRICTION_THRESHOLD_VALUE}: Value-based restriction
     *                 comparison. Any node or edge with a
     *                 RESTRICTIONS_VALUECOMPARED value greater than the {@code
     *                 restriction_threshold_value} will not be included in the
     *                 solution.
     *                         <li> {@link
     *                 com.gpudb.protocol.SolveGraphRequest.Options#UNIFORM_WEIGHTS
     *                 UNIFORM_WEIGHTS}: When specified, assigns the given
     *                 value to all the edges in the graph. Note that weights
     *                 provided in {@code weightsOnEdges} will override this
     *                 value.
     *                 </ul>
     *                 The default value is an empty {@link Map}.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public SolveGraphRequest setOptions(Map<String, String> options) {
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
        return this;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     * 
     * @return the schema object describing this class.
     * 
     */
    @Override
    public Schema getSchema() {
        return schema$;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     * 
     * @param index  the position of the field to get
     * 
     * @return value of the field with the given index.
     * 
     * @throws IndexOutOfBoundsException
     * 
     */
    @Override
    public Object get(int index) {
        switch (index) {
            case 0:
                return this.graphName;

            case 1:
                return this.weightsOnEdges;

            case 2:
                return this.restrictions;

            case 3:
                return this.solverType;

            case 4:
                return this.sourceNodeId;

            case 5:
                return this.destinationNodeIds;

            case 6:
                return this.nodeType;

            case 7:
                return this.sourceNode;

            case 8:
                return this.destinationNodes;

            case 9:
                return this.solutionTable;

            case 10:
                return this.options;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     * 
     * @param index  the position of the field to set
     * @param value  the value to set
     * 
     * @throws IndexOutOfBoundsException
     * 
     */
    @Override
    @SuppressWarnings("unchecked")
    public void put(int index, Object value) {
        switch (index) {
            case 0:
                this.graphName = (String)value;
                break;

            case 1:
                this.weightsOnEdges = (List<String>)value;
                break;

            case 2:
                this.restrictions = (List<String>)value;
                break;

            case 3:
                this.solverType = (String)value;
                break;

            case 4:
                this.sourceNodeId = (Long)value;
                break;

            case 5:
                this.destinationNodeIds = (List<Long>)value;
                break;

            case 6:
                this.nodeType = (String)value;
                break;

            case 7:
                this.sourceNode = (String)value;
                break;

            case 8:
                this.destinationNodes = (List<String>)value;
                break;

            case 9:
                this.solutionTable = (String)value;
                break;

            case 10:
                this.options = (Map<String, String>)value;
                break;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if( obj == this ) {
            return true;
        }

        if( (obj == null) || (obj.getClass() != this.getClass()) ) {
            return false;
        }

        SolveGraphRequest that = (SolveGraphRequest)obj;

        return ( this.graphName.equals( that.graphName )
                 && this.weightsOnEdges.equals( that.weightsOnEdges )
                 && this.restrictions.equals( that.restrictions )
                 && this.solverType.equals( that.solverType )
                 && ( this.sourceNodeId == that.sourceNodeId )
                 && this.destinationNodeIds.equals( that.destinationNodeIds )
                 && this.nodeType.equals( that.nodeType )
                 && this.sourceNode.equals( that.sourceNode )
                 && this.destinationNodes.equals( that.destinationNodes )
                 && this.solutionTable.equals( that.solutionTable )
                 && this.options.equals( that.options ) );
    }

    @Override
    public String toString() {
        GenericData gd = GenericData.get();
        StringBuilder builder = new StringBuilder();
        builder.append( "{" );
        builder.append( gd.toString( "graphName" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.graphName ) );
        builder.append( ", " );
        builder.append( gd.toString( "weightsOnEdges" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.weightsOnEdges ) );
        builder.append( ", " );
        builder.append( gd.toString( "restrictions" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.restrictions ) );
        builder.append( ", " );
        builder.append( gd.toString( "solverType" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.solverType ) );
        builder.append( ", " );
        builder.append( gd.toString( "sourceNodeId" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.sourceNodeId ) );
        builder.append( ", " );
        builder.append( gd.toString( "destinationNodeIds" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.destinationNodeIds ) );
        builder.append( ", " );
        builder.append( gd.toString( "nodeType" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.nodeType ) );
        builder.append( ", " );
        builder.append( gd.toString( "sourceNode" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.sourceNode ) );
        builder.append( ", " );
        builder.append( gd.toString( "destinationNodes" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.destinationNodes ) );
        builder.append( ", " );
        builder.append( gd.toString( "solutionTable" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.solutionTable ) );
        builder.append( ", " );
        builder.append( gd.toString( "options" ) );
        builder.append( ": " );
        builder.append( gd.toString( this.options ) );
        builder.append( "}" );

        return builder.toString();
    }

    @Override
    public int hashCode() {
        int hashCode = 1;
        hashCode = (31 * hashCode) + this.graphName.hashCode();
        hashCode = (31 * hashCode) + this.weightsOnEdges.hashCode();
        hashCode = (31 * hashCode) + this.restrictions.hashCode();
        hashCode = (31 * hashCode) + this.solverType.hashCode();
        hashCode = (31 * hashCode) + ((Long)this.sourceNodeId).hashCode();
        hashCode = (31 * hashCode) + this.destinationNodeIds.hashCode();
        hashCode = (31 * hashCode) + this.nodeType.hashCode();
        hashCode = (31 * hashCode) + this.sourceNode.hashCode();
        hashCode = (31 * hashCode) + this.destinationNodes.hashCode();
        hashCode = (31 * hashCode) + this.solutionTable.hashCode();
        hashCode = (31 * hashCode) + this.options.hashCode();
        return hashCode;
    }

}
