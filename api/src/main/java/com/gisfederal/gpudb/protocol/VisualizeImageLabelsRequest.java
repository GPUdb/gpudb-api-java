/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gisfederal.gpudb.protocol;

import java.util.LinkedHashMap;
import java.util.Map;
import org.apache.avro.Schema;
import org.apache.avro.SchemaBuilder;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.IndexedRecord;


/**
 * A set of parameters for {@link
 * com.gisfederal.gpudb.GPUdb#visualizeImageLabels(VisualizeImageLabelsRequest)}.
 * <p>
 * Generates a rasterized image tile containing text labels defined by data
 * contained in the given table, suitable for overlaying onto a feature image
 * tile covering the same area (for example one generated using {@link
 * com.gisfederal.gpudb.GPUdb#visualizeImage(VisualizeImageRequest)}).
 * <p>
 * All color values must be integers encoded in the format RRGGBB or AARRGGBB
 * (to specify the alpha value) when represented in hexadecimal; although note
 * that literal color values must be specified in base 10, not hexadecimal.
 * <p>
 * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
 * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
 * list of words defining style, variant, weight, stretch, or gravity, and SIZE
 * is a decimal number (size in points) or optionally followed by the unit
 * modifier 'px' for absolute size. All three sub-fields are optional; default
 * values will be used for omitted sub-fields. (For example, 'Helvetica Bold
 * Italic 10' specifies Helvetica, Bold and Italic, 10 points.) A substitute
 * font will be used if a requested font is not installed.
 */
public class VisualizeImageLabelsRequest implements IndexedRecord {
    private static final Schema schema$ = SchemaBuilder
            .record("VisualizeImageLabelsRequest")
            .namespace("com.gisfederal.gpudb")
            .fields()
                .name("tableName").type().stringType().noDefault()
                .name("xColumnName").type().stringType().noDefault()
                .name("yColumnName").type().stringType().noDefault()
                .name("xOffset").type().stringType().noDefault()
                .name("yOffset").type().stringType().noDefault()
                .name("textString").type().stringType().noDefault()
                .name("font").type().stringType().noDefault()
                .name("textColor").type().stringType().noDefault()
                .name("textAngle").type().stringType().noDefault()
                .name("textScale").type().stringType().noDefault()
                .name("drawBox").type().stringType().noDefault()
                .name("drawLeader").type().stringType().noDefault()
                .name("lineWidth").type().stringType().noDefault()
                .name("lineColor").type().stringType().noDefault()
                .name("fillColor").type().stringType().noDefault()
                .name("leaderXColumnName").type().stringType().noDefault()
                .name("leaderYColumnName").type().stringType().noDefault()
                .name("minX").type().doubleType().noDefault()
                .name("maxX").type().doubleType().noDefault()
                .name("minY").type().doubleType().noDefault()
                .name("maxY").type().doubleType().noDefault()
                .name("width").type().intType().noDefault()
                .name("height").type().intType().noDefault()
                .name("projection").type().stringType().noDefault()
                .name("options").type().map().values().stringType().noDefault()
            .endRecord();


    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     * 
     * @return  the schema for the class.
     * 
     */
    public static Schema getClassSchema() {
        return schema$;
    }


    /**
     * Spatial Reference System (i.e. EPSG Code).
     * A set of string constants for the parameter {@code projection}.
     */
    public static final class Projection {
        public static final String EPSG_4326 = "EPSG:4326";
        public static final String PLATE_CARREE = "PLATE_CARREE";
        public static final String _900913 = "900913";
        public static final String EPSG_900913 = "EPSG:900913";
        public static final String _102100 = "102100";
        public static final String EPSG_102100 = "EPSG:102100";
        public static final String _3857 = "3857";
        public static final String EPSG_3857 = "EPSG:3857";
        public static final String WEB_MERCATOR = "WEB_MERCATOR";

        private Projection() {  }
    }

    private String tableName;
    private String xColumnName;
    private String yColumnName;
    private String xOffset;
    private String yOffset;
    private String textString;
    private String font;
    private String textColor;
    private String textAngle;
    private String textScale;
    private String drawBox;
    private String drawLeader;
    private String lineWidth;
    private String lineColor;
    private String fillColor;
    private String leaderXColumnName;
    private String leaderYColumnName;
    private double minX;
    private double maxX;
    private double minY;
    private double maxY;
    private int width;
    private int height;
    private String projection;
    private Map<String, String> options;


    /**
     * Constructs a VisualizeImageLabelsRequest object with default parameters.
     */
    public VisualizeImageLabelsRequest() {
        tableName = "";
        xColumnName = "";
        yColumnName = "";
        xOffset = "";
        yOffset = "";
        textString = "";
        font = "";
        textColor = "";
        textAngle = "";
        textScale = "";
        drawBox = "";
        drawLeader = "";
        lineWidth = "";
        lineColor = "";
        fillColor = "";
        leaderXColumnName = "";
        leaderYColumnName = "";
        projection = "";
        options = new LinkedHashMap<>();
    }

    /**
     * Constructs a VisualizeImageLabelsRequest object with the specified
     * parameters.
     * 
     * @param tableName  Name of the table containing the data defining the
     *                   labels to render.
     * @param xColumnName  Name of the column containing the x coordinates of
     *                     the center points of the labels.
     * @param yColumnName  Name of the column containing the y coordinates of
     *                     the center points of the labels.
     * @param xOffset  Either the name of an integer column, or a single
     *                 literal integer value, defining the number of output
     *                 pixels by which the labels will be offset horizontally
     *                 from their specified x coordinates. If blank, an offset
     *                 of 0 will be used.
     * @param yOffset  Either the name of an integer column, or a single
     *                 literal integer value, defining the number of output
     *                 pixels by which the labels will be offset vertically
     *                 from their specified y coordinates. If blank, an offset
     *                 of 0 will be used.
     * @param textString  Either the name of a string column, or a single
     *                    literal string value (enclosed in double quotes),
     *                    defining the text for the labels.
     * @param font  Either the name of a string column, or a single literal
     *              string value (enclosed in double quotes), defining the
     *              fonts for the labels.
     * @param textColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the text color for the
     *                   labels. If blank, opaque black will be used.
     * @param textAngle  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the angle of clockwise
     *                   rotation (in degrees) for the labels. If blank, an
     *                   angle of 0 will be used.
     * @param textScale  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the scaling factor for
     *                   the labels. (1 is normal size, 0.5 is half size, 2 is
     *                   double size, etc.) If blank, a scaling factor of 1
     *                   will be used.
     * @param drawBox  Either the name of an integer column, or a single
     *                 literal integer value, defining a Boolean flag
     *                 indicating whether boxes will be drawn around the
     *                 labels. If blank, no boxes will be drawn.
     * @param drawLeader  Either the name of an integer column, or a single
     *                    literal integer value, defining a Boolean flag
     *                    indicating whether leader lines will be drawn from
     *                    the labels to points specified using {@code
     *                    leaderXColumnName} and {@code leaderYColumnName}. If
     *                    blank, no leader lines will be drawn.
     * @param lineWidth  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the line width in
     *                   output pixels for the labels' boxes and leader lines.
     *                   If blank, a line width of 1 will be used.
     * @param lineColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the line color for the
     *                   labels' boxes and leader lines. If blank, opaque black
     *                   will be used.
     * @param fillColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the fill color for the
     *                   labels' boxes. If blank, the boxes will not be filled.
     * @param leaderXColumnName  Name of the column containing the x
     *                           coordinates of the points to which the labels'
     *                           leader lines will be drawn. May be left blank
     *                           if no leader lines are to be drawn.
     * @param leaderYColumnName  Name of the column containing the y
     *                           coordinates of the points to which the labels'
     *                           leader lines will be drawn. May be left blank
     *                           if no leader lines are to be drawn.
     * @param minX  Lower bound for the x coordinates of labels to include in
     *              the image.
     * @param maxX  Upper bound for the x coordinates of labels to include in
     *              the image.
     * @param minY  Lower bound for the y coordinates of labels to include in
     *              the image.
     * @param maxY  Upper bound for the y coordinates of labels to include in
     *              the image.
     * @param width  Width of the generated image.
     * @param height  Height of the generated image.
     * @param projection  Spatial Reference System (i.e. EPSG Code).
     * @param options  Optional parameters.
     * 
     */
    public VisualizeImageLabelsRequest(String tableName, String xColumnName, String yColumnName, String xOffset, String yOffset, String textString, String font, String textColor, String textAngle, String textScale, String drawBox, String drawLeader, String lineWidth, String lineColor, String fillColor, String leaderXColumnName, String leaderYColumnName, double minX, double maxX, double minY, double maxY, int width, int height, String projection, Map<String, String> options) {
        this.tableName = (tableName == null) ? "" : tableName;
        this.xColumnName = (xColumnName == null) ? "" : xColumnName;
        this.yColumnName = (yColumnName == null) ? "" : yColumnName;
        this.xOffset = (xOffset == null) ? "" : xOffset;
        this.yOffset = (yOffset == null) ? "" : yOffset;
        this.textString = (textString == null) ? "" : textString;
        this.font = (font == null) ? "" : font;
        this.textColor = (textColor == null) ? "" : textColor;
        this.textAngle = (textAngle == null) ? "" : textAngle;
        this.textScale = (textScale == null) ? "" : textScale;
        this.drawBox = (drawBox == null) ? "" : drawBox;
        this.drawLeader = (drawLeader == null) ? "" : drawLeader;
        this.lineWidth = (lineWidth == null) ? "" : lineWidth;
        this.lineColor = (lineColor == null) ? "" : lineColor;
        this.fillColor = (fillColor == null) ? "" : fillColor;
        this.leaderXColumnName = (leaderXColumnName == null) ? "" : leaderXColumnName;
        this.leaderYColumnName = (leaderYColumnName == null) ? "" : leaderYColumnName;
        this.minX = minX;
        this.maxX = maxX;
        this.minY = minY;
        this.maxY = maxY;
        this.width = width;
        this.height = height;
        this.projection = (projection == null) ? "" : projection;
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
    }

    /**
     * 
     * @return Name of the table containing the data defining the labels to
     *         render.
     * 
     */
    public String getTableName() {
        return tableName;
    }

    /**
     * 
     * @param tableName  Name of the table containing the data defining the
     *                   labels to render.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setTableName(String tableName) {
        this.tableName = (tableName == null) ? "" : tableName;
        return this;
    }

    /**
     * 
     * @return Name of the column containing the x coordinates of the center
     *         points of the labels.
     * 
     */
    public String getXColumnName() {
        return xColumnName;
    }

    /**
     * 
     * @param xColumnName  Name of the column containing the x coordinates of
     *                     the center points of the labels.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setXColumnName(String xColumnName) {
        this.xColumnName = (xColumnName == null) ? "" : xColumnName;
        return this;
    }

    /**
     * 
     * @return Name of the column containing the y coordinates of the center
     *         points of the labels.
     * 
     */
    public String getYColumnName() {
        return yColumnName;
    }

    /**
     * 
     * @param yColumnName  Name of the column containing the y coordinates of
     *                     the center points of the labels.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setYColumnName(String yColumnName) {
        this.yColumnName = (yColumnName == null) ? "" : yColumnName;
        return this;
    }

    /**
     * 
     * @return Either the name of an integer column, or a single literal
     *         integer value, defining the number of output pixels by which the
     *         labels will be offset horizontally from their specified x
     *         coordinates. If blank, an offset of 0 will be used.
     * 
     */
    public String getXOffset() {
        return xOffset;
    }

    /**
     * 
     * @param xOffset  Either the name of an integer column, or a single
     *                 literal integer value, defining the number of output
     *                 pixels by which the labels will be offset horizontally
     *                 from their specified x coordinates. If blank, an offset
     *                 of 0 will be used.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setXOffset(String xOffset) {
        this.xOffset = (xOffset == null) ? "" : xOffset;
        return this;
    }

    /**
     * 
     * @return Either the name of an integer column, or a single literal
     *         integer value, defining the number of output pixels by which the
     *         labels will be offset vertically from their specified y
     *         coordinates. If blank, an offset of 0 will be used.
     * 
     */
    public String getYOffset() {
        return yOffset;
    }

    /**
     * 
     * @param yOffset  Either the name of an integer column, or a single
     *                 literal integer value, defining the number of output
     *                 pixels by which the labels will be offset vertically
     *                 from their specified y coordinates. If blank, an offset
     *                 of 0 will be used.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setYOffset(String yOffset) {
        this.yOffset = (yOffset == null) ? "" : yOffset;
        return this;
    }

    /**
     * 
     * @return Either the name of a string column, or a single literal string
     *         value (enclosed in double quotes), defining the text for the
     *         labels.
     * 
     */
    public String getTextString() {
        return textString;
    }

    /**
     * 
     * @param textString  Either the name of a string column, or a single
     *                    literal string value (enclosed in double quotes),
     *                    defining the text for the labels.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setTextString(String textString) {
        this.textString = (textString == null) ? "" : textString;
        return this;
    }

    /**
     * 
     * @return Either the name of a string column, or a single literal string
     *         value (enclosed in double quotes), defining the fonts for the
     *         labels.
     * 
     */
    public String getFont() {
        return font;
    }

    /**
     * 
     * @param font  Either the name of a string column, or a single literal
     *              string value (enclosed in double quotes), defining the
     *              fonts for the labels.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setFont(String font) {
        this.font = (font == null) ? "" : font;
        return this;
    }

    /**
     * 
     * @return Either the name of an integer column, or a single literal
     *         integer value, defining the text color for the labels. If blank,
     *         opaque black will be used.
     * 
     */
    public String getTextColor() {
        return textColor;
    }

    /**
     * 
     * @param textColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the text color for the
     *                   labels. If blank, opaque black will be used.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setTextColor(String textColor) {
        this.textColor = (textColor == null) ? "" : textColor;
        return this;
    }

    /**
     * 
     * @return Either the name of a numeric column, or a single literal numeric
     *         value, defining the angle of clockwise rotation (in degrees) for
     *         the labels. If blank, an angle of 0 will be used.
     * 
     */
    public String getTextAngle() {
        return textAngle;
    }

    /**
     * 
     * @param textAngle  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the angle of clockwise
     *                   rotation (in degrees) for the labels. If blank, an
     *                   angle of 0 will be used.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setTextAngle(String textAngle) {
        this.textAngle = (textAngle == null) ? "" : textAngle;
        return this;
    }

    /**
     * 
     * @return Either the name of a numeric column, or a single literal numeric
     *         value, defining the scaling factor for the labels. (1 is normal
     *         size, 0.5 is half size, 2 is double size, etc.) If blank, a
     *         scaling factor of 1 will be used.
     * 
     */
    public String getTextScale() {
        return textScale;
    }

    /**
     * 
     * @param textScale  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the scaling factor for
     *                   the labels. (1 is normal size, 0.5 is half size, 2 is
     *                   double size, etc.) If blank, a scaling factor of 1
     *                   will be used.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setTextScale(String textScale) {
        this.textScale = (textScale == null) ? "" : textScale;
        return this;
    }

    /**
     * 
     * @return Either the name of an integer column, or a single literal
     *         integer value, defining a Boolean flag indicating whether boxes
     *         will be drawn around the labels. If blank, no boxes will be
     *         drawn.
     * 
     */
    public String getDrawBox() {
        return drawBox;
    }

    /**
     * 
     * @param drawBox  Either the name of an integer column, or a single
     *                 literal integer value, defining a Boolean flag
     *                 indicating whether boxes will be drawn around the
     *                 labels. If blank, no boxes will be drawn.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setDrawBox(String drawBox) {
        this.drawBox = (drawBox == null) ? "" : drawBox;
        return this;
    }

    /**
     * 
     * @return Either the name of an integer column, or a single literal
     *         integer value, defining a Boolean flag indicating whether leader
     *         lines will be drawn from the labels to points specified using
     *         {@code leaderXColumnName} and {@code leaderYColumnName}. If
     *         blank, no leader lines will be drawn.
     * 
     */
    public String getDrawLeader() {
        return drawLeader;
    }

    /**
     * 
     * @param drawLeader  Either the name of an integer column, or a single
     *                    literal integer value, defining a Boolean flag
     *                    indicating whether leader lines will be drawn from
     *                    the labels to points specified using {@code
     *                    leaderXColumnName} and {@code leaderYColumnName}. If
     *                    blank, no leader lines will be drawn.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setDrawLeader(String drawLeader) {
        this.drawLeader = (drawLeader == null) ? "" : drawLeader;
        return this;
    }

    /**
     * 
     * @return Either the name of a numeric column, or a single literal numeric
     *         value, defining the line width in output pixels for the labels'
     *         boxes and leader lines. If blank, a line width of 1 will be
     *         used.
     * 
     */
    public String getLineWidth() {
        return lineWidth;
    }

    /**
     * 
     * @param lineWidth  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the line width in
     *                   output pixels for the labels' boxes and leader lines.
     *                   If blank, a line width of 1 will be used.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setLineWidth(String lineWidth) {
        this.lineWidth = (lineWidth == null) ? "" : lineWidth;
        return this;
    }

    /**
     * 
     * @return Either the name of an integer column, or a single literal
     *         integer value, defining the line color for the labels' boxes and
     *         leader lines. If blank, opaque black will be used.
     * 
     */
    public String getLineColor() {
        return lineColor;
    }

    /**
     * 
     * @param lineColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the line color for the
     *                   labels' boxes and leader lines. If blank, opaque black
     *                   will be used.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setLineColor(String lineColor) {
        this.lineColor = (lineColor == null) ? "" : lineColor;
        return this;
    }

    /**
     * 
     * @return Either the name of an integer column, or a single literal
     *         integer value, defining the fill color for the labels' boxes. If
     *         blank, the boxes will not be filled.
     * 
     */
    public String getFillColor() {
        return fillColor;
    }

    /**
     * 
     * @param fillColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the fill color for the
     *                   labels' boxes. If blank, the boxes will not be filled.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setFillColor(String fillColor) {
        this.fillColor = (fillColor == null) ? "" : fillColor;
        return this;
    }

    /**
     * 
     * @return Name of the column containing the x coordinates of the points to
     *         which the labels' leader lines will be drawn. May be left blank
     *         if no leader lines are to be drawn.
     * 
     */
    public String getLeaderXColumnName() {
        return leaderXColumnName;
    }

    /**
     * 
     * @param leaderXColumnName  Name of the column containing the x
     *                           coordinates of the points to which the labels'
     *                           leader lines will be drawn. May be left blank
     *                           if no leader lines are to be drawn.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setLeaderXColumnName(String leaderXColumnName) {
        this.leaderXColumnName = (leaderXColumnName == null) ? "" : leaderXColumnName;
        return this;
    }

    /**
     * 
     * @return Name of the column containing the y coordinates of the points to
     *         which the labels' leader lines will be drawn. May be left blank
     *         if no leader lines are to be drawn.
     * 
     */
    public String getLeaderYColumnName() {
        return leaderYColumnName;
    }

    /**
     * 
     * @param leaderYColumnName  Name of the column containing the y
     *                           coordinates of the points to which the labels'
     *                           leader lines will be drawn. May be left blank
     *                           if no leader lines are to be drawn.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setLeaderYColumnName(String leaderYColumnName) {
        this.leaderYColumnName = (leaderYColumnName == null) ? "" : leaderYColumnName;
        return this;
    }

    /**
     * 
     * @return Lower bound for the x coordinates of labels to include in the
     *         image.
     * 
     */
    public double getMinX() {
        return minX;
    }

    /**
     * 
     * @param minX  Lower bound for the x coordinates of labels to include in
     *              the image.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setMinX(double minX) {
        this.minX = minX;
        return this;
    }

    /**
     * 
     * @return Upper bound for the x coordinates of labels to include in the
     *         image.
     * 
     */
    public double getMaxX() {
        return maxX;
    }

    /**
     * 
     * @param maxX  Upper bound for the x coordinates of labels to include in
     *              the image.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setMaxX(double maxX) {
        this.maxX = maxX;
        return this;
    }

    /**
     * 
     * @return Lower bound for the y coordinates of labels to include in the
     *         image.
     * 
     */
    public double getMinY() {
        return minY;
    }

    /**
     * 
     * @param minY  Lower bound for the y coordinates of labels to include in
     *              the image.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setMinY(double minY) {
        this.minY = minY;
        return this;
    }

    /**
     * 
     * @return Upper bound for the y coordinates of labels to include in the
     *         image.
     * 
     */
    public double getMaxY() {
        return maxY;
    }

    /**
     * 
     * @param maxY  Upper bound for the y coordinates of labels to include in
     *              the image.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setMaxY(double maxY) {
        this.maxY = maxY;
        return this;
    }

    /**
     * 
     * @return Width of the generated image.
     * 
     */
    public int getWidth() {
        return width;
    }

    /**
     * 
     * @param width  Width of the generated image.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setWidth(int width) {
        this.width = width;
        return this;
    }

    /**
     * 
     * @return Height of the generated image.
     * 
     */
    public int getHeight() {
        return height;
    }

    /**
     * 
     * @param height  Height of the generated image.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setHeight(int height) {
        this.height = height;
        return this;
    }

    /**
     * 
     * @return Spatial Reference System (i.e. EPSG Code).
     * 
     */
    public String getProjection() {
        return projection;
    }

    /**
     * 
     * @param projection  Spatial Reference System (i.e. EPSG Code).
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setProjection(String projection) {
        this.projection = (projection == null) ? "" : projection;
        return this;
    }

    /**
     * 
     * @return Optional parameters.
     * 
     */
    public Map<String, String> getOptions() {
        return options;
    }

    /**
     * 
     * @param options  Optional parameters.
     * 
     * @return {@code this} to mimic the builder pattern.
     * 
     */
    public VisualizeImageLabelsRequest setOptions(Map<String, String> options) {
        this.options = (options == null) ? new LinkedHashMap<String, String>() : options;
        return this;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     * 
     * @return the schema object describing this class.
     * 
     */
    @Override
    public Schema getSchema() {
        return schema$;
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     * 
     * @param index  the position of the field to get
     * 
     * @return value of the field with the given index.
     * 
     * @throws IndexOutOfBoundsException
     * 
     */
    @Override
    public Object get(int index) {
        switch (index) {
            case 0:
                return this.tableName;

            case 1:
                return this.xColumnName;

            case 2:
                return this.yColumnName;

            case 3:
                return this.xOffset;

            case 4:
                return this.yOffset;

            case 5:
                return this.textString;

            case 6:
                return this.font;

            case 7:
                return this.textColor;

            case 8:
                return this.textAngle;

            case 9:
                return this.textScale;

            case 10:
                return this.drawBox;

            case 11:
                return this.drawLeader;

            case 12:
                return this.lineWidth;

            case 13:
                return this.lineColor;

            case 14:
                return this.fillColor;

            case 15:
                return this.leaderXColumnName;

            case 16:
                return this.leaderYColumnName;

            case 17:
                return this.minX;

            case 18:
                return this.maxX;

            case 19:
                return this.minY;

            case 20:
                return this.maxY;

            case 21:
                return this.width;

            case 22:
                return this.height;

            case 23:
                return this.projection;

            case 24:
                return this.options;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    /**
     * This method supports the Avro framework and is not intended to be called
     * directly by the user.
     * 
     * @param index  the position of the field to set
     * @param value  the value to set
     * 
     * @throws IndexOutOfBoundsException
     * 
     */
    @Override
    @SuppressWarnings("unchecked")
    public void put(int index, Object value) {
        switch (index) {
            case 0:
                this.tableName = (String)value;
                break;

            case 1:
                this.xColumnName = (String)value;
                break;

            case 2:
                this.yColumnName = (String)value;
                break;

            case 3:
                this.xOffset = (String)value;
                break;

            case 4:
                this.yOffset = (String)value;
                break;

            case 5:
                this.textString = (String)value;
                break;

            case 6:
                this.font = (String)value;
                break;

            case 7:
                this.textColor = (String)value;
                break;

            case 8:
                this.textAngle = (String)value;
                break;

            case 9:
                this.textScale = (String)value;
                break;

            case 10:
                this.drawBox = (String)value;
                break;

            case 11:
                this.drawLeader = (String)value;
                break;

            case 12:
                this.lineWidth = (String)value;
                break;

            case 13:
                this.lineColor = (String)value;
                break;

            case 14:
                this.fillColor = (String)value;
                break;

            case 15:
                this.leaderXColumnName = (String)value;
                break;

            case 16:
                this.leaderYColumnName = (String)value;
                break;

            case 17:
                this.minX = (Double)value;
                break;

            case 18:
                this.maxX = (Double)value;
                break;

            case 19:
                this.minY = (Double)value;
                break;

            case 20:
                this.maxY = (Double)value;
                break;

            case 21:
                this.width = (Integer)value;
                break;

            case 22:
                this.height = (Integer)value;
                break;

            case 23:
                this.projection = (String)value;
                break;

            case 24:
                this.options = (Map<String, String>)value;
                break;

            default:
                throw new IndexOutOfBoundsException("Invalid index specified.");
        }
    }

    @Override
    public boolean equals(Object obj) {
        if( obj == this ) {
            return true;
        }

        if( (obj == null) || (obj.getClass() != this.getClass()) ) {
            return false;
        }

        VisualizeImageLabelsRequest that = (VisualizeImageLabelsRequest)obj;

        return ( this.tableName.equals( that.tableName )
                 && this.xColumnName.equals( that.xColumnName )
                 && this.yColumnName.equals( that.yColumnName )
                 && this.xOffset.equals( that.xOffset )
                 && this.yOffset.equals( that.yOffset )
                 && this.textString.equals( that.textString )
                 && this.font.equals( that.font )
                 && this.textColor.equals( that.textColor )
                 && this.textAngle.equals( that.textAngle )
                 && this.textScale.equals( that.textScale )
                 && this.drawBox.equals( that.drawBox )
                 && this.drawLeader.equals( that.drawLeader )
                 && this.lineWidth.equals( that.lineWidth )
                 && this.lineColor.equals( that.lineColor )
                 && this.fillColor.equals( that.fillColor )
                 && this.leaderXColumnName.equals( that.leaderXColumnName )
                 && this.leaderYColumnName.equals( that.leaderYColumnName )
                 && ( (Double)this.minX ).equals( (Double)that.minX )
                 && ( (Double)this.maxX ).equals( (Double)that.maxX )
                 && ( (Double)this.minY ).equals( (Double)that.minY )
                 && ( (Double)this.maxY ).equals( (Double)that.maxY )
                 && ( this.width == that.width )
                 && ( this.height == that.height )
                 && this.projection.equals( that.projection )
                 && this.options.equals( that.options ) );
    }

    @Override
    public String toString() {
        GenericData gd = GenericData.get();
        StringBuilder builder = new StringBuilder();
        builder.append( gd.toString( "tableName" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.tableName ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "xColumnName" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.xColumnName ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "yColumnName" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.yColumnName ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "xOffset" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.xOffset ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "yOffset" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.yOffset ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "textString" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.textString ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "font" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.font ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "textColor" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.textColor ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "textAngle" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.textAngle ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "textScale" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.textScale ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "drawBox" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.drawBox ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "drawLeader" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.drawLeader ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "lineWidth" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.lineWidth ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "lineColor" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.lineColor ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "fillColor" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.fillColor ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "leaderXColumnName" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.leaderXColumnName ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "leaderYColumnName" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.leaderYColumnName ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "minX" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.minX ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "maxX" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.maxX ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "minY" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.minY ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "maxY" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.maxY ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "width" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.width ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "height" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.height ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "projection" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.projection ) );
        builder.append( gd.toString( "," ) );
        builder.append( gd.toString( "options" ) );
        builder.append( gd.toString( ":" ) );
        builder.append( gd.toString( this.options ) );

        return builder.toString();
    }

    @Override
    public int hashCode() {
        int hashCode = 1;
        hashCode = (31 * hashCode) + this.tableName.hashCode();
        hashCode = (31 * hashCode) + this.xColumnName.hashCode();
        hashCode = (31 * hashCode) + this.yColumnName.hashCode();
        hashCode = (31 * hashCode) + this.xOffset.hashCode();
        hashCode = (31 * hashCode) + this.yOffset.hashCode();
        hashCode = (31 * hashCode) + this.textString.hashCode();
        hashCode = (31 * hashCode) + this.font.hashCode();
        hashCode = (31 * hashCode) + this.textColor.hashCode();
        hashCode = (31 * hashCode) + this.textAngle.hashCode();
        hashCode = (31 * hashCode) + this.textScale.hashCode();
        hashCode = (31 * hashCode) + this.drawBox.hashCode();
        hashCode = (31 * hashCode) + this.drawLeader.hashCode();
        hashCode = (31 * hashCode) + this.lineWidth.hashCode();
        hashCode = (31 * hashCode) + this.lineColor.hashCode();
        hashCode = (31 * hashCode) + this.fillColor.hashCode();
        hashCode = (31 * hashCode) + this.leaderXColumnName.hashCode();
        hashCode = (31 * hashCode) + this.leaderYColumnName.hashCode();
        hashCode = (31 * hashCode) + ((Double)this.minX).hashCode();
        hashCode = (31 * hashCode) + ((Double)this.maxX).hashCode();
        hashCode = (31 * hashCode) + ((Double)this.minY).hashCode();
        hashCode = (31 * hashCode) + ((Double)this.maxY).hashCode();
        hashCode = (31 * hashCode) + this.width;
        hashCode = (31 * hashCode) + this.height;
        hashCode = (31 * hashCode) + this.projection.hashCode();
        hashCode = (31 * hashCode) + this.options.hashCode();
        return hashCode;
    }

}
