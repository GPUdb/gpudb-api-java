/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb;

import com.gpudb.protocol.*;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;

/**
 * Object that provides access to a specific GPUdb server. {@code GPUdb}
 * instances are thread safe and may be used from any number of threads
 * simultaneously.
 */
public class GPUdb extends GPUdbBase {

    /**
     * Creates a {@link GPUdb} instance for the GPUdb server at the
     * specified URL using default options.  Note that these options
     * cannot be changed subsequently; to use different options, a new
     * {@link GPUdb} instance must be created.
     * 
     * @param url  The URL of the GPUdb server.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(String url) throws GPUdbException {
        super(url, new Options());
    }

    /**
     * Creates a {@link GPUdb} instance for the GPUdb server at the
     * specified URL using default options.  Note that these options
     * cannot be changed subsequently; to use different options, a new
     * {@link GPUdb} instance must be created.
     * 
     * @param url  The URL of the GPUdb server.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(URL url) throws GPUdbException {
        super(url, new Options());
    }

    /**
     * Creates a {@link GPUdb} instance for the GPUdb server at the
     * specified URL using the specified options.  Note that these
     * options cannot be changed subsequently; to use different options,
     * a new {@link GPUdb} instance must be created.
     * 
     * @param url  The URL of the GPUdb server.
     * 
     * @param options  The options to use.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(String url, Options options) throws GPUdbException {
        super(url, options);
    }
    /**
     * Creates a {@link GPUdb} instance for the GPUdb server at the
     * specified URL using the specified options.  Note that these
     * options cannot be changed subsequently; to use different options,
     * a new {@link GPUdb} instance must be created.
     * 
     * @param url  The URL of the GPUdb server.
     * 
     * @param options  The options to use.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(URL url, Options options) throws GPUdbException {
        super(url, options);
    }

    /**
     * Delete a node from the system.  To delete a node, the data is first
     * distributed from the deleted node to all the other nodes.  Then the node
     * is taken out of service.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminDeleteNodeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminDeleteNodeResponse adminDeleteNode(AdminDeleteNodeRequest request) throws GPUdbException {
        AdminDeleteNodeResponse actualResponse_ = new AdminDeleteNodeResponse();
        submitRequest("/admin/delete/node", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Delete a node from the system.  To delete a node, the data is first
     * distributed from the deleted node to all the other nodes.  Then the node
     * is taken out of service.
     * 
     * @param rank  Rank number of the node being removed from the system.
     * @param authorization  The password that GPUdb is configured with during
     *                       startup. Incorrect or missing authorization code
     *                       will result in an error.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminDeleteNodeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminDeleteNodeResponse adminDeleteNode(int rank, String authorization, Map<String, String> options) throws GPUdbException {
        AdminDeleteNodeRequest actualRequest_ = new AdminDeleteNodeRequest(rank, authorization, options);
        AdminDeleteNodeResponse actualResponse_ = new AdminDeleteNodeResponse();
        submitRequest("/admin/delete/node", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns the list of shards and the corresponding rank and tom containing
     * the shard.  The response message contains arrays of 16384 (total number
     * of shards in the system) rank and tom numbers corresponding to each
     * shard.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminGetShardAssignmentsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminGetShardAssignmentsResponse adminGetShardAssignments(AdminGetShardAssignmentsRequest request) throws GPUdbException {
        AdminGetShardAssignmentsResponse actualResponse_ = new AdminGetShardAssignmentsResponse();
        submitRequest("/admin/getshardassignments", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns the list of shards and the corresponding rank and tom containing
     * the shard.  The response message contains arrays of 16384 (total number
     * of shards in the system) rank and tom numbers corresponding to each
     * shard.
     * 
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminGetShardAssignmentsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminGetShardAssignmentsResponse adminGetShardAssignments(Map<String, String> options) throws GPUdbException {
        AdminGetShardAssignmentsRequest actualRequest_ = new AdminGetShardAssignmentsRequest(options);
        AdminGetShardAssignmentsResponse actualResponse_ = new AdminGetShardAssignmentsResponse();
        submitRequest("/admin/getshardassignments", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Take the system offline. When the system is offline, no user operations
     * can be performed with the exception of a system shutdown.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminOfflineResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminOfflineResponse adminOffline(AdminOfflineRequest request) throws GPUdbException {
        AdminOfflineResponse actualResponse_ = new AdminOfflineResponse();
        submitRequest("/admin/offline", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Take the system offline. When the system is offline, no user operations
     * can be performed with the exception of a system shutdown.
     * 
     * @param offline  Set to true if desired state is offline.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminOfflineResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminOfflineResponse adminOffline(boolean offline, Map<String, String> options) throws GPUdbException {
        AdminOfflineRequest actualRequest_ = new AdminOfflineRequest(offline, options);
        AdminOfflineResponse actualResponse_ = new AdminOfflineResponse();
        submitRequest("/admin/offline", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Rebalance the database such that all the nodes contain approximately
     * equal number of records.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminRebalanceResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminRebalanceResponse adminRebalance(AdminRebalanceRequest request) throws GPUdbException {
        AdminRebalanceResponse actualResponse_ = new AdminRebalanceResponse();
        submitRequest("/admin/rebalance", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Rebalance the database such that all the nodes contain approximately
     * equal number of records.
     * 
     * @param tableNames  Names of the tables to be rebalanced.  If array is
     *                    empty, all tables will be rebalanced.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminRebalanceResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminRebalanceResponse adminRebalance(List<String> tableNames, Map<String, String> options) throws GPUdbException {
        AdminRebalanceRequest actualRequest_ = new AdminRebalanceRequest(tableNames, options);
        AdminRebalanceResponse actualResponse_ = new AdminRebalanceResponse();
        submitRequest("/admin/rebalance", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminSetShardAssignmentsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminSetShardAssignmentsResponse adminSetShardAssignments(AdminSetShardAssignmentsRequest request) throws GPUdbException {
        AdminSetShardAssignmentsResponse actualResponse_ = new AdminSetShardAssignmentsResponse();
        submitRequest("/admin/setshardassignments", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * 
     * @param version
     * @param partialReassignment
     * @param shardAssignmentsRank
     * @param shardAssignmentsTom
     * @param assignmentIndex
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminSetShardAssignmentsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminSetShardAssignmentsResponse adminSetShardAssignments(long version, boolean partialReassignment, List<Integer> shardAssignmentsRank, List<Integer> shardAssignmentsTom, List<Integer> assignmentIndex, Map<String, String> options) throws GPUdbException {
        AdminSetShardAssignmentsRequest actualRequest_ = new AdminSetShardAssignmentsRequest(version, partialReassignment, shardAssignmentsRank, shardAssignmentsTom, assignmentIndex, options);
        AdminSetShardAssignmentsResponse actualResponse_ = new AdminSetShardAssignmentsResponse();
        submitRequest("/admin/setshardassignments", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Exits the GPUdb server application. A authorization code is required
     * (chosen at the time of GPUdb configuration) to successfully complete
     * this request.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminShutdownResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminShutdownResponse adminShutdown(AdminShutdownRequest request) throws GPUdbException {
        AdminShutdownResponse actualResponse_ = new AdminShutdownResponse();
        submitRequest("/admin/shutdown", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Exits the GPUdb server application. A authorization code is required
     * (chosen at the time of GPUdb configuration) to successfully complete
     * this request.
     * 
     * @param exitType  Reserved for future use. User can pass an empty string.
     * @param authorization  The password that GPUdb is configured with during
     *                       startup. Incorrect or missing authorization code
     *                       will result in an error.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminShutdownResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminShutdownResponse adminShutdown(String exitType, String authorization, Map<String, String> options) throws GPUdbException {
        AdminShutdownRequest actualRequest_ = new AdminShutdownRequest(exitType, authorization, options);
        AdminShutdownResponse actualResponse_ = new AdminShutdownResponse();
        submitRequest("/admin/shutdown", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Verify database is in a consistent state.  When inconsistencies or
     * errors are found, the verified_ok flag in the response is set to false
     * and the list of errors found is provided in the error_list.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminVerifyDbResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminVerifyDbResponse adminVerifyDb(AdminVerifyDbRequest request) throws GPUdbException {
        AdminVerifyDbResponse actualResponse_ = new AdminVerifyDbResponse();
        submitRequest("/admin/verifydb", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Verify database is in a consistent state.  When inconsistencies or
     * errors are found, the verified_ok flag in the response is set to false
     * and the list of errors found is provided in the error_list.
     * 
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminVerifyDbResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminVerifyDbResponse adminVerifyDb(Map<String, String> options) throws GPUdbException {
        AdminVerifyDbRequest actualRequest_ = new AdminVerifyDbRequest(options);
        AdminVerifyDbResponse actualResponse_ = new AdminVerifyDbResponse();
        submitRequest("/admin/verifydb", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates and returns the convex hull for the values in a table
     * specified by {@code tableName}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateConvexHullResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateConvexHullResponse aggregateConvexHull(AggregateConvexHullRequest request) throws GPUdbException {
        AggregateConvexHullResponse actualResponse_ = new AggregateConvexHullResponse();
        submitRequest("/aggregate/convexhull", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates and returns the convex hull for the values in a table
     * specified by {@code tableName}.
     * 
     * @param tableName  Name of Table on which the operation will be
     *                   performed. Must be a valid table in GPUdb.  It can not
     *                   be a collection.
     * @param xColumnName  Name of the column containing the x coordinates of
     *                     the points for the operation being performed.
     * @param yColumnName  Name of the column containing the y coordinates of
     *                     the points for the operation being performed.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateConvexHullResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateConvexHullResponse aggregateConvexHull(String tableName, String xColumnName, String yColumnName, Map<String, String> options) throws GPUdbException {
        AggregateConvexHullRequest actualRequest_ = new AggregateConvexHullRequest(tableName, xColumnName, yColumnName, options);
        AggregateConvexHullResponse actualResponse_ = new AggregateConvexHullResponse();
        submitRequest("/aggregate/convexhull", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates unique combinations (i.e. groups) of values for the given
     * columns in a given table/view/collection and computes aggregates on each
     * unique combination. This is somewhat analogous to an SQL-style
     * SELECT...GROUP BY. Any column(s) can be grouped on, but only non-string
     * (i.e. numeric) columns may be used for computing aggregates.
     * <p>
     * The results can be paged via the {@code offset} and {@code limit}
     * parameters. For example, to get 10 groups with the largest counts the
     * inputs would be: limit=10, options={"sort_order":"descending",
     * "sort_by":"value"}.
     * <p>
     * {@code options} can be used to customize behavior of this call e.g.
     * filtering or sorting the results.
     * <p>
     * To group by 'x' and 'y' and compute the number of objects within each
     * group, use column_names=['x','y','count(*)'].  To also compute the sum
     * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
     * <p>
     * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max',
     * 'avg', 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop'
     * and 'var_samp'.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawAggregateGroupByResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawAggregateGroupByResponse aggregateGroupByRaw(AggregateGroupByRequest request) throws GPUdbException {
        RawAggregateGroupByResponse actualResponse_ = new RawAggregateGroupByResponse();
        submitRequest("/aggregate/groupby", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates unique combinations (i.e. groups) of values for the given
     * columns in a given table/view/collection and computes aggregates on each
     * unique combination. This is somewhat analogous to an SQL-style
     * SELECT...GROUP BY. Any column(s) can be grouped on, but only non-string
     * (i.e. numeric) columns may be used for computing aggregates.
     * <p>
     * The results can be paged via the {@code offset} and {@code limit}
     * parameters. For example, to get 10 groups with the largest counts the
     * inputs would be: limit=10, options={"sort_order":"descending",
     * "sort_by":"value"}.
     * <p>
     * {@code options} can be used to customize behavior of this call e.g.
     * filtering or sorting the results.
     * <p>
     * To group by 'x' and 'y' and compute the number of objects within each
     * group, use column_names=['x','y','count(*)'].  To also compute the sum
     * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
     * <p>
     * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max',
     * 'avg', 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop'
     * and 'var_samp'.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateGroupByResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateGroupByResponse aggregateGroupBy(AggregateGroupByRequest request) throws GPUdbException {
        RawAggregateGroupByResponse actualResponse_ = new RawAggregateGroupByResponse();
        submitRequest("/aggregate/groupby", request, actualResponse_, false);
        AggregateGroupByResponse response_ = new AggregateGroupByResponse();
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Calculates unique combinations (i.e. groups) of values for the given
     * columns in a given table/view/collection and computes aggregates on each
     * unique combination. This is somewhat analogous to an SQL-style
     * SELECT...GROUP BY. Any column(s) can be grouped on, but only non-string
     * (i.e. numeric) columns may be used for computing aggregates.
     * <p>
     * The results can be paged via the {@code offset} and {@code limit}
     * parameters. For example, to get 10 groups with the largest counts the
     * inputs would be: limit=10, options={"sort_order":"descending",
     * "sort_by":"value"}.
     * <p>
     * {@code options} can be used to customize behavior of this call e.g.
     * filtering or sorting the results.
     * <p>
     * To group by 'x' and 'y' and compute the number of objects within each
     * group, use column_names=['x','y','count(*)'].  To also compute the sum
     * of 'z' over each group, use column_names=['x','y','count(*)','sum(z)'].
     * <p>
     * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max',
     * 'avg', 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop'
     * and 'var_samp'.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be a valid table/view/collection in
     *                   GPUdb.
     * @param columnNames  List of one or more column names, expressions, and
     *                     aggregate expressions. Must include at least one
     *                     'grouping' column or expression.  If no aggregate is
     *                     included, count(*) will be computed as a default.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned Or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateGroupByResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateGroupByResponse aggregateGroupBy(String tableName, List<String> columnNames, long offset, long limit, Map<String, String> options) throws GPUdbException {
        AggregateGroupByRequest actualRequest_ = new AggregateGroupByRequest(tableName, columnNames, offset, limit, null, options);
        RawAggregateGroupByResponse actualResponse_ = new RawAggregateGroupByResponse();
        submitRequest("/aggregate/groupby", actualRequest_, actualResponse_, false);
        AggregateGroupByResponse response_ = new AggregateGroupByResponse();
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Performs a histogram calculation given a table, a column, and an
     * interval function. The {@code interval} is used to produce bins of that
     * size and the result, computed over the records falling within each bin,
     * is returned.  For each bin, the start value is inclusive, but the end
     * value is exclusive--except for the very last bin for which the end value
     * is also inclusive.  The value returned for each bin is the number of
     * records in it, except when a column name is provided as a *value_column*
     * in {@code options}.  In this latter case the sum of the values
     * corresponding to the *value_column* is used as the result instead.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateHistogramResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateHistogramResponse aggregateHistogram(AggregateHistogramRequest request) throws GPUdbException {
        AggregateHistogramResponse actualResponse_ = new AggregateHistogramResponse();
        submitRequest("/aggregate/histogram", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Performs a histogram calculation given a table, a column, and an
     * interval function. The {@code interval} is used to produce bins of that
     * size and the result, computed over the records falling within each bin,
     * is returned.  For each bin, the start value is inclusive, but the end
     * value is exclusive--except for the very last bin for which the end value
     * is also inclusive.  The value returned for each bin is the number of
     * records in it, except when a column name is provided as a *value_column*
     * in {@code options}.  In this latter case the sum of the values
     * corresponding to the *value_column* is used as the result instead.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be a valid table or collection in
     *                   GPUdb.
     * @param columnName  Name of a column or an expression of one or more
     *                    column names over which the histogram will be
     *                    calculated.
     * @param start  Lower end value of the histogram interval, inclusive.
     * @param end  Upper end value of the histogram interval, inclusive.
     * @param interval  The size of each bin within the start and end
     *                  parameters.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateHistogramResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateHistogramResponse aggregateHistogram(String tableName, String columnName, double start, double end, double interval, Map<String, String> options) throws GPUdbException {
        AggregateHistogramRequest actualRequest_ = new AggregateHistogramRequest(tableName, columnName, start, end, interval, options);
        AggregateHistogramResponse actualResponse_ = new AggregateHistogramResponse();
        submitRequest("/aggregate/histogram", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * This endpoint runs the k-means algorithm - a heuristic algorithm that
     * attempts to do k-means clustering.  An ideal k-means clustering
     * algorithm selects k points such that the sum of the mean squared
     * distances of each member of the set to the nearest of the k points is
     * minimized.  The k-means algorithm however does not necessarily produce
     * such an ideal cluster.   It begins with a randomly selected set of k
     * points and then refines the location of the points iteratively and
     * settles to a local minimum.  Various parameters and options are provided
     * to control the heuristic search.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateKMeansResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateKMeansResponse aggregateKMeans(AggregateKMeansRequest request) throws GPUdbException {
        AggregateKMeansResponse actualResponse_ = new AggregateKMeansResponse();
        submitRequest("/aggregate/kmeans", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * This endpoint runs the k-means algorithm - a heuristic algorithm that
     * attempts to do k-means clustering.  An ideal k-means clustering
     * algorithm selects k points such that the sum of the mean squared
     * distances of each member of the set to the nearest of the k points is
     * minimized.  The k-means algorithm however does not necessarily produce
     * such an ideal cluster.   It begins with a randomly selected set of k
     * points and then refines the location of the points iteratively and
     * settles to a local minimum.  Various parameters and options are provided
     * to control the heuristic search.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be a valid table or collection in
     *                   GPUdb.
     * @param columnNames  List of column names on which the operation would be
     *                     performed. If n columns are provided then each of
     *                     the k result points will have n dimensions
     *                     corresponding to the n columns.
     * @param k  The number of mean points to be determined by the algorithm.
     * @param tolerance  Stop iterating when the distances between successive
     *                   points is less than the given tolerance.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateKMeansResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateKMeansResponse aggregateKMeans(String tableName, List<String> columnNames, int k, double tolerance, Map<String, String> options) throws GPUdbException {
        AggregateKMeansRequest actualRequest_ = new AggregateKMeansRequest(tableName, columnNames, k, tolerance, options);
        AggregateKMeansResponse actualResponse_ = new AggregateKMeansResponse();
        submitRequest("/aggregate/kmeans", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates and returns the minimum and maximum values of a particular
     * column in a table.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateMinMaxResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateMinMaxResponse aggregateMinMax(AggregateMinMaxRequest request) throws GPUdbException {
        AggregateMinMaxResponse actualResponse_ = new AggregateMinMaxResponse();
        submitRequest("/aggregate/minmax", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates and returns the minimum and maximum values of a particular
     * column in a table.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be a valid table in GPUdb.
     * @param columnName  Name of a column or an expression of one or more
     *                    column on which the min-max will be calculated.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateMinMaxResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateMinMaxResponse aggregateMinMax(String tableName, String columnName, Map<String, String> options) throws GPUdbException {
        AggregateMinMaxRequest actualRequest_ = new AggregateMinMaxRequest(tableName, columnName, options);
        AggregateMinMaxResponse actualResponse_ = new AggregateMinMaxResponse();
        submitRequest("/aggregate/minmax", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates the requested statistics of a given column in a given table.
     * <p>
     * The available statistics are count (number of total objects), mean, stdv
     * (standard deviation), variance, skew, kurtosis, sum, min, max,
     * weighted_average, cardinality (unique count), estimated cardinality,
     * percentile and percentile_rank.
     * <p>
     * Estimated cardinality is calculated by using the hyperloglog
     * approximation technique.
     * <p>
     * Percentiles and percentile_ranks are approximate and are calculated
     * using the t-digest algorithm. They must include the desired
     * percentile/percentile_rank. To compute multiple percentiles each value
     * must be specified separately (i.e.
     * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
     * <p>
     * The weighted average statistic requires a weight_attribute to be
     * specified in {@code options}. The weighted average is then defined as
     * the sum of the products of {@code columnName} times the weight attribute
     * divided by the sum of the weight attribute.
     * <p>
     * The response includes a list of the statistics requested along with the
     * count of the number of items in the given set.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateStatisticsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateStatisticsResponse aggregateStatistics(AggregateStatisticsRequest request) throws GPUdbException {
        AggregateStatisticsResponse actualResponse_ = new AggregateStatisticsResponse();
        submitRequest("/aggregate/statistics", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates the requested statistics of a given column in a given table.
     * <p>
     * The available statistics are count (number of total objects), mean, stdv
     * (standard deviation), variance, skew, kurtosis, sum, min, max,
     * weighted_average, cardinality (unique count), estimated cardinality,
     * percentile and percentile_rank.
     * <p>
     * Estimated cardinality is calculated by using the hyperloglog
     * approximation technique.
     * <p>
     * Percentiles and percentile_ranks are approximate and are calculated
     * using the t-digest algorithm. They must include the desired
     * percentile/percentile_rank. To compute multiple percentiles each value
     * must be specified separately (i.e.
     * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
     * <p>
     * The weighted average statistic requires a weight_attribute to be
     * specified in {@code options}. The weighted average is then defined as
     * the sum of the products of {@code columnName} times the weight attribute
     * divided by the sum of the weight attribute.
     * <p>
     * The response includes a list of the statistics requested along with the
     * count of the number of items in the given set.
     * 
     * @param tableName  Name of the table on which the statistics operation
     *                   will be performed.
     * @param columnName  Name of the column for which the statistics are to be
     *                    calculated.
     * @param stats  Comma separated list of the statistics to calculate, e.g.
     *               "sum,mean".
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateStatisticsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateStatisticsResponse aggregateStatistics(String tableName, String columnName, String stats, Map<String, String> options) throws GPUdbException {
        AggregateStatisticsRequest actualRequest_ = new AggregateStatisticsRequest(tableName, columnName, stats, options);
        AggregateStatisticsResponse actualResponse_ = new AggregateStatisticsResponse();
        submitRequest("/aggregate/statistics", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Divides the given set into bins and calculates statistics of the values
     * of a value-column in each bin.  The bins are based on the values of a
     * given binning-column.  The statistics that may be requested are mean,
     * stdv (standard deviation), variance, skew, kurtosis, sum, min, max,
     * first, last and weighted average. In addition to the requested
     * statistics the count of total samples in each bin is returned. This
     * counts vector is just the histogram of the column used to divide the set
     * members into bins. The weighted average statistic requires a
     * weight_column to be specified in {@code options}. The weighted average
     * is then defined as the sum of the products of the value column times the
     * weight column divided by the sum of the weight column.
     * <p>
     * There are two methods for binning the set members. In the first, which
     * can be used for numeric valued binning-columns, a min, max and interval
     * are specified. The number of bins, nbins, is the integer upper bound of
     * (max-min)/interval. Values that fall in the range
     * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
     * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In
     * the second method, {@code options} bin_values specifies a list of
     * binning column values. Binning-columns whose value matches the nth
     * member of the bin_values list are placed in the nth bin. When a list is
     * provided the binning-column must be of type string or int.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateStatisticsByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateStatisticsByRangeResponse aggregateStatisticsByRange(AggregateStatisticsByRangeRequest request) throws GPUdbException {
        AggregateStatisticsByRangeResponse actualResponse_ = new AggregateStatisticsByRangeResponse();
        submitRequest("/aggregate/statistics/byrange", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Divides the given set into bins and calculates statistics of the values
     * of a value-column in each bin.  The bins are based on the values of a
     * given binning-column.  The statistics that may be requested are mean,
     * stdv (standard deviation), variance, skew, kurtosis, sum, min, max,
     * first, last and weighted average. In addition to the requested
     * statistics the count of total samples in each bin is returned. This
     * counts vector is just the histogram of the column used to divide the set
     * members into bins. The weighted average statistic requires a
     * weight_column to be specified in {@code options}. The weighted average
     * is then defined as the sum of the products of the value column times the
     * weight column divided by the sum of the weight column.
     * <p>
     * There are two methods for binning the set members. In the first, which
     * can be used for numeric valued binning-columns, a min, max and interval
     * are specified. The number of bins, nbins, is the integer upper bound of
     * (max-min)/interval. Values that fall in the range
     * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
     * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In
     * the second method, {@code options} bin_values specifies a list of
     * binning column values. Binning-columns whose value matches the nth
     * member of the bin_values list are placed in the nth bin. When a list is
     * provided the binning-column must be of type string or int.
     * 
     * @param tableName  Name of the table on which the ranged-statistics
     *                   operation will be performed.
     * @param selectExpression  For a non-empty expression statistics are
     *                          calculated for those records for which the
     *                          expression is true.
     * @param columnName  Name of the binning-column used to divide the set
     *                    samples into bins.
     * @param valueColumnName  Name of the value-column for which statistics
     *                         are to be computed.
     * @param stats  A string of comma separated list of the statistics to
     *               calculate, e.g. 'sum,mean'. Available statistics: mean,
     *               stdv (standard deviation), variance, skew, kurtosis, sum.
     * @param start  The lower bound of the binning-column.
     * @param end  The upper bound of the binning-column.
     * @param interval  The interval of a bin. Set members fall into bin i if
     *                  the binning-column falls in the range
     *                  [start+interval``*``i, start+interval``*``(i+1)).
     * @param options  Map of optional parameters:
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateStatisticsByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateStatisticsByRangeResponse aggregateStatisticsByRange(String tableName, String selectExpression, String columnName, String valueColumnName, String stats, double start, double end, double interval, Map<String, String> options) throws GPUdbException {
        AggregateStatisticsByRangeRequest actualRequest_ = new AggregateStatisticsByRangeRequest(tableName, selectExpression, columnName, valueColumnName, stats, start, end, interval, options);
        AggregateStatisticsByRangeResponse actualResponse_ = new AggregateStatisticsByRangeResponse();
        submitRequest("/aggregate/statistics/byrange", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns all the unique values from a particular column (specified by
     * {@code columnName}) of a particular table (specified by {@code
     * tableName}). If {@code columnName} is a numeric column the values will
     * be in {@code binaryEncodedResponse}. Otherwise if {@code columnName} is
     * a string column the values will be in {@code jsonEncodedResponse}.
     * {@code offset} and {@code limit} are used to page through the results if
     * there are large numbers of unique values. To get the first 10 unique
     * values sorted in descending order {@code options} would be::
     * <p>
     * {"limit":"10","sort_order":"descending"}.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawAggregateUniqueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawAggregateUniqueResponse aggregateUniqueRaw(AggregateUniqueRequest request) throws GPUdbException {
        RawAggregateUniqueResponse actualResponse_ = new RawAggregateUniqueResponse();
        submitRequest("/aggregate/unique", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns all the unique values from a particular column (specified by
     * {@code columnName}) of a particular table (specified by {@code
     * tableName}). If {@code columnName} is a numeric column the values will
     * be in {@code binaryEncodedResponse}. Otherwise if {@code columnName} is
     * a string column the values will be in {@code jsonEncodedResponse}.
     * {@code offset} and {@code limit} are used to page through the results if
     * there are large numbers of unique values. To get the first 10 unique
     * values sorted in descending order {@code options} would be::
     * <p>
     * {"limit":"10","sort_order":"descending"}.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateUniqueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateUniqueResponse aggregateUnique(AggregateUniqueRequest request) throws GPUdbException {
        RawAggregateUniqueResponse actualResponse_ = new RawAggregateUniqueResponse();
        submitRequest("/aggregate/unique", request, actualResponse_, false);
        AggregateUniqueResponse response_ = new AggregateUniqueResponse();
        response_.setTableName(actualResponse_.getTableName());
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Returns all the unique values from a particular column (specified by
     * {@code columnName}) of a particular table (specified by {@code
     * tableName}). If {@code columnName} is a numeric column the values will
     * be in {@code binaryEncodedResponse}. Otherwise if {@code columnName} is
     * a string column the values will be in {@code jsonEncodedResponse}.
     * {@code offset} and {@code limit} are used to page through the results if
     * there are large numbers of unique values. To get the first 10 unique
     * values sorted in descending order {@code options} would be::
     * <p>
     * {"limit":"10","sort_order":"descending"}.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be a valid table in GPUdb.
     * @param columnName  Name of the column or an expression containing one or
     *                    more column names on which the unique function would
     *                    be applied.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned. Or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateUniqueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateUniqueResponse aggregateUnique(String tableName, String columnName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        AggregateUniqueRequest actualRequest_ = new AggregateUniqueRequest(tableName, columnName, offset, limit, null, options);
        RawAggregateUniqueResponse actualResponse_ = new RawAggregateUniqueResponse();
        submitRequest("/aggregate/unique", actualRequest_, actualResponse_, false);
        AggregateUniqueResponse response_ = new AggregateUniqueResponse();
        response_.setTableName(actualResponse_.getTableName());
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * The alter_system_properties endpoint is primarily used to simplify the
     * testing of gpudb and is not expected to be used during normal execution.
     * Commands are given through the properties_update_map whose keys are
     * commands and values are strings representing integer values (for example
     * '8000') or boolean values ('true' or 'false').
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterSystemPropertiesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterSystemPropertiesResponse alterSystemProperties(AlterSystemPropertiesRequest request) throws GPUdbException {
        AlterSystemPropertiesResponse actualResponse_ = new AlterSystemPropertiesResponse();
        submitRequest("/alter/system/properties", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * The alter_system_properties endpoint is primarily used to simplify the
     * testing of gpudb and is not expected to be used during normal execution.
     * Commands are given through the properties_update_map whose keys are
     * commands and values are strings representing integer values (for example
     * '8000') or boolean values ('true' or 'false').
     * 
     * @param propertyUpdatesMap  Map containing the properties of the system
     *                            to be updated. Error if empty.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterSystemPropertiesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterSystemPropertiesResponse alterSystemProperties(Map<String, String> propertyUpdatesMap, Map<String, String> options) throws GPUdbException {
        AlterSystemPropertiesRequest actualRequest_ = new AlterSystemPropertiesRequest(propertyUpdatesMap, options);
        AlterSystemPropertiesResponse actualResponse_ = new AlterSystemPropertiesResponse();
        submitRequest("/alter/system/properties", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Apply various modifications to a table or collection. Available
     * modifications include:
     * <p>
     *      Cereating or deleting an index on a particular column. This can
     * speed up certain search queries (such as {@link
     * GPUdb#getRecordsRaw(GetRecordsRequest)}, {@link
     * GPUdb#deleteRecords(DeleteRecordsRequest)}, {@link
     * GPUdb#updateRecordsRaw(RawUpdateRecordsRequest)}) when using expressions
     * containing equality or relational operators on indexed columns. This
     * only applies to child tables.
     * <p>
     *      Making a table protected or not. Protected tables need the admin
     * password to be sent in a {@link GPUdb#clearTable(ClearTableRequest)} to
     * delete the table. This can be applied to child tables or collections or
     * views.
     * <p>
     *      Setting the ttl (time-to-live). This can be applied to child tables
     * or collections or views.
     * <p>
     *      Allowing homogeneous child tables. This only applies to
     * collections.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterTableResponse alterTable(AlterTableRequest request) throws GPUdbException {
        AlterTableResponse actualResponse_ = new AlterTableResponse();
        submitRequest("/alter/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Apply various modifications to a table or collection. Available
     * modifications include:
     * <p>
     *      Cereating or deleting an index on a particular column. This can
     * speed up certain search queries (such as {@link
     * GPUdb#getRecordsRaw(GetRecordsRequest)}, {@link
     * GPUdb#deleteRecords(String, List, Map)}, {@link
     * GPUdb#updateRecordsRaw(RawUpdateRecordsRequest)}) when using expressions
     * containing equality or relational operators on indexed columns. This
     * only applies to child tables.
     * <p>
     *      Making a table protected or not. Protected tables need the admin
     * password to be sent in a {@link GPUdb#clearTable(String, String, Map)}
     * to delete the table. This can be applied to child tables or collections
     * or views.
     * <p>
     *      Setting the ttl (time-to-live). This can be applied to child tables
     * or collections or views.
     * <p>
     *      Allowing homogeneous child tables. This only applies to
     * collections.
     * 
     * @param tableName  Table on which the operation will be performed. Must
     *                   be a valid table or collection in GPUdb.
     * @param action  Modification operation to be applied to the table or
     *                collection
     * @param value  The value of the modification. May be a column name,
     *               'true' or 'false', or a time-to-live depending on {@code
     *               action}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterTableResponse alterTable(String tableName, String action, String value, Map<String, String> options) throws GPUdbException {
        AlterTableRequest actualRequest_ = new AlterTableRequest(tableName, action, value, options);
        AlterTableResponse actualResponse_ = new AlterTableResponse();
        submitRequest("/alter/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Updates (adds or changes) metadata for tables. The metadata key and
     * values must both be strings. This is an easy way to annotate whole
     * tables rather than single records within tables.  Some examples of
     * metadata are owner of the table, table creation timestamp etc.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterTableMetadataResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterTableMetadataResponse alterTableMetadata(AlterTableMetadataRequest request) throws GPUdbException {
        AlterTableMetadataResponse actualResponse_ = new AlterTableMetadataResponse();
        submitRequest("/alter/table/metadata", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Updates (adds or changes) metadata for tables. The metadata key and
     * values must both be strings. This is an easy way to annotate whole
     * tables rather than single records within tables.  Some examples of
     * metadata are owner of the table, table creation timestamp etc.
     * 
     * @param tableNames  Names of the tables whose metadata will be updated.
     *                    All specified tables must exist in GPUdb, or GPUdb
     *                    will return an error.
     * @param metadataMap  A map which contains the metadata of the tables that
     *                     are to be updated. Note that only one map is
     *                     provided for all the tables; so the change will be
     *                     applied to every table. If the provided map is
     *                     empty, then all existing metadata for the table(s)
     *                     will be cleared.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterTableMetadataResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterTableMetadataResponse alterTableMetadata(List<String> tableNames, Map<String, String> metadataMap, Map<String, String> options) throws GPUdbException {
        AlterTableMetadataRequest actualRequest_ = new AlterTableMetadataRequest(tableNames, metadataMap, options);
        AlterTableMetadataResponse actualResponse_ = new AlterTableMetadataResponse();
        submitRequest("/alter/table/metadata", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Clears (drops) one or all tables in the GPUdb cluster. The operation is
     * synchronous meaning that the table will be cleared before the function
     * returns. The response payload returns the status of the operation along
     * with the name of the table that was cleared. For protected tables, this
     * function requires an administrator password without which the operation
     * will fail.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTableResponse clearTable(ClearTableRequest request) throws GPUdbException {
        ClearTableResponse actualResponse_ = new ClearTableResponse();
        submitRequest("/clear/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Clears (drops) one or all tables in the GPUdb cluster. The operation is
     * synchronous meaning that the table will be cleared before the function
     * returns. The response payload returns the status of the operation along
     * with the name of the table that was cleared. For protected tables, this
     * function requires an administrator password without which the operation
     * will fail.
     * 
     * @param tableName  Name of the table to be cleared. Must be an existing
     *                   GPUdb table. Empty string clears all available tables
     *                   in GPUdb.
     * @param authorization  Administrator password needed for clearing
     *                       protected tables. For unprotected tables the
     *                       string can be left blank.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTableResponse clearTable(String tableName, String authorization, Map<String, String> options) throws GPUdbException {
        ClearTableRequest actualRequest_ = new ClearTableRequest(tableName, authorization, options);
        ClearTableResponse actualResponse_ = new ClearTableResponse();
        submitRequest("/clear/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deactivates a table monitor previously created with {@link
     * GPUdb#createTableMonitor(CreateTableMonitorRequest)}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTableMonitorResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTableMonitorResponse clearTableMonitor(ClearTableMonitorRequest request) throws GPUdbException {
        ClearTableMonitorResponse actualResponse_ = new ClearTableMonitorResponse();
        submitRequest("/clear/tablemonitor", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deactivates a table monitor previously created with {@link
     * GPUdb#createTableMonitor(String, Map)}.
     * 
     * @param topicId  The topic ID returned by {@link
     *                 GPUdb#createTableMonitor(String, Map)}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTableMonitorResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTableMonitorResponse clearTableMonitor(String topicId, Map<String, String> options) throws GPUdbException {
        ClearTableMonitorRequest actualRequest_ = new ClearTableMonitorRequest(topicId, options);
        ClearTableMonitorResponse actualResponse_ = new ClearTableMonitorResponse();
        submitRequest("/clear/tablemonitor", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Clears or cancels the trigger identified by the specified handle. The
     * output returns the handle of the trigger cleared as well as indicating
     * success or failure of the trigger deactivation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTriggerResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTriggerResponse clearTrigger(ClearTriggerRequest request) throws GPUdbException {
        ClearTriggerResponse actualResponse_ = new ClearTriggerResponse();
        submitRequest("/clear/trigger", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Clears or cancels the trigger identified by the specified handle. The
     * output returns the handle of the trigger cleared as well as indicating
     * success or failure of the trigger deactivation.
     * 
     * @param triggerId  ID for the trigger to be deactivated.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTriggerResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTriggerResponse clearTrigger(String triggerId, Map<String, String> options) throws GPUdbException {
        ClearTriggerRequest actualRequest_ = new ClearTriggerRequest(triggerId, options);
        ClearTriggerResponse actualResponse_ = new ClearTriggerResponse();
        submitRequest("/clear/trigger", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a joint_table which is a list of tables and aliases for those
     * tables.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateJoinTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateJoinTableResponse createJoinTable(CreateJoinTableRequest request) throws GPUdbException {
        CreateJoinTableResponse actualResponse_ = new CreateJoinTableResponse();
        submitRequest("/create/jointable", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a joint_table which is a list of tables and aliases for those
     * tables.
     * 
     * @param joinTableName  Name of the join_table to be created. Must not be
     *                       the name of a currently existing GPUdb table or
     *                       join_table. Cannot be an empty string.
     * @param tableNames  The list of table names making up the joined set.
     *                    Corresponds to SQL statement from clause
     * @param aliases  The list of aliases for each of the corresponding
     *                 tables.
     * @param expression  An optional expression GPUdb uses to filter the join-
     *                    table being created.  Corresponds to SQL select
     *                    statement where clause. For details see <a
     *                    href="../../../../../concepts/index.html#expressions"
     *                    target="_top">concepts</a>.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateJoinTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateJoinTableResponse createJoinTable(String joinTableName, List<String> tableNames, List<String> aliases, String expression, Map<String, String> options) throws GPUdbException {
        CreateJoinTableRequest actualRequest_ = new CreateJoinTableRequest(joinTableName, tableNames, aliases, expression, options);
        CreateJoinTableResponse actualResponse_ = new CreateJoinTableResponse();
        submitRequest("/create/jointable", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new table or collection in GPUdb. If a new table is being
     * created then type of the table is given by {@code typeId} which must the
     * be the type id of a currently registered type (i.e. one created via
     * {@link GPUdb#createType(CreateTypeRequest)}). The table will be created
     * inside a collection if the option *collection_name* is specified. If
     * that collection does not already exist then it will be created. To
     * create a new, empty collection specify the collection name in {@code
     * tableName}, leave {@code typeId} blank, and set the *is_collection*
     * option to 'true'.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTableResponse createTable(CreateTableRequest request) throws GPUdbException {
        CreateTableResponse actualResponse_ = new CreateTableResponse();
        submitRequest("/create/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new table or collection in GPUdb. If a new table is being
     * created then type of the table is given by {@code typeId} which must the
     * be the type id of a currently registered type (i.e. one created via
     * {@link GPUdb#createType(String, String, Map, Map)}). The table will be
     * created inside a collection if the option *collection_name* is
     * specified. If that collection does not already exist then it will be
     * created. To create a new, empty collection specify the collection name
     * in {@code tableName}, leave {@code typeId} blank, and set the
     * *is_collection* option to 'true'.
     * 
     * @param tableName  Name of the table to be created. Must not be the name
     *                   of a currently existing GPUdb table of a different
     *                   type.  Error for requests with existing table of the
     *                   same name and type id may be suppressed by using the
     *                   {@code no_error_if_exists} option.  Cannot be an empty
     *                   string.  Valid characters are 'A-Za-z0-9_-(){}[] .:'
     *                   (excluding the single quote), with the first character
     *                   being one of 'A-Za-z0-9_'.  The maximum length is 256
     *                   characters.
     * @param typeId  ID of a currently registered type in GPUdb. All objects
     *                added to the newly created table will be of this type.
     *                Must be an empty string if the *is_collection* is 'true'.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTableResponse createTable(String tableName, String typeId, Map<String, String> options) throws GPUdbException {
        CreateTableRequest actualRequest_ = new CreateTableRequest(tableName, typeId, options);
        CreateTableResponse actualResponse_ = new CreateTableResponse();
        submitRequest("/create/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a monitor that watches for new records inserted into a
     * particular table (identified by {@code tableName}) and forwards copies
     * to subscribers via ZMQ. After this call completes, subscribe to the
     * returned {@code topicId} on the GPUdb ZMQ table monitor port (default
     * 9002). Each time an insert operation on the table completes, a multipart
     * message is published for that topic; the first part contains only the
     * topic ID, and each subsequent part contains one binary-encoded Avro
     * object that was inserted. The monitor will continue to run (regardless
     * of whether or not there are any subscribers) until deactivated with
     * {@link GPUdb#clearTableMonitor(ClearTableMonitorRequest)}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTableMonitorResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTableMonitorResponse createTableMonitor(CreateTableMonitorRequest request) throws GPUdbException {
        CreateTableMonitorResponse actualResponse_ = new CreateTableMonitorResponse();
        submitRequest("/create/tablemonitor", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a monitor that watches for new records inserted into a
     * particular table (identified by {@code tableName}) and forwards copies
     * to subscribers via ZMQ. After this call completes, subscribe to the
     * returned {@code topicId} on the GPUdb ZMQ table monitor port (default
     * 9002). Each time an insert operation on the table completes, a multipart
     * message is published for that topic; the first part contains only the
     * topic ID, and each subsequent part contains one binary-encoded Avro
     * object that was inserted. The monitor will continue to run (regardless
     * of whether or not there are any subscribers) until deactivated with
     * {@link GPUdb#clearTableMonitor(String, Map)}.
     * 
     * @param tableName  Name of the table to monitor. Must not refer to a
     *                   collection.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTableMonitorResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTableMonitorResponse createTableMonitor(String tableName, Map<String, String> options) throws GPUdbException {
        CreateTableMonitorRequest actualRequest_ = new CreateTableMonitorRequest(tableName, options);
        CreateTableMonitorResponse actualResponse_ = new CreateTableMonitorResponse();
        submitRequest("/create/tablemonitor", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Sets up an area trigger mechanism for two column_names for one or more
     * tables. (This function is essentially the two-dimensional version of
     * {@link GPUdb#createTriggerByRange(CreateTriggerByRangeRequest)}.) Once
     * the trigger has been activated, any record added to the listed tables(s)
     * via {@link GPUdb#insertRecordsRaw(RawInsertRecordsRequest)} with the
     * chosen columns' values falling within the specified region will trip the
     * trigger. All such records will be queued at GPUdb's trigger port-by
     * default '9001' but can also be obtained via {@link
     * GPUdb#showSystemStatus(ShowSystemStatusRequest)}-for any listening
     * client to collect. Active triggers can be cancelled by using the {@link
     * GPUdb#clearTrigger(ClearTriggerRequest)} endpoint or by clearing all
     * relevant tables.
     * <p>
     * The output returns the trigger handle as well as indicating success or
     * failure of the trigger activation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTriggerByAreaResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTriggerByAreaResponse createTriggerByArea(CreateTriggerByAreaRequest request) throws GPUdbException {
        CreateTriggerByAreaResponse actualResponse_ = new CreateTriggerByAreaResponse();
        submitRequest("/create/trigger/byarea", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Sets up an area trigger mechanism for two column_names for one or more
     * tables. (This function is essentially the two-dimensional version of
     * {@link GPUdb#createTriggerByRange(String, List, String, double, double,
     * Map)}.) Once the trigger has been activated, any record added to the
     * listed tables(s) via {@link
     * GPUdb#insertRecordsRaw(RawInsertRecordsRequest)} with the chosen
     * columns' values falling within the specified region will trip the
     * trigger. All such records will be queued at GPUdb's trigger port-by
     * default '9001' but can also be obtained via {@link
     * GPUdb#showSystemStatus(Map)}-for any listening client to collect. Active
     * triggers can be cancelled by using the {@link GPUdb#clearTrigger(String,
     * Map)} endpoint or by clearing all relevant tables.
     * <p>
     * The output returns the trigger handle as well as indicating success or
     * failure of the trigger activation.
     * 
     * @param requestId  ID for the trigger to be activated.
     * @param tableNames  Names of the tables on which the trigger will be
     *                    activated and maintained.
     * @param xColumnName  Name of a numeric column on which the trigger is
     *                     activated. Usually 'x' for geospatial data points.
     * @param xVector  The respective coordinate values for the region on which
     *                 the trigger is activated. This usually translates to the
     *                 x-coordinates of a geospatial region.
     * @param yColumnName  Name of a second numeric column on which the trigger
     *                     is activated. Usually 'y' for geospatial data
     *                     points.
     * @param yVector  The respective coordinate values for the region on which
     *                 the trigger is activated. This usually translates to the
     *                 y-coordinates of a geospatial region. Must be the same
     *                 length as xvals.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTriggerByAreaResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTriggerByAreaResponse createTriggerByArea(String requestId, List<String> tableNames, String xColumnName, List<Double> xVector, String yColumnName, List<Double> yVector, Map<String, String> options) throws GPUdbException {
        CreateTriggerByAreaRequest actualRequest_ = new CreateTriggerByAreaRequest(requestId, tableNames, xColumnName, xVector, yColumnName, yVector, options);
        CreateTriggerByAreaResponse actualResponse_ = new CreateTriggerByAreaResponse();
        submitRequest("/create/trigger/byarea", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Sets up a simple range trigger for a column_name for one or more tables.
     * Once the trigger has been activated, any record added to the listed
     * tables(s) via {@link GPUdb#insertRecordsRaw(RawInsertRecordsRequest)}
     * with the chosen column_name's value falling within the specified range
     * will trip the trigger. All such records will be queued at GPUdb's
     * trigger port-by default '9001' but can also be obtained via {@link
     * GPUdb#showSystemStatus(ShowSystemStatusRequest)}-for any listening
     * client to collect. Active triggers can be cancelled by using the {@link
     * GPUdb#clearTrigger(ClearTriggerRequest)} endpoint or by clearing all
     * relevant tables.
     * <p>
     * The output returns the trigger handle as well as indicating success or
     * failure of the trigger activation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTriggerByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTriggerByRangeResponse createTriggerByRange(CreateTriggerByRangeRequest request) throws GPUdbException {
        CreateTriggerByRangeResponse actualResponse_ = new CreateTriggerByRangeResponse();
        submitRequest("/create/trigger/byrange", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Sets up a simple range trigger for a column_name for one or more tables.
     * Once the trigger has been activated, any record added to the listed
     * tables(s) via {@link GPUdb#insertRecordsRaw(RawInsertRecordsRequest)}
     * with the chosen column_name's value falling within the specified range
     * will trip the trigger. All such records will be queued at GPUdb's
     * trigger port-by default '9001' but can also be obtained via {@link
     * GPUdb#showSystemStatus(Map)}-for any listening client to collect. Active
     * triggers can be cancelled by using the {@link GPUdb#clearTrigger(String,
     * Map)} endpoint or by clearing all relevant tables.
     * <p>
     * The output returns the trigger handle as well as indicating success or
     * failure of the trigger activation.
     * 
     * @param requestId  ID for the trigger request.
     * @param tableNames  Tables on which the trigger will be active.
     * @param columnName  Name of a numeric column_name on which the trigger is
     *                    activated.
     * @param min  The lower bound (inclusive) for the trigger range.
     * @param max  The upper bound (inclusive) for the trigger range.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTriggerByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTriggerByRangeResponse createTriggerByRange(String requestId, List<String> tableNames, String columnName, double min, double max, Map<String, String> options) throws GPUdbException {
        CreateTriggerByRangeRequest actualRequest_ = new CreateTriggerByRangeRequest(requestId, tableNames, columnName, min, max, options);
        CreateTriggerByRangeResponse actualResponse_ = new CreateTriggerByRangeResponse();
        submitRequest("/create/trigger/byrange", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new type in GPUdb describing the layout or schema of a table.
     * The type definition is a JSON string describing the fields (i.e.
     * columns) of the type. Each field consists of a name and a data type.
     * Supported data types are: double, float, int, long, string, and bytes.
     * In addition one or more properties can be specified for each column
     * which customize the memory usage and query availability of that column.
     * Note that some properties are mutually exclusive--i.e. they cannot be
     * specified for any given column simultaneously.  One example of mutually
     * exclusive properties are {@code data} and {@code store_only}.
     * <p>
     * To set a *primary key* on one or more columns include the property
     * 'primary_key' on the desired column_names. If a primary key is specified
     * then GPUdb enforces a uniqueness constraint in that only a single object
     * can exist with a given primary key. When {@link
     * GPUdb#insertRecordsRaw(RawInsertRecordsRequest) inserting} data into a
     * table with a primary key, depending on the parameters in the request,
     * incoming objects with primary keys that match existing objects will
     * either overwrite (i.e. update) the existing object or will be skipped
     * and not added into the set.
     * <p>
     * Example of a type definition with some of the parameters::
     * <p>
     *         {"type":"record",
     *         "name":"point",
     *         "fields":[{"name":"msg_id","type":"string"},
     *                         {"name":"x","type":"double"},
     *                         {"name":"y","type":"double"},
     *                         {"name":"TIMESTAMP","type":"double"},
     *                         {"name":"source","type":"string"},
     *                         {"name":"group_id","type":"string"},
     *                         {"name":"OBJECT_ID","type":"string"}]
     *         }
     * <p>
     * Properties::
     * <p>
     *         {"group_id":["store_only"],
     *         "msg_id":["store_only","text_search"]
     *         }
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTypeResponse createType(CreateTypeRequest request) throws GPUdbException {
        CreateTypeResponse actualResponse_ = new CreateTypeResponse();
        submitRequest("/create/type", request, actualResponse_, false);
        setTypeDescriptorIfMissing(actualResponse_.getTypeId(), actualResponse_.getLabel(), actualResponse_.getTypeDefinition(), actualResponse_.getProperties());
        return actualResponse_;
    }



    /**
     * Creates a new type in GPUdb describing the layout or schema of a table.
     * The type definition is a JSON string describing the fields (i.e.
     * columns) of the type. Each field consists of a name and a data type.
     * Supported data types are: double, float, int, long, string, and bytes.
     * In addition one or more properties can be specified for each column
     * which customize the memory usage and query availability of that column.
     * Note that some properties are mutually exclusive--i.e. they cannot be
     * specified for any given column simultaneously.  One example of mutually
     * exclusive properties are {@code data} and {@code store_only}.
     * <p>
     * To set a *primary key* on one or more columns include the property
     * 'primary_key' on the desired column_names. If a primary key is specified
     * then GPUdb enforces a uniqueness constraint in that only a single object
     * can exist with a given primary key. When {@link
     * GPUdb#insertRecordsRaw(RawInsertRecordsRequest) inserting} data into a
     * table with a primary key, depending on the parameters in the request,
     * incoming objects with primary keys that match existing objects will
     * either overwrite (i.e. update) the existing object or will be skipped
     * and not added into the set.
     * <p>
     * Example of a type definition with some of the parameters::
     * <p>
     *         {"type":"record",
     *         "name":"point",
     *         "fields":[{"name":"msg_id","type":"string"},
     *                         {"name":"x","type":"double"},
     *                         {"name":"y","type":"double"},
     *                         {"name":"TIMESTAMP","type":"double"},
     *                         {"name":"source","type":"string"},
     *                         {"name":"group_id","type":"string"},
     *                         {"name":"OBJECT_ID","type":"string"}]
     *         }
     * <p>
     * Properties::
     * <p>
     *         {"group_id":["store_only"],
     *         "msg_id":["store_only","text_search"]
     *         }
     * 
     * @param typeDefinition  a JSON string describing the columns of the type
     *                        to be registered.
     * @param label  A user-defined description string which can be used to
     *               differentiate between tables and types with otherwise
     *               identical schemas.
     * @param properties  Each key-value pair specifies the properties to use
     *                    for a given column where the key is the column name.
     *                    All keys used must be relevant column names for the
     *                    given table.  Specifying any property overrides the
     *                    default properties for that column (which is based on
     *                    the column's data type).
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTypeResponse createType(String typeDefinition, String label, Map<String, List<String>> properties, Map<String, String> options) throws GPUdbException {
        CreateTypeRequest actualRequest_ = new CreateTypeRequest(typeDefinition, label, properties, options);
        CreateTypeResponse actualResponse_ = new CreateTypeResponse();
        submitRequest("/create/type", actualRequest_, actualResponse_, false);
        setTypeDescriptorIfMissing(actualResponse_.getTypeId(), actualResponse_.getLabel(), actualResponse_.getTypeDefinition(), actualResponse_.getProperties());
        return actualResponse_;
    }



    /**
     * Deletes record(s) matching the provided criteria from the given table.
     * The record selection criteria can either be one or more  {@code
     * expressions} (matching multiple records) or a single record identified
     * by {@code record_id} optiona.  Note that the two selection criteria are
     * mutually exclusive.  This operation cannot be run on a collection or a
     * view.  The operation is synchronous meaning that a response will not be
     * available until the request is completely processed and all the matching
     * records are deleted.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteRecordsResponse deleteRecords(DeleteRecordsRequest request) throws GPUdbException {
        DeleteRecordsResponse actualResponse_ = new DeleteRecordsResponse();
        submitRequest("/delete/records", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes record(s) matching the provided criteria from the given table.
     * The record selection criteria can either be one or more  {@code
     * expressions} (matching multiple records) or a single record identified
     * by {@code record_id} optiona.  Note that the two selection criteria are
     * mutually exclusive.  This operation cannot be run on a collection or a
     * view.  The operation is synchronous meaning that a response will not be
     * available until the request is completely processed and all the matching
     * records are deleted.
     * 
     * @param tableName  Name of the table from which to delete records. The
     *                   set must be a currently existing table and not a
     *                   collection or a view.
     * @param expressions  A list of the actual predicates, one for each
     *                     select; format should follow the guidelines provided
     *                     {@link GPUdb#filter(String, String, String, Map)
     *                     here}. Specifying one or more {@code expressions} is
     *                     mutually exclusive to specifying {@code record_id}
     *                     in the {@code options}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteRecordsResponse deleteRecords(String tableName, List<String> expressions, Map<String, String> options) throws GPUdbException {
        DeleteRecordsRequest actualRequest_ = new DeleteRecordsRequest(tableName, expressions, options);
        DeleteRecordsResponse actualResponse_ = new DeleteRecordsResponse();
        submitRequest("/delete/records", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Executes a proc in the GPUdb Node.js proc server.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ExecuteProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ExecuteProcResponse executeProc(ExecuteProcRequest request) throws GPUdbException {
        ExecuteProcResponse actualResponse_ = new ExecuteProcResponse();
        submitRequest("/execute/proc", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Executes a proc in the GPUdb Node.js proc server.
     * 
     * @param name  Name of the proc to execute.
     * @param params  A map containing string parameters to pass to the proc.
     *                Each key/value pair specifies the name of a parameter and
     *                its value.
     * @param binParams  A map containing binary parameters to pass to the
     *                   proc. Each key/value pair specifies the name of a
     *                   parameter and its value.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ExecuteProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ExecuteProcResponse executeProc(String name, Map<String, String> params, Map<String, ByteBuffer> binParams, Map<String, String> options) throws GPUdbException {
        ExecuteProcRequest actualRequest_ = new ExecuteProcRequest(name, params, binParams, options);
        ExecuteProcResponse actualResponse_ = new ExecuteProcResponse();
        submitRequest("/execute/proc", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters data based on the specified expression.  The results are stored
     * in a result set with the given {@code viewName}.
     * <p>
     * For details see <a href="../../../../../concepts/index.html#expressions"
     * target="_top">concepts</a>.
     * <p>
     * The response message contains the number of points for which the
     * expression evaluated to be true, which is equivalent to the size of the
     * result view.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterResponse filter(FilterRequest request) throws GPUdbException {
        FilterResponse actualResponse_ = new FilterResponse();
        submitRequest("/filter", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters data based on the specified expression.  The results are stored
     * in a result set with the given {@code viewName}.
     * <p>
     * For details see <a href="../../../../../concepts/index.html#expressions"
     * target="_top">concepts</a>.
     * <p>
     * The response message contains the number of points for which the
     * expression evaluated to be true, which is equivalent to the size of the
     * result view.
     * 
     * @param tableName  Name of the table to filter.  This may be the ID of a
     *                   collection, table or a result set (for chaining
     *                   queries).  Collections may be filtered only if all
     *                   tables within the collection have the same type ID.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view .
     * @param expression  The select expression GPUdb uses to filter the
     *                    specified table.  For details see <a
     *                    href="../../../../../concepts/index.html#expressions"
     *                    target="_top">concepts</a>.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterResponse filter(String tableName, String viewName, String expression, Map<String, String> options) throws GPUdbException {
        FilterRequest actualRequest_ = new FilterRequest(tableName, viewName, expression, options);
        FilterResponse actualResponse_ = new FilterResponse();
        submitRequest("/filter", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table are within a named area of
     * interest (NAI/polygon). The operation is synchronous meaning that GPUdb
     * will not return the request until all the matching objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new resultant set (view) which satisfies the input NAI restriction
     * specification is created with the name {@code viewName} passed in as
     * part of the input.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByAreaResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByAreaResponse filterByArea(FilterByAreaRequest request) throws GPUdbException {
        FilterByAreaResponse actualResponse_ = new FilterByAreaResponse();
        submitRequest("/filter/byarea", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table are within a named area of
     * interest (NAI/polygon). The operation is synchronous meaning that GPUdb
     * will not return the request until all the matching objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new resultant set (view) which satisfies the input NAI restriction
     * specification is created with the name {@code viewName} passed in as
     * part of the input.
     * 
     * @param tableName  Name of the table to filter.  This may be the name of
     *                   a collection, a table or a view (when chaining
     *                   queries).  Collections may be filtered only if all
     *                   tables within the collection have the same type ID.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param xColumnName  Name of the column containing the x values to be
     *                     filtered.
     * @param xVector  List of x coordinates of the vertices of the polygon
     *                 representing the area to be filtered.
     * @param yColumnName  Name of the column containing the y values to be
     *                     filtered.
     * @param yVector  List of y coordinates of the vertices of the polygon
     *                 representing the area to be filtered.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByAreaResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByAreaResponse filterByArea(String tableName, String viewName, String xColumnName, List<Double> xVector, String yColumnName, List<Double> yVector, Map<String, String> options) throws GPUdbException {
        FilterByAreaRequest actualRequest_ = new FilterByAreaRequest(tableName, viewName, xColumnName, xVector, yColumnName, yVector, options);
        FilterByAreaResponse actualResponse_ = new FilterByAreaResponse();
        submitRequest("/filter/byarea", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates how many objects within the given table lie in a rectangular
     * box. The operation is synchronous meaning that GPUdb will not return the
     * request until all the objects are fully available. The response payload
     * provides the count of the resulting set. A new resultant set which
     * satisfies the input NAI restriction specification is also created when a
     * {@code viewName} is passed in as part of the input payload.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByBoxResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByBoxResponse filterByBox(FilterByBoxRequest request) throws GPUdbException {
        FilterByBoxResponse actualResponse_ = new FilterByBoxResponse();
        submitRequest("/filter/bybox", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates how many objects within the given table lie in a rectangular
     * box. The operation is synchronous meaning that GPUdb will not return the
     * request until all the objects are fully available. The response payload
     * provides the count of the resulting set. A new resultant set which
     * satisfies the input NAI restriction specification is also created when a
     * {@code viewName} is passed in as part of the input payload.
     * 
     * @param tableName  Name of the table on which the bounding box operation
     *                   will be performed. Must be a valid table in GPUdb.
     * @param viewName  Optional name of the result view that will be created
     *                  containing the results of the query. Must not be an
     *                  already existing collection, table or view in GPUdb.
     * @param xColumnName  Name of the column on which to perform the bounding
     *                     box query. If the table's data type is not a shape
     *                     type, must be a valid numeric column.
     * @param minX  Lower bound for the column chosen by {@code xColumnName}.
     *              Must be less than or equal to {@code maxX}.
     * @param maxX  Upper bound for {@code xColumnName}.  Must be greater than
     *              or equal to {@code minX}.
     * @param yColumnName  Name of a column on which to perform the bounding
     *                     box query. If the table's data type is not a shape
     *                     type, must be a valid numeric column.
     * @param minY  Lower bound for {@code yColumnName}. Must be less than or
     *              equal to {@code maxY}.
     * @param maxY  Upper bound for {@code yColumnName}. Must be greater than
     *              or equal to {@code minY}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByBoxResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByBoxResponse filterByBox(String tableName, String viewName, String xColumnName, double minX, double maxX, String yColumnName, double minY, double maxY, Map<String, String> options) throws GPUdbException {
        FilterByBoxRequest actualRequest_ = new FilterByBoxRequest(tableName, viewName, xColumnName, minX, maxX, yColumnName, minY, maxY, options);
        FilterByBoxResponse actualResponse_ = new FilterByBoxResponse();
        submitRequest("/filter/bybox", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Applies a geometry filter against a spatial column in a given table,
     * collection or view. The filtering geometry is provided by {@code
     * inputWkt}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByGeometryResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByGeometryResponse filterByGeometry(FilterByGeometryRequest request) throws GPUdbException {
        FilterByGeometryResponse actualResponse_ = new FilterByGeometryResponse();
        submitRequest("/filter/bygeometry", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Applies a geometry filter against a spatial column in a given table,
     * collection or view. The filtering geometry is provided by {@code
     * inputWkt}.
     * 
     * @param tableName  Name of the table on which the filter by spatial
     *                   operation will be performed.  Must be an existing
     *                   table, collection or view in GPUdb.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param columnName  Name of the column to be used in the filter. Must be
     *                    a spatial column. Typically this will be 'WKT'
     * @param inputWkt  A geometry in WKT format that will be used to filter
     *                  the objects in {@code tableName}
     * @param operation  The geometric filtering operation to perform
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByGeometryResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByGeometryResponse filterByGeometry(String tableName, String viewName, String columnName, String inputWkt, String operation, Map<String, String> options) throws GPUdbException {
        FilterByGeometryRequest actualRequest_ = new FilterByGeometryRequest(tableName, viewName, columnName, inputWkt, operation, options);
        FilterByGeometryResponse actualResponse_ = new FilterByGeometryResponse();
        submitRequest("/filter/bygeometry", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which records from a table have values in the given list for
     * the corresponding column. The operation is synchronous meaning that
     * GPUdb will not return a response until all the objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new resultant set (view) which satisfies the input filter
     * specification is also created if a {@code viewName} is passed in as part
     * of the request.
     * <p>
     * For example, if a type definition has the columns 'x' and 'y', then a
     * filter by list query with the column map {"x":["10.1", "2.3"],
     * "y":["0.0", "-31.5", "42.0"]} will return the count of all data points
     * whose x and y values match one of the values in the respective x- and
     * y-lists. If the filter_mode option is set to 'not_in_list' then the
     * filter will match all items that are not in the provided list(s).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByListResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByListResponse filterByList(FilterByListRequest request) throws GPUdbException {
        FilterByListResponse actualResponse_ = new FilterByListResponse();
        submitRequest("/filter/bylist", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which records from a table have values in the given list for
     * the corresponding column. The operation is synchronous meaning that
     * GPUdb will not return a response until all the objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new resultant set (view) which satisfies the input filter
     * specification is also created if a {@code viewName} is passed in as part
     * of the request.
     * <p>
     * For example, if a type definition has the columns 'x' and 'y', then a
     * filter by list query with the column map {"x":["10.1", "2.3"],
     * "y":["0.0", "-31.5", "42.0"]} will return the count of all data points
     * whose x and y values match one of the values in the respective x- and
     * y-lists. If the filter_mode option is set to 'not_in_list' then the
     * filter will match all items that are not in the provided list(s).
     * 
     * @param tableName  Name of the table to filter.  This may be the ID of a
     *                   collection, table or a result set (for chaining
     *                   queries).  Collections may be filtered only if all
     *                   tables within the collection have the same type ID.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param columnValuesMap  List of values for the corresponding column in
     *                         the table
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByListResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByListResponse filterByList(String tableName, String viewName, Map<String, List<String>> columnValuesMap, Map<String, String> options) throws GPUdbException {
        FilterByListRequest actualRequest_ = new FilterByListRequest(tableName, viewName, columnValuesMap, options);
        FilterByListResponse actualResponse_ = new FilterByListResponse();
        submitRequest("/filter/bylist", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table lie within a circle with the given
     * radius and center point (i.e. circular NAI). The operation is
     * synchronous meaning that GPUdb will not return a response until all the
     * objects are fully available. The response payload provides the count of
     * the resulting set. A new resultant set (view) which satisfies the input
     * circular NAI restriction specification is also created if a {@code
     * viewName} is passed in as part of the request.
     * <p>
     * For track data, all track points that lie within the circle plus one
     * point on either side of the circle (if the track goes beyond the circle)
     * will be included in the result. For shapes, e.g. polygons, all polygons
     * that intersect the circle will be included (even if none of the points
     * of the polygon fall within the circle).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByRadiusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByRadiusResponse filterByRadius(FilterByRadiusRequest request) throws GPUdbException {
        FilterByRadiusResponse actualResponse_ = new FilterByRadiusResponse();
        submitRequest("/filter/byradius", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table lie within a circle with the given
     * radius and center point (i.e. circular NAI). The operation is
     * synchronous meaning that GPUdb will not return a response until all the
     * objects are fully available. The response payload provides the count of
     * the resulting set. A new resultant set (view) which satisfies the input
     * circular NAI restriction specification is also created if a {@code
     * viewName} is passed in as part of the request.
     * <p>
     * For track data, all track points that lie within the circle plus one
     * point on either side of the circle (if the track goes beyond the circle)
     * will be included in the result. For shapes, e.g. polygons, all polygons
     * that intersect the circle will be included (even if none of the points
     * of the polygon fall within the circle).
     * 
     * @param tableName  Name of the table on which the filter by radius
     *                   operation will be performed.  Must be an existing
     *                   table in GPUdb.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param xColumnName  Name of the column to be used for the x-coordinate
     *                     (the longitude) of the center.
     * @param xCenter  Value of the longitude of the center. Must be within
     *                 [-180.0, 180.0].  The minimum allowed value is -180. The
     *                 maximum allowed value is 180.
     * @param yColumnName  Name of the column to be used for the y-coordinate-
     *                     the latitude-of the center.
     * @param yCenter  Value of the latitude of the center. Must be within
     *                 [-90.0, 90.0].  The minimum allowed value is -90. The
     *                 maximum allowed value is 90.
     * @param radius  The radius of the circle within which the search will be
     *                performed. Must be a non-zero positive value. It is in
     *                meters; so, for example, a value of '42000' means 42 km.
     *                The minimum allowed value is 0. The maximum allowed value
     *                is MAX_INT.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByRadiusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByRadiusResponse filterByRadius(String tableName, String viewName, String xColumnName, double xCenter, String yColumnName, double yCenter, double radius, Map<String, String> options) throws GPUdbException {
        FilterByRadiusRequest actualRequest_ = new FilterByRadiusRequest(tableName, viewName, xColumnName, xCenter, yColumnName, yCenter, radius, options);
        FilterByRadiusResponse actualResponse_ = new FilterByRadiusResponse();
        submitRequest("/filter/byradius", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table have a column that is within the
     * given bounds. An object from the table identified by {@code tableName}
     * is added to the view {@code viewName} if its column is within [{@code
     * lowerBound}, {@code upperBound}] (inclusive). The operation is
     * synchronous. The response provides a count of the number of objects
     * which passed the bound filter.
     * <p>
     * For track objects, the count reflects how many points fall within the
     * given bounds (which may not include all the track points of any given
     * track).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByRangeResponse filterByRange(FilterByRangeRequest request) throws GPUdbException {
        FilterByRangeResponse actualResponse_ = new FilterByRangeResponse();
        submitRequest("/filter/byrange", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table have a column that is within the
     * given bounds. An object from the table identified by {@code tableName}
     * is added to the view {@code viewName} if its column is within [{@code
     * lowerBound}, {@code upperBound}] (inclusive). The operation is
     * synchronous. The response provides a count of the number of objects
     * which passed the bound filter.
     * <p>
     * For track objects, the count reflects how many points fall within the
     * given bounds (which may not include all the track points of any given
     * track).
     * 
     * @param tableName  Name of the table on which the filter by range
     *                   operation will be performed.  Must be a valid GPUdb
     *                   table.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param columnName  Name of a column or an expression of one or more
     *                    columns on which the operation would be applied.
     * @param lowerBound  Value of the lower bound (inclusive).
     * @param upperBound  Value of the upper bound (inclusive).
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByRangeResponse filterByRange(String tableName, String viewName, String columnName, double lowerBound, double upperBound, Map<String, String> options) throws GPUdbException {
        FilterByRangeRequest actualRequest_ = new FilterByRangeRequest(tableName, viewName, columnName, lowerBound, upperBound, options);
        FilterByRangeResponse actualResponse_ = new FilterByRangeResponse();
        submitRequest("/filter/byrange", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters objects matching all points of the given track (works only on
     * track type data).  It allows users to specify a particular track to find
     * all other points in the table that fall within specified ranges-spatial
     * and temporal-of all points of the given track. Additionally, the user
     * can specify another track to see if the two intersect (or go close to
     * each other within the specified ranges). The user also has the
     * flexibility of using different metrics for the spatial distance
     * calculation: Euclidean (flat geometry) or Great Circle (spherical
     * geometry to approximate the Earth's surface distances). The filtered
     * points are stored in a newly created result set. The return value of the
     * function is the number of points in the resultant set (view).
     * <p>
     * This operation is synchronous meaning that GPUdb will not return a
     * response until all the objects are fully available.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterBySeriesResponse filterBySeries(FilterBySeriesRequest request) throws GPUdbException {
        FilterBySeriesResponse actualResponse_ = new FilterBySeriesResponse();
        submitRequest("/filter/byseries", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters objects matching all points of the given track (works only on
     * track type data).  It allows users to specify a particular track to find
     * all other points in the table that fall within specified ranges-spatial
     * and temporal-of all points of the given track. Additionally, the user
     * can specify another track to see if the two intersect (or go close to
     * each other within the specified ranges). The user also has the
     * flexibility of using different metrics for the spatial distance
     * calculation: Euclidean (flat geometry) or Great Circle (spherical
     * geometry to approximate the Earth's surface distances). The filtered
     * points are stored in a newly created result set. The return value of the
     * function is the number of points in the resultant set (view).
     * <p>
     * This operation is synchronous meaning that GPUdb will not return a
     * response until all the objects are fully available.
     * 
     * @param tableName  Name of the table on which the filter by track
     *                   operation will be performed. Must be a currently
     *                   existing table with track semantic type.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param trackId  The ID of the track which will act as the filtering
     *                 points. Must be an existing track within the given
     *                 table.
     * @param targetTrackIds  Up to one track ID to intersect with the "filter"
     *                        track. If any provided, it must be an valid track
     *                        ID within the given set.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterBySeriesResponse filterBySeries(String tableName, String viewName, String trackId, List<String> targetTrackIds, Map<String, String> options) throws GPUdbException {
        FilterBySeriesRequest actualRequest_ = new FilterBySeriesRequest(tableName, viewName, trackId, targetTrackIds, options);
        FilterBySeriesResponse actualResponse_ = new FilterBySeriesResponse();
        submitRequest("/filter/byseries", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table, collection or view match a string
     * expression for the given string columns. The 'mode' may be:
     * <p>
     *     'search' for full text search query with wildcards and boolean
     * operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode,
     * no column can be specified in {@code columnNames}; GPUdb will search
     * through all string columns of the table that have text search enabled.
     * Also, the first character of the regular expression cannot be a wildcard
     * (* or ?).
     * <p>
     * * 'equals' for an exact whole-string match
     * * 'contains' for a partial substring match (not accelerated)
     * * 'starts_with' to find strings that start with the given expression
     * (not accelerated)
     * * 'regex' - to use a full regular expression search (not accelerated)
     * <p>
     * The options 'case_sensitive' can be used to modify the behavior for all
     * modes except 'search'
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByStringResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByStringResponse filterByString(FilterByStringRequest request) throws GPUdbException {
        FilterByStringResponse actualResponse_ = new FilterByStringResponse();
        submitRequest("/filter/bystring", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table, collection or view match a string
     * expression for the given string columns. The 'mode' may be:
     * <p>
     *     'search' for full text search query with wildcards and boolean
     * operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode,
     * no column can be specified in {@code columnNames}; GPUdb will search
     * through all string columns of the table that have text search enabled.
     * Also, the first character of the regular expression cannot be a wildcard
     * (* or ?).
     * <p>
     * * 'equals' for an exact whole-string match
     * * 'contains' for a partial substring match (not accelerated)
     * * 'starts_with' to find strings that start with the given expression
     * (not accelerated)
     * * 'regex' - to use a full regular expression search (not accelerated)
     * <p>
     * The options 'case_sensitive' can be used to modify the behavior for all
     * modes except 'search'
     * 
     * @param tableName  Name of the table on which the filter operation will
     *                   be performed.  Must be a valid GPUdb table, collection
     *                   or view.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param expression  The expression with which to filter the table.
     * @param mode  The string filtering mode to apply. See above for details.
     * @param columnNames  List of columns on which to apply the filter.
     *                     Ignored for 'search' mode.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByStringResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByStringResponse filterByString(String tableName, String viewName, String expression, String mode, List<String> columnNames, Map<String, String> options) throws GPUdbException {
        FilterByStringRequest actualRequest_ = new FilterByStringRequest(tableName, viewName, expression, mode, columnNames, options);
        FilterByStringResponse actualResponse_ = new FilterByStringResponse();
        submitRequest("/filter/bystring", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters objects in one table based on objects in another table. The user
     * must specify matching column types from the two tables (i.e. the target
     * table from which objects will be filtered and the source table based on
     * which the filter will be created); the column names need not be the
     * same. If a {@code viewName} is specified, then the filtered objects will
     * then be put in a newly created view. The operation is synchronous,
     * meaning that GPUdb will not return until all objects are fully available
     * in the result view. The return value contains the count (i.e. the size)
     * of the resulting view.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByTableResponse filterByTable(FilterByTableRequest request) throws GPUdbException {
        FilterByTableResponse actualResponse_ = new FilterByTableResponse();
        submitRequest("/filter/bytable", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters objects in one table based on objects in another table. The user
     * must specify matching column types from the two tables (i.e. the target
     * table from which objects will be filtered and the source table based on
     * which the filter will be created); the column names need not be the
     * same. If a {@code viewName} is specified, then the filtered objects will
     * then be put in a newly created view. The operation is synchronous,
     * meaning that GPUdb will not return until all objects are fully available
     * in the result view. The return value contains the count (i.e. the size)
     * of the resulting view.
     * 
     * @param tableName  Name of the table whose data will be filtered. Must be
     *                   an existing table in GPUdb.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param columnName  Name of the column by whose value the data will be
     *                    filtered from the table designated by {@code
     *                    tableName}.
     * @param sourceTableName  Name of the table whose data will be compared
     *                         against in the table called {@code tableName}.
     *                         Must be an existing table in GPUdb.
     * @param sourceTableColumnName  Name of the column in the {@code
     *                               sourceTableName} whose values will be used
     *                               as the filter for table {@code tableName}.
     *                               Must match the type of the {@code
     *                               columnName}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByTableResponse filterByTable(String tableName, String viewName, String columnName, String sourceTableName, String sourceTableColumnName, Map<String, String> options) throws GPUdbException {
        FilterByTableRequest actualRequest_ = new FilterByTableRequest(tableName, viewName, columnName, sourceTableName, sourceTableColumnName, options);
        FilterByTableResponse actualResponse_ = new FilterByTableResponse();
        submitRequest("/filter/bytable", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table has a particular value for a
     * particular column. The input parameters provide a way to specify either
     * a String or a Double valued column and a desired value for the column on
     * which the filter is performed. The operation is synchronous meaning that
     * GPUdb will not return a response until all the objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new result view which satisfies the input filter restriction
     * specification is also created with a view name passed in as part of the
     * input payload.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByValueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByValueResponse filterByValue(FilterByValueRequest request) throws GPUdbException {
        FilterByValueResponse actualResponse_ = new FilterByValueResponse();
        submitRequest("/filter/byvalue", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table has a particular value for a
     * particular column. The input parameters provide a way to specify either
     * a String or a Double valued column and a desired value for the column on
     * which the filter is performed. The operation is synchronous meaning that
     * GPUdb will not return a response until all the objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new result view which satisfies the input filter restriction
     * specification is also created with a view name passed in as part of the
     * input payload.
     * 
     * @param tableName  Name of an existing GPUdb table on which to perform
     *                   the calculation.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Must not be an already existing
     *                  collection, table or view.
     * @param isString  Indicates whether the value being searched for is
     *                  string or numeric.
     * @param value  The value to search for.
     * @param valueStr  The string value to search for.
     * @param columnName  Name of a column or an expression of one or more
     *                    columns on which the filter by value would be
     *                    applied.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByValueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByValueResponse filterByValue(String tableName, String viewName, boolean isString, double value, String valueStr, String columnName, Map<String, String> options) throws GPUdbException {
        FilterByValueRequest actualRequest_ = new FilterByValueRequest(tableName, viewName, isString, value, valueStr, columnName, options);
        FilterByValueResponse actualResponse_ = new FilterByValueResponse();
        submitRequest("/filter/byvalue", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can only be
     * performed on tables or on homogeneous collection (collections whose
     * children all have the same type). Records can be returned encoded as
     * binary or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawGetRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawGetRecordsResponse getRecordsRaw(GetRecordsRequest request) throws GPUdbException {
        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can only be
     * performed on tables or on homogeneous collection (collections whose
     * children all have the same type). Records can be returned encoded as
     * binary or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsResponse<TResponse> getRecords(Object typeDescriptor, GetRecordsRequest request) throws GPUdbException {
        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", request, actualResponse_, false);
        GetRecordsResponse<TResponse> response_ = new GetRecordsResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeName(actualResponse_.getTypeName());
        response_.setTypeSchema(actualResponse_.getTypeSchema());
        response_.setData(this.<TResponse>decode(typeDescriptor, actualResponse_.getRecordsBinary()));
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can only be
     * performed on tables or on homogeneous collection (collections whose
     * children all have the same type). Records can be returned encoded as
     * binary or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param tableName  Name of the table from which the records will be
     *                   fetched. Must be a table, view or homogeneous
     *                   collection.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned. Or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsResponse<TResponse> getRecords(Object typeDescriptor, String tableName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsRequest actualRequest_ = new GetRecordsRequest(tableName, offset, limit, null, options);
        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", actualRequest_, actualResponse_, false);
        GetRecordsResponse<TResponse> response_ = new GetRecordsResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeName(actualResponse_.getTypeName());
        response_.setTypeSchema(actualResponse_.getTypeSchema());
        response_.setData(this.<TResponse>decode(typeDescriptor, actualResponse_.getRecordsBinary()));
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can only be
     * performed on tables or on homogeneous collection (collections whose
     * children all have the same type). Records can be returned encoded as
     * binary or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsResponse<TResponse> getRecords(GetRecordsRequest request) throws GPUdbException {
        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", request, actualResponse_, false);
        GetRecordsResponse<TResponse> response_ = new GetRecordsResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeName(actualResponse_.getTypeName());
        response_.setTypeSchema(actualResponse_.getTypeSchema());
        response_.setData(this.<TResponse>decode(actualResponse_.getTypeName(), actualResponse_.getRecordsBinary()));
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can only be
     * performed on tables or on homogeneous collection (collections whose
     * children all have the same type). Records can be returned encoded as
     * binary or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param tableName  Name of the table from which the records will be
     *                   fetched. Must be a table, view or homogeneous
     *                   collection.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned. Or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsResponse<TResponse> getRecords(String tableName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsRequest actualRequest_ = new GetRecordsRequest(tableName, offset, limit, null, options);
        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", actualRequest_, actualResponse_, false);
        GetRecordsResponse<TResponse> response_ = new GetRecordsResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeName(actualResponse_.getTypeName());
        response_.setTypeSchema(actualResponse_.getTypeSchema());
        response_.setData(this.<TResponse>decode(actualResponse_.getTypeName(), actualResponse_.getRecordsBinary()));
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * For a given table, retrieves the values of the given columns within a
     * given range. It returns maps of column name to the vector of values for
     * each supported data type (double, float, long, int and string). This
     * operation supports pagination feature, i.e. values that are retrieved
     * are those associated with the indices between the start (offset) and end
     * value (offset + limit) parameters (inclusive). If there are num_points
     * values in the table then each of the indices between 0 and num_points-1
     * retrieves a unique value.
     * <p>
     * Note that when using the pagination feature, if the table (or the
     * underlying table in case of a view) is updated (records are inserted,
     * deleted or modified) the records or values retrieved may differ between
     * calls (discontiguous or overlap) based on the type of the update.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawGetRecordsByColumnResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawGetRecordsByColumnResponse getRecordsByColumnRaw(GetRecordsByColumnRequest request) throws GPUdbException {
        RawGetRecordsByColumnResponse actualResponse_ = new RawGetRecordsByColumnResponse();
        submitRequest("/get/records/bycolumn", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * For a given table, retrieves the values of the given columns within a
     * given range. It returns maps of column name to the vector of values for
     * each supported data type (double, float, long, int and string). This
     * operation supports pagination feature, i.e. values that are retrieved
     * are those associated with the indices between the start (offset) and end
     * value (offset + limit) parameters (inclusive). If there are num_points
     * values in the table then each of the indices between 0 and num_points-1
     * retrieves a unique value.
     * <p>
     * Note that when using the pagination feature, if the table (or the
     * underlying table in case of a view) is updated (records are inserted,
     * deleted or modified) the records or values retrieved may differ between
     * calls (discontiguous or overlap) based on the type of the update.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsByColumnResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GetRecordsByColumnResponse getRecordsByColumn(GetRecordsByColumnRequest request) throws GPUdbException {
        RawGetRecordsByColumnResponse actualResponse_ = new RawGetRecordsByColumnResponse();
        submitRequest("/get/records/bycolumn", request, actualResponse_, false);
        GetRecordsByColumnResponse response_ = new GetRecordsByColumnResponse();
        response_.setTableName(actualResponse_.getTableName());
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * For a given table, retrieves the values of the given columns within a
     * given range. It returns maps of column name to the vector of values for
     * each supported data type (double, float, long, int and string). This
     * operation supports pagination feature, i.e. values that are retrieved
     * are those associated with the indices between the start (offset) and end
     * value (offset + limit) parameters (inclusive). If there are num_points
     * values in the table then each of the indices between 0 and num_points-1
     * retrieves a unique value.
     * <p>
     * Note that when using the pagination feature, if the table (or the
     * underlying table in case of a view) is updated (records are inserted,
     * deleted or modified) the records or values retrieved may differ between
     * calls (discontiguous or overlap) based on the type of the update.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../../concepts/index.html#dynamic-schemas"
     * target="_top">dynamic schemas documentation</a>.
     * 
     * @param tableName  Name of the table on which this operation will be
     *                   performed. The table cannot be a parent set.
     * @param columnNames  The list of column values to retrieve. Columns
     *                     annotated as store only cannot be retrieved.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned (if not provided the default is
     *               10000). Or END_OF_column (-9999) to indicate that the max
     *               number of results should be returned.
     * @param options
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsByColumnResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GetRecordsByColumnResponse getRecordsByColumn(String tableName, List<String> columnNames, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsByColumnRequest actualRequest_ = new GetRecordsByColumnRequest(tableName, columnNames, offset, limit, null, options);
        RawGetRecordsByColumnResponse actualResponse_ = new RawGetRecordsByColumnResponse();
        submitRequest("/get/records/bycolumn", actualRequest_, actualResponse_, false);
        GetRecordsByColumnResponse response_ = new GetRecordsByColumnResponse();
        response_.setTableName(actualResponse_.getTableName());
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track informaton contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecordsRaw(GetRecordsRequest)} this
     * returns records grouped by series/track. So if {@code offset} is 0 and
     * {@code limit} is 5 this operation would return the first 5 series/tracks
     * in {@code tableName}. Each series/track will be returned sorted by their
     * TIMESTAMP column.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawGetRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawGetRecordsBySeriesResponse getRecordsBySeriesRaw(GetRecordsBySeriesRequest request) throws GPUdbException {
        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track informaton contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecords(Object, GetRecordsRequest)} this
     * returns records grouped by series/track. So if {@code offset} is 0 and
     * {@code limit} is 5 this operation would return the first 5 series/tracks
     * in {@code tableName}. Each series/track will be returned sorted by their
     * TIMESTAMP column.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsBySeriesResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsBySeriesResponse<TResponse> getRecordsBySeries(Object typeDescriptor, GetRecordsBySeriesRequest request) throws GPUdbException {
        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", request, actualResponse_, false);
        GetRecordsBySeriesResponse<TResponse> response_ = new GetRecordsBySeriesResponse<>();
        response_.setTableNames(actualResponse_.getTableNames());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setTypeSchemas(actualResponse_.getTypeSchemas());
        response_.setData(this.<TResponse>decodeMultiple(typeDescriptor, actualResponse_.getListRecordsBinary()));
        return response_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track informaton contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecords(Object, String, long, long, Map)}
     * this returns records grouped by series/track. So if {@code offset} is 0
     * and {@code limit} is 5 this operation would return the first 5
     * series/tracks in {@code tableName}. Each series/track will be returned
     * sorted by their TIMESTAMP column.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param tableName  Name of the collection/table/view for which
     *                   series/tracks will be fetched.
     * @param worldTableName  Name of the table containing the complete
     *                        series/track information to be returned for the
     *                        tracks present in the {@code tableName}.
     *                        Typically this is used when retrieving
     *                        series/tracks from a view (which contains partial
     *                        series/tracks) but the user wants to retrieve the
     *                        entire original series/tracks. Can be blank.
     * @param offset  A positive integer indicating the number of initial
     *                series/tracks to skip (useful for paging through the
     *                results).  The minimum allowed value is 0. The maximum
     *                allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               series/tracks to be returned. Or END_OF_SET (-9999) to
     *               indicate that the max number of results should be
     *               returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsBySeriesResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsBySeriesResponse<TResponse> getRecordsBySeries(Object typeDescriptor, String tableName, String worldTableName, int offset, int limit, Map<String, String> options) throws GPUdbException {
        GetRecordsBySeriesRequest actualRequest_ = new GetRecordsBySeriesRequest(tableName, worldTableName, offset, limit, null, options);
        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
        GetRecordsBySeriesResponse<TResponse> response_ = new GetRecordsBySeriesResponse<>();
        response_.setTableNames(actualResponse_.getTableNames());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setTypeSchemas(actualResponse_.getTypeSchemas());
        response_.setData(this.<TResponse>decodeMultiple(typeDescriptor, actualResponse_.getListRecordsBinary()));
        return response_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track informaton contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecords(GetRecordsRequest)} this returns
     * records grouped by series/track. So if {@code offset} is 0 and {@code
     * limit} is 5 this operation would return the first 5 series/tracks in
     * {@code tableName}. Each series/track will be returned sorted by their
     * TIMESTAMP column.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsBySeriesResponse<TResponse> getRecordsBySeries(GetRecordsBySeriesRequest request) throws GPUdbException {
        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", request, actualResponse_, false);
        GetRecordsBySeriesResponse<TResponse> response_ = new GetRecordsBySeriesResponse<>();
        response_.setTableNames(actualResponse_.getTableNames());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setTypeSchemas(actualResponse_.getTypeSchemas());
        response_.setData(this.<TResponse>decodeMultiple(actualResponse_.getTypeNames(), actualResponse_.getListRecordsBinary()));
        return response_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track informaton contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecords(String, long, long, Map)} this
     * returns records grouped by series/track. So if {@code offset} is 0 and
     * {@code limit} is 5 this operation would return the first 5 series/tracks
     * in {@code tableName}. Each series/track will be returned sorted by their
     * TIMESTAMP column.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param tableName  Name of the collection/table/view for which
     *                   series/tracks will be fetched.
     * @param worldTableName  Name of the table containing the complete
     *                        series/track information to be returned for the
     *                        tracks present in the {@code tableName}.
     *                        Typically this is used when retrieving
     *                        series/tracks from a view (which contains partial
     *                        series/tracks) but the user wants to retrieve the
     *                        entire original series/tracks. Can be blank.
     * @param offset  A positive integer indicating the number of initial
     *                series/tracks to skip (useful for paging through the
     *                results).  The minimum allowed value is 0. The maximum
     *                allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               series/tracks to be returned. Or END_OF_SET (-9999) to
     *               indicate that the max number of results should be
     *               returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsBySeriesResponse<TResponse> getRecordsBySeries(String tableName, String worldTableName, int offset, int limit, Map<String, String> options) throws GPUdbException {
        GetRecordsBySeriesRequest actualRequest_ = new GetRecordsBySeriesRequest(tableName, worldTableName, offset, limit, null, options);
        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
        GetRecordsBySeriesResponse<TResponse> response_ = new GetRecordsBySeriesResponse<>();
        response_.setTableNames(actualResponse_.getTableNames());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setTypeSchemas(actualResponse_.getTypeSchemas());
        response_.setData(this.<TResponse>decodeMultiple(actualResponse_.getTypeNames(), actualResponse_.getListRecordsBinary()));
        return response_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(DeleteRecordsRequest)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawGetRecordsFromCollectionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawGetRecordsFromCollectionResponse getRecordsFromCollectionRaw(GetRecordsFromCollectionRequest request) throws GPUdbException {
        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(DeleteRecordsRequest)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsFromCollectionResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection(Object typeDescriptor, GetRecordsFromCollectionRequest request) throws GPUdbException {
        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", request, actualResponse_, false);
        GetRecordsFromCollectionResponse<TResponse> response_ = new GetRecordsFromCollectionResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setData(this.<TResponse>decode(typeDescriptor, actualResponse_.getRecordsBinary()));
        response_.setRecordIds(actualResponse_.getRecordIds());
        return response_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(String, List, Map)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param tableName  Name of the collection or table from which records are
     *                   to be retrieved. Must be an existing GPUdb collection
     *                   or table.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned, or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsFromCollectionResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection(Object typeDescriptor, String tableName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsFromCollectionRequest actualRequest_ = new GetRecordsFromCollectionRequest(tableName, offset, limit, null, options);
        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
        GetRecordsFromCollectionResponse<TResponse> response_ = new GetRecordsFromCollectionResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setData(this.<TResponse>decode(typeDescriptor, actualResponse_.getRecordsBinary()));
        response_.setRecordIds(actualResponse_.getRecordIds());
        return response_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(DeleteRecordsRequest)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsFromCollectionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection(GetRecordsFromCollectionRequest request) throws GPUdbException {
        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", request, actualResponse_, false);
        GetRecordsFromCollectionResponse<TResponse> response_ = new GetRecordsFromCollectionResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setData(this.<TResponse>decode(actualResponse_.getTypeNames(), actualResponse_.getRecordsBinary()));
        response_.setRecordIds(actualResponse_.getRecordIds());
        return response_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(String, List, Map)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param tableName  Name of the collection or table from which records are
     *                   to be retrieved. Must be an existing GPUdb collection
     *                   or table.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned, or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsFromCollectionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection(String tableName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsFromCollectionRequest actualRequest_ = new GetRecordsFromCollectionRequest(tableName, offset, limit, null, options);
        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
        GetRecordsFromCollectionResponse<TResponse> response_ = new GetRecordsFromCollectionResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setData(this.<TResponse>decode(actualResponse_.getTypeNames(), actualResponse_.getRecordsBinary()));
        response_.setRecordIds(actualResponse_.getRecordIds());
        return response_;
    }



    /**
     * Checks the existence of a table with the given name in GPUdb.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasTableResponse hasTable(HasTableRequest request) throws GPUdbException {
        HasTableResponse actualResponse_ = new HasTableResponse();
        submitRequest("/has/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Checks the existence of a table with the given name in GPUdb.
     * 
     * @param tableName  Name of the table to check for existence.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasTableResponse hasTable(String tableName, Map<String, String> options) throws GPUdbException {
        HasTableRequest actualRequest_ = new HasTableRequest(tableName, options);
        HasTableResponse actualResponse_ = new HasTableResponse();
        submitRequest("/has/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Check the existence of a type in GPUdb.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasTypeResponse hasType(HasTypeRequest request) throws GPUdbException {
        HasTypeResponse actualResponse_ = new HasTypeResponse();
        submitRequest("/has/type", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Check the existence of a type in GPUdb.
     * 
     * @param typeId  Id of the type returned by GPUdb in response to {@link
     *                GPUdb#createType(String, String, Map, Map)} request.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasTypeResponse hasType(String typeId, Map<String, String> options) throws GPUdbException {
        HasTypeRequest actualRequest_ = new HasTypeRequest(typeId, options);
        HasTypeResponse actualResponse_ = new HasTypeResponse();
        submitRequest("/has/type", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous meaning that GPUdb will not return a response until all the
     * records are fully inserted and available. The response payload provides
     * unique identifier for each added record along with counts of the number
     * of records actually inserted and/or updated.
     * <p>
     * {@code options} can be used to customize this function's behavior. The
     * only parameter available is {@code update_on_existing_pk}. The value can
     * be either 'true' or 'false'. If the table has a {@link
     * GPUdb#createType(CreateTypeRequest) primary key} and if {@code
     * update_on_existing_pk} is 'true' then if any of the records being added
     * have the same primary key as existing records, the existing records are
     * replaced (i.e. *updated*) with the given records. If {@code
     * update_on_existing_pk} is false and if the records being added have the
     * same primary key as existing records, the given records with existing
     * primary keys are ignored (the existing records are left unchanged). It
     * is quite possible that in this case some of the given records will be
     * inserted and some (those having existing primary keys) will be ignored
     * (or updated). If the specified table does not have a primary key column
     * then the {@code update_on_existing_pk} option is ignored.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertRecordsResponse insertRecordsRaw(RawInsertRecordsRequest request) throws GPUdbException {
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", request, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous meaning that GPUdb will not return a response until all the
     * records are fully inserted and available. The response payload provides
     * unique identifier for each added record along with counts of the number
     * of records actually inserted and/or updated.
     * <p>
     * {@code options} can be used to customize this function's behavior. The
     * only parameter available is {@code update_on_existing_pk}. The value can
     * be either 'true' or 'false'. If the table has a {@link
     * GPUdb#createType(CreateTypeRequest) primary key} and if {@code
     * update_on_existing_pk} is 'true' then if any of the records being added
     * have the same primary key as existing records, the existing records are
     * replaced (i.e. *updated*) with the given records. If {@code
     * update_on_existing_pk} is false and if the records being added have the
     * same primary key as existing records, the given records with existing
     * primary keys are ignored (the existing records are left unchanged). It
     * is quite possible that in this case some of the given records will be
     * inserted and some (those having existing primary keys) will be ignored
     * (or updated). If the specified table does not have a primary key column
     * then the {@code update_on_existing_pk} option is ignored.
     * 
     * @param <TRequest>  The type of object being added.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> InsertRecordsResponse insertRecords(InsertRecordsRequest<TRequest> request) throws GPUdbException {
        RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest(request.getTableName(), this.encode( request.getData() ), null, null, request.getOptions());
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous meaning that GPUdb will not return a response until all the
     * records are fully inserted and available. The response payload provides
     * unique identifier for each added record along with counts of the number
     * of records actually inserted and/or updated.
     * <p>
     * {@code options} can be used to customize this function's behavior. The
     * only parameter available is {@code update_on_existing_pk}. The value can
     * be either 'true' or 'false'. If the table has a {@link
     * GPUdb#createType(CreateTypeRequest) primary key} and if {@code
     * update_on_existing_pk} is 'true' then if any of the records being added
     * have the same primary key as existing records, the existing records are
     * replaced (i.e. *updated*) with the given records. If {@code
     * update_on_existing_pk} is false and if the records being added have the
     * same primary key as existing records, the given records with existing
     * primary keys are ignored (the existing records are left unchanged). It
     * is quite possible that in this case some of the given records will be
     * inserted and some (those having existing primary keys) will be ignored
     * (or updated). If the specified table does not have a primary key column
     * then the {@code update_on_existing_pk} option is ignored.
     * 
     * @param <TRequest>  The type of object being added.
     * @param typeObjectMap  Type object map used for encoding input objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeObjectMap} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> InsertRecordsResponse insertRecords(TypeObjectMap<TRequest> typeObjectMap, InsertRecordsRequest<TRequest> request) throws GPUdbException {
        RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest(request.getTableName(), this.encode( typeObjectMap, request.getData() ), null, null, request.getOptions());
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous meaning that GPUdb will not return a response until all the
     * records are fully inserted and available. The response payload provides
     * unique identifier for each added record along with counts of the number
     * of records actually inserted and/or updated.
     * <p>
     * {@code options} can be used to customize this function's behavior. The
     * only parameter available is {@code update_on_existing_pk}. The value can
     * be either 'true' or 'false'. If the table has a {@link
     * GPUdb#createType(String, String, Map, Map) primary key} and if {@code
     * update_on_existing_pk} is 'true' then if any of the records being added
     * have the same primary key as existing records, the existing records are
     * replaced (i.e. *updated*) with the given records. If {@code
     * update_on_existing_pk} is false and if the records being added have the
     * same primary key as existing records, the given records with existing
     * primary keys are ignored (the existing records are left unchanged). It
     * is quite possible that in this case some of the given records will be
     * inserted and some (those having existing primary keys) will be ignored
     * (or updated). If the specified table does not have a primary key column
     * then the {@code update_on_existing_pk} option is ignored.
     * 
     * @param <TRequest>  The type of object being added.
     * @param tableName  Table to which the records are to be added. Must be an
     *                   existing table.
     * @param data  An array of binary-encoded data for the records to be
     *              added. All records must be of the same type as that of the
     *              table. Empty array if {@code listEncoding} is {@code json}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> InsertRecordsResponse insertRecords(String tableName, List<TRequest> data, Map<String, String> options) throws GPUdbException {
        RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest(tableName, this.encode( data ), null, null, options);
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous meaning that GPUdb will not return a response until all the
     * records are fully inserted and available. The response payload provides
     * unique identifier for each added record along with counts of the number
     * of records actually inserted and/or updated.
     * <p>
     * {@code options} can be used to customize this function's behavior. The
     * only parameter available is {@code update_on_existing_pk}. The value can
     * be either 'true' or 'false'. If the table has a {@link
     * GPUdb#createType(String, String, Map, Map) primary key} and if {@code
     * update_on_existing_pk} is 'true' then if any of the records being added
     * have the same primary key as existing records, the existing records are
     * replaced (i.e. *updated*) with the given records. If {@code
     * update_on_existing_pk} is false and if the records being added have the
     * same primary key as existing records, the given records with existing
     * primary keys are ignored (the existing records are left unchanged). It
     * is quite possible that in this case some of the given records will be
     * inserted and some (those having existing primary keys) will be ignored
     * (or updated). If the specified table does not have a primary key column
     * then the {@code update_on_existing_pk} option is ignored.
     * 
     * @param <TRequest>  The type of object being added.
     * @param typeObjectMap  Type object map used for encoding input objects.
     * @param tableName  Table to which the records are to be added. Must be an
     *                   existing table.
     * @param data  An array of binary-encoded data for the records to be
     *              added. All records must be of the same type as that of the
     *              table. Empty array if {@code listEncoding} is {@code json}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeObjectMap} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> InsertRecordsResponse insertRecords(TypeObjectMap<TRequest> typeObjectMap, String tableName, List<TRequest> data, Map<String, String> options) throws GPUdbException {
        RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest(tableName, this.encode( typeObjectMap, data ), null, null, options);
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Generates a specified number of random records and adds them to the
     * given table. There is an optional parameter that allows the user to
     * customize the ranges of the column values. It also allows the user to
     * specify linear profiles for some or all columns in which case linear
     * values are generated rather than random ones. Only individual tables are
     * supported for this operation.
     * <p>
     * This operation is synchronous, meaning that GPUdb will not return until
     * all random records are fully available.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsRandomResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertRecordsRandomResponse insertRecordsRandom(InsertRecordsRandomRequest request) throws GPUdbException {
        InsertRecordsRandomResponse actualResponse_ = new InsertRecordsRandomResponse();
        submitRequest("/insert/records/random", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates a specified number of random records and adds them to the
     * given table. There is an optional parameter that allows the user to
     * customize the ranges of the column values. It also allows the user to
     * specify linear profiles for some or all columns in which case linear
     * values are generated rather than random ones. Only individual tables are
     * supported for this operation.
     * <p>
     * This operation is synchronous, meaning that GPUdb will not return until
     * all random records are fully available.
     * 
     * @param tableName  Table to which random records will be added. Must be
     *                   an existing table.  Also, must be an individual table,
     *                   not a collection of tables, nor a view of a table.
     * @param count  Number of records to generate.
     * @param options  Optional parameter to pass in specifications for the
     *                 randomness of the values.  This map is different from
     *                 the *options* parameter of most other endpoints in that
     *                 it is a map of string to map of string to doubles, while
     *                 most others are maps of string to string.  In this map,
     *                 the top level keys represent which column's parameters
     *                 are being specified, while the internal keys represents
     *                 which parameter is being specified.  The parameters that
     *                 can be specified are: *min*, *max*, and *interval*.
     *                 These parameters take on different meanings depending on
     *                 the type of the column.  Below follows a more detailed
     *                 description of the map:
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsRandomResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertRecordsRandomResponse insertRecordsRandom(String tableName, long count, Map<String, Map<String, Double>> options) throws GPUdbException {
        InsertRecordsRandomRequest actualRequest_ = new InsertRecordsRandomRequest(tableName, count, options);
        InsertRecordsRandomResponse actualResponse_ = new InsertRecordsRandomResponse();
        submitRequest("/insert/records/random", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Adds a symbol or icon (i.e. an image) to represent data points when data
     * is rendered visually. Users must provide the symbol identifier (string),
     * a format (currently supported: 'svg' and 'svg_path'), the data for the
     * symbol, and any additional optional parameter (e.g. color). To have a
     * symbol used for rendering create a table with a string column named
     * 'SYMBOLCODE' (along with 'x' or 'y' for example). Then when the table is
     * rendered (via <a href="../../../../rest/wms_rest.html"
     * target="_top">WMS</a> or {@link
     * GPUdb#visualizeImage(VisualizeImageRequest)}) if the 'dosymbology'
     * parameter is 'true' then GPUdb uses the value of the 'SYMBOLCODE' column
     * to pick the symbol displayed for each point.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertSymbolResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertSymbolResponse insertSymbol(InsertSymbolRequest request) throws GPUdbException {
        InsertSymbolResponse actualResponse_ = new InsertSymbolResponse();
        submitRequest("/insert/symbol", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Adds a symbol or icon (i.e. an image) to represent data points when data
     * is rendered visually. Users must provide the symbol identifier (string),
     * a format (currently supported: 'svg' and 'svg_path'), the data for the
     * symbol, and any additional optional parameter (e.g. color). To have a
     * symbol used for rendering create a table with a string column named
     * 'SYMBOLCODE' (along with 'x' or 'y' for example). Then when the table is
     * rendered (via <a href="../../../../rest/wms_rest.html"
     * target="_top">WMS</a> or {@link GPUdb#visualizeImage(List, List, String,
     * String, List, double, double, double, double, int, int, String, long,
     * Map, Map)}) if the 'dosymbology' parameter is 'true' then GPUdb uses the
     * value of the 'SYMBOLCODE' column to pick the symbol displayed for each
     * point.
     * 
     * @param symbolId  The id of the symbol being added. This is the same id
     *                  that should be in the 'SYMBOLCODE' column for objects
     *                  using this symbol
     * @param symbolFormat  Specifies the symbol format. Must be either 'svg'
     *                      or 'svg_path'.
     * @param symbolData  The actual symbol data. If {@code symbolFormat} is
     *                    'svg' then this should be the raw bytes representing
     *                    an svg file. If {@code symbolFormat} is svg path then
     *                    this should be an svg path string, for example:
     *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertSymbolResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertSymbolResponse insertSymbol(String symbolId, String symbolFormat, ByteBuffer symbolData, Map<String, String> options) throws GPUdbException {
        InsertSymbolRequest actualRequest_ = new InsertSymbolRequest(symbolId, symbolFormat, symbolData, options);
        InsertSymbolResponse actualResponse_ = new InsertSymbolResponse();
        submitRequest("/insert/symbol", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Locks a table.  By default a table has no locks and all operations are
     * permitted.  A user may request a read-only or a write-only lock, after
     * which only read or write operations are permitted on the table until the
     * next request.  When lock_type is disable then then no operations are
     * permitted on the table.  The lock status can be queried by passing an
     * empty string for {@code lockType}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  LockTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public LockTableResponse lockTable(LockTableRequest request) throws GPUdbException {
        LockTableResponse actualResponse_ = new LockTableResponse();
        submitRequest("/lock/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Locks a table.  By default a table has no locks and all operations are
     * permitted.  A user may request a read-only or a write-only lock, after
     * which only read or write operations are permitted on the table until the
     * next request.  When lock_type is disable then then no operations are
     * permitted on the table.  The lock status can be queried by passing an
     * empty string for {@code lockType}.
     * 
     * @param tableName  Name of the table to be locked. It must be a currently
     *                   existing table and not a collection or a view.
     * @param lockType  The type of lock being applied to the table or blank to
     *                  query. Empty string returns the lock status without
     *                  change the lock status of the table.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  LockTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public LockTableResponse lockTable(String tableName, String lockType, Map<String, String> options) throws GPUdbException {
        LockTableRequest actualRequest_ = new LockTableRequest(tableName, lockType, options);
        LockTableResponse actualResponse_ = new LockTableResponse();
        submitRequest("/lock/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns server configuration and version related information to the
     * caller. The GPUdb Admin tool uses it to present server related
     * information to the user.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemPropertiesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemPropertiesResponse showSystemProperties(ShowSystemPropertiesRequest request) throws GPUdbException {
        ShowSystemPropertiesResponse actualResponse_ = new ShowSystemPropertiesResponse();
        submitRequest("/show/system/properties", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns server configuration and version related information to the
     * caller. The GPUdb Admin tool uses it to present server related
     * information to the user.
     * 
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemPropertiesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemPropertiesResponse showSystemProperties(Map<String, String> options) throws GPUdbException {
        ShowSystemPropertiesRequest actualRequest_ = new ShowSystemPropertiesRequest(options);
        ShowSystemPropertiesResponse actualResponse_ = new ShowSystemPropertiesResponse();
        submitRequest("/show/system/properties", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Provides server configuration and health related status to the caller.
     * The GPUdb Admin tool uses it to present server related information to
     * the user.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemStatusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemStatusResponse showSystemStatus(ShowSystemStatusRequest request) throws GPUdbException {
        ShowSystemStatusResponse actualResponse_ = new ShowSystemStatusResponse();
        submitRequest("/show/system/status", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Provides server configuration and health related status to the caller.
     * The GPUdb Admin tool uses it to present server related information to
     * the user.
     * 
     * @param options  Optional parameters, currently unused.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemStatusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemStatusResponse showSystemStatus(Map<String, String> options) throws GPUdbException {
        ShowSystemStatusRequest actualRequest_ = new ShowSystemStatusRequest(options);
        ShowSystemStatusResponse actualResponse_ = new ShowSystemStatusResponse();
        submitRequest("/show/system/status", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns the last 100 requests made to GPUdb along with the request
     * timing and internal job id. The GPUdb Admin tool uses it to present
     * request timing information to the user.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemTimingResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemTimingResponse showSystemTiming(ShowSystemTimingRequest request) throws GPUdbException {
        ShowSystemTimingResponse actualResponse_ = new ShowSystemTimingResponse();
        submitRequest("/show/system/timing", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns the last 100 requests made to GPUdb along with the request
     * timing and internal job id. The GPUdb Admin tool uses it to present
     * request timing information to the user.
     * 
     * @param options  Optional parameters, currently unused.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemTimingResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemTimingResponse showSystemTiming(Map<String, String> options) throws GPUdbException {
        ShowSystemTimingRequest actualRequest_ = new ShowSystemTimingRequest(options);
        ShowSystemTimingResponse actualResponse_ = new ShowSystemTimingResponse();
        submitRequest("/show/system/timing", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves detailed information about a particular GPUdb table, specified
     * in {@code tableName}. If the supplied {@code tableName} is a collection,
     * the call returns a list of tables contained in the collection, and for
     * each table it returns the description, type id, schema, type label, type
     * propertiess, and additional information including TTL. If {@code
     * tableName} is empty it will return all top-level tables including all
     * collections and top-level child tables (i.e. tables with no parent).
     * <p>
     *     If the option 'get_sizes' is set to 'true' then the sizes (objects
     * and elements) of each table are returned (in {@code sizes} and {@code
     * fullSizes}), along with the total number of objects in the requested
     * table (in {@code totalSize} and {@code totalFullSize}).
     * <p>
     *     If the option 'show_children' is set to 'false' then for a
     * collection it only returns information about the collection itself, not
     * about the child tables. If 'show_children' is set to 'true' then it will
     * return information about each of the children.
     * <p>
     *     Running with 'show_children' = 'true' on a child table will return
     * an error.
     * <p>
     *     Running with 'show_children' = 'false' with {@code tableName} empty
     * will return an error.
     * <p>
     * If the requested table is blank, then information is returned about all
     * top-level tables including collections.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTableResponse showTable(ShowTableRequest request) throws GPUdbException {
        ShowTableResponse actualResponse_ = new ShowTableResponse();
        submitRequest("/show/table", request, actualResponse_, false);

        for (int i_ = 0; i_ < actualResponse_.getTypeIds().size(); i_++) {
            setTypeDescriptorIfMissing(actualResponse_.getTypeIds().get(i_), actualResponse_.getTypeLabels().get(i_), actualResponse_.getTypeSchemas().get(i_), actualResponse_.getProperties().get(i_));
        }

        return actualResponse_;
    }



    /**
     * Retrieves detailed information about a particular GPUdb table, specified
     * in {@code tableName}. If the supplied {@code tableName} is a collection,
     * the call returns a list of tables contained in the collection, and for
     * each table it returns the description, type id, schema, type label, type
     * propertiess, and additional information including TTL. If {@code
     * tableName} is empty it will return all top-level tables including all
     * collections and top-level child tables (i.e. tables with no parent).
     * <p>
     *     If the option 'get_sizes' is set to 'true' then the sizes (objects
     * and elements) of each table are returned (in {@code sizes} and {@code
     * fullSizes}), along with the total number of objects in the requested
     * table (in {@code totalSize} and {@code totalFullSize}).
     * <p>
     *     If the option 'show_children' is set to 'false' then for a
     * collection it only returns information about the collection itself, not
     * about the child tables. If 'show_children' is set to 'true' then it will
     * return information about each of the children.
     * <p>
     *     Running with 'show_children' = 'true' on a child table will return
     * an error.
     * <p>
     *     Running with 'show_children' = 'false' with {@code tableName} empty
     * will return an error.
     * <p>
     * If the requested table is blank, then information is returned about all
     * top-level tables including collections.
     * 
     * @param tableName  Name of the table for which to retrieve the
     *                   information. If blank then information about all
     *                   collections and top-level tables is returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTableResponse showTable(String tableName, Map<String, String> options) throws GPUdbException {
        ShowTableRequest actualRequest_ = new ShowTableRequest(tableName, options);
        ShowTableResponse actualResponse_ = new ShowTableResponse();
        submitRequest("/show/table", actualRequest_, actualResponse_, false);

        for (int i_ = 0; i_ < actualResponse_.getTypeIds().size(); i_++) {
            setTypeDescriptorIfMissing(actualResponse_.getTypeIds().get(i_), actualResponse_.getTypeLabels().get(i_), actualResponse_.getTypeSchemas().get(i_), actualResponse_.getProperties().get(i_));
        }

        return actualResponse_;
    }



    /**
     * Retrieves the user provided metadata for the specified tables.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTableMetadataResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTableMetadataResponse showTableMetadata(ShowTableMetadataRequest request) throws GPUdbException {
        ShowTableMetadataResponse actualResponse_ = new ShowTableMetadataResponse();
        submitRequest("/show/table/metadata", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves the user provided metadata for the specified tables.
     * 
     * @param tableNames  Tables whose metadata will be fetched. All provided
     *                    tables must exist in GPUdb, or GPUdb returns an
     *                    error.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTableMetadataResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTableMetadataResponse showTableMetadata(List<String> tableNames, Map<String, String> options) throws GPUdbException {
        ShowTableMetadataRequest actualRequest_ = new ShowTableMetadataRequest(tableNames, options);
        ShowTableMetadataResponse actualResponse_ = new ShowTableMetadataResponse();
        submitRequest("/show/table/metadata", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Gets names of the tables from GPUdb based on the type information. Each
     * table in GPUdb has a particular type. This type is made out of the type
     * label, schema of the table and the semantic type of the table. This
     * function allows a look up of the existing tables based on full or
     * partial type information. The operation is synchronous.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTablesByTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTablesByTypeResponse showTablesByType(ShowTablesByTypeRequest request) throws GPUdbException {
        ShowTablesByTypeResponse actualResponse_ = new ShowTablesByTypeResponse();
        submitRequest("/show/tables/bytype", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Gets names of the tables from GPUdb based on the type information. Each
     * table in GPUdb has a particular type. This type is made out of the type
     * label, schema of the table and the semantic type of the table. This
     * function allows a look up of the existing tables based on full or
     * partial type information. The operation is synchronous.
     * 
     * @param typeId  Type id returned by a call to {@link
     *                GPUdb#createType(String, String, Map, Map)}.
     * @param label  Optional user supplied label which can be used instead of
     *               the type_id to retrieve all tables with the given label.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTablesByTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTablesByTypeResponse showTablesByType(String typeId, String label, Map<String, String> options) throws GPUdbException {
        ShowTablesByTypeRequest actualRequest_ = new ShowTablesByTypeRequest(typeId, label, options);
        ShowTablesByTypeResponse actualResponse_ = new ShowTablesByTypeResponse();
        submitRequest("/show/tables/bytype", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves information regarding the specified triggers or all existing
     * triggers currently active within GPUdb.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTriggersResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTriggersResponse showTriggers(ShowTriggersRequest request) throws GPUdbException {
        ShowTriggersResponse actualResponse_ = new ShowTriggersResponse();
        submitRequest("/show/triggers", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves information regarding the specified triggers or all existing
     * triggers currently active within GPUdb.
     * 
     * @param triggerIds  List of IDs of the triggers whose information to be
     *                    retrieved. Empty list means retrieve information on
     *                    all active triggers.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTriggersResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTriggersResponse showTriggers(List<String> triggerIds, Map<String, String> options) throws GPUdbException {
        ShowTriggersRequest actualRequest_ = new ShowTriggersRequest(triggerIds, options);
        ShowTriggersResponse actualResponse_ = new ShowTriggersResponse();
        submitRequest("/show/triggers", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves information for the specified data type. Given a type ID,
     * GPUdb returns the data type schema, the label, and the semantic type
     * along with the type ID. If the user provides any combination of label
     * and semantic type, then GPUdb returns the pertinent information for all
     * data types that match the input criteria.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTypesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTypesResponse showTypes(ShowTypesRequest request) throws GPUdbException {
        ShowTypesResponse actualResponse_ = new ShowTypesResponse();
        submitRequest("/show/types", request, actualResponse_, false);

        for (int i_ = 0; i_ < actualResponse_.getTypeIds().size(); i_++) {
            setTypeDescriptorIfMissing(actualResponse_.getTypeIds().get(i_), actualResponse_.getLabels().get(i_), actualResponse_.getTypeSchemas().get(i_), actualResponse_.getProperties().get(i_));
        }

        return actualResponse_;
    }



    /**
     * Retrieves information for the specified data type. Given a type ID,
     * GPUdb returns the data type schema, the label, and the semantic type
     * along with the type ID. If the user provides any combination of label
     * and semantic type, then GPUdb returns the pertinent information for all
     * data types that match the input criteria.
     * 
     * @param typeId  Type Id returned in response to a call to {@link
     *                GPUdb#createType(String, String, Map, Map)}.
     * @param label  Option string that was supplied by user in a call to
     *               {@link GPUdb#createType(String, String, Map, Map)}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTypesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTypesResponse showTypes(String typeId, String label, Map<String, String> options) throws GPUdbException {
        ShowTypesRequest actualRequest_ = new ShowTypesRequest(typeId, label, options);
        ShowTypesResponse actualResponse_ = new ShowTypesResponse();
        submitRequest("/show/types", actualRequest_, actualResponse_, false);

        for (int i_ = 0; i_ < actualResponse_.getTypeIds().size(); i_++) {
            setTypeDescriptorIfMissing(actualResponse_.getTypeIds().get(i_), actualResponse_.getLabels().get(i_), actualResponse_.getTypeSchemas().get(i_), actualResponse_.getProperties().get(i_));
        }

        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public UpdateRecordsResponse updateRecordsRaw(RawUpdateRecordsRequest request) throws GPUdbException {
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", request, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param <TRequest>  The type of object being added.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> UpdateRecordsResponse updateRecords(UpdateRecordsRequest<TRequest> request) throws GPUdbException {
        RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest(request.getTableName(), request.getExpressions(), request.getNewValuesMaps(), this.encode( request.getData() ), null, null, request.getOptions());
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param <TRequest>  The type of object being added.
     * @param typeObjectMap  Type object map used for encoding input objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeObjectMap} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> UpdateRecordsResponse updateRecords(TypeObjectMap<TRequest> typeObjectMap, UpdateRecordsRequest<TRequest> request) throws GPUdbException {
        RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest(request.getTableName(), request.getExpressions(), request.getNewValuesMaps(), this.encode( typeObjectMap, request.getData() ), null, null, request.getOptions());
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param <TRequest>  The type of object being added.
     * @param tableName  Table to be updated. Must be a currently existing
     *                   table and not a collection or view.
     * @param expressions  A list of the actual predicates, one for each
     *                     update; format should follow the guidelines {@link
     *                     GPUdb#filter(String, String, String, Map) here}.
     * @param newValuesMaps  List of new values for the matching records.  Each
     *                       element is a map with (key, value) pairs where the
     *                       keys are the names of the columns whose values are
     *                       to be updated; the values are the new values.  The
     *                       number of elements in the list should match the
     *                       length of {@code expressions}.
     * @param data  An *optional* list of new binary-avro encoded records to
     *              insert, one for each update.  If one of {@code expressions}
     *              does not yield a matching record to be updated, then the
     *              corresponding element from this list will be added to the
     *              table.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> UpdateRecordsResponse updateRecords(String tableName, List<String> expressions, List<Map<String, String>> newValuesMaps, List<TRequest> data, Map<String, String> options) throws GPUdbException {
        RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest(tableName, expressions, newValuesMaps, this.encode( data ), null, null, options);
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param <TRequest>  The type of object being added.
     * @param typeObjectMap  Type object map used for encoding input objects.
     * @param tableName  Table to be updated. Must be a currently existing
     *                   table and not a collection or view.
     * @param expressions  A list of the actual predicates, one for each
     *                     update; format should follow the guidelines {@link
     *                     GPUdb#filter(String, String, String, Map) here}.
     * @param newValuesMaps  List of new values for the matching records.  Each
     *                       element is a map with (key, value) pairs where the
     *                       keys are the names of the columns whose values are
     *                       to be updated; the values are the new values.  The
     *                       number of elements in the list should match the
     *                       length of {@code expressions}.
     * @param data  An *optional* list of new binary-avro encoded records to
     *              insert, one for each update.  If one of {@code expressions}
     *              does not yield a matching record to be updated, then the
     *              corresponding element from this list will be added to the
     *              table.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeObjectMap} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> UpdateRecordsResponse updateRecords(TypeObjectMap<TRequest> typeObjectMap, String tableName, List<String> expressions, List<Map<String, String>> newValuesMaps, List<TRequest> data, Map<String, String> options) throws GPUdbException {
        RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest(tableName, expressions, newValuesMaps, this.encode( typeObjectMap, data ), null, null, options);
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Updates the view specified by {@code tableName} to include full series
     * (track) information from the {@code worldTableName} for the series
     * (tracks) present in the {@code viewName}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public UpdateRecordsBySeriesResponse updateRecordsBySeries(UpdateRecordsBySeriesRequest request) throws GPUdbException {
        UpdateRecordsBySeriesResponse actualResponse_ = new UpdateRecordsBySeriesResponse();
        submitRequest("/update/records/byseries", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Updates the view specified by {@code tableName} to include full series
     * (track) information from the {@code worldTableName} for the series
     * (tracks) present in the {@code viewName}.
     * 
     * @param tableName  Name of the view on which the update operation will be
     *                   performed. Must be a valid view in GPUdb.
     * @param worldTableName  Name of the table containing the complete series
     *                        (track) information.
     * @param viewName  Optional name of the view containing the series
     *                  (tracks) which have to be updated.
     * @param reserved
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public UpdateRecordsBySeriesResponse updateRecordsBySeries(String tableName, String worldTableName, String viewName, List<String> reserved, Map<String, String> options) throws GPUdbException {
        UpdateRecordsBySeriesRequest actualRequest_ = new UpdateRecordsBySeriesRequest(tableName, worldTableName, viewName, reserved, options);
        UpdateRecordsBySeriesResponse actualResponse_ = new UpdateRecordsBySeriesResponse();
        submitRequest("/update/records/byseries", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates rasterized image tiles for an area of interest using the given
     * tables and the provided parameters.
     * <p>
     * All color values must be in the format RRGGBB or AARRGGBB (to specify
     * the alpha value).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeImageResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeImageResponse visualizeImage(VisualizeImageRequest request) throws GPUdbException {
        VisualizeImageResponse actualResponse_ = new VisualizeImageResponse();
        submitRequest("/visualize/image", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates rasterized image tiles for an area of interest using the given
     * tables and the provided parameters.
     * <p>
     * All color values must be in the format RRGGBB or AARRGGBB (to specify
     * the alpha value).
     * 
     * @param tableNames  Name of the table containing the data for the various
     *                    layers to be rendered.
     * @param worldTableNames  Optional name of the tables containing the data
     *                         for the entire track when the {@code tableNames}
     *                         contains only part of the track data, but the
     *                         entire track has to be rendered.
     * @param xColumnName  Name of the column containing the x coordinates.
     * @param yColumnName  Name of the column containing the y coordinates.
     * @param trackIds  Tracks from the {@code tableNames} to be rendered.
     * @param minX  Lower bound for the x values.
     * @param maxX  Upper bound for the x values.
     * @param minY  Lower bound for the y values.
     * @param maxY  Upper bound for the y values.
     * @param width  Width of the generated image.
     * @param height  Height of the generated image.
     * @param projection  Spatial Reference System (i.e. EPSG Code).
     * @param bgColor  Background color of the generated image
     * @param styleOptions  Styling options for the image.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeImageResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeImageResponse visualizeImage(List<String> tableNames, List<String> worldTableNames, String xColumnName, String yColumnName, List<List<String>> trackIds, double minX, double maxX, double minY, double maxY, int width, int height, String projection, long bgColor, Map<String, List<String>> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeImageRequest actualRequest_ = new VisualizeImageRequest(tableNames, worldTableNames, xColumnName, yColumnName, trackIds, minX, maxX, minY, maxY, width, height, projection, bgColor, styleOptions, options);
        VisualizeImageResponse actualResponse_ = new VisualizeImageResponse();
        submitRequest("/visualize/image", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates 'class break' rasterized image tiles for an area of interest
     * using the given tables and the provided parameters.
     * <p>
     * A class break rendering is where data from one or more GPUdb tables is
     * rasterized with styling applied on a per-class basis. GPUdb supports
     * class breaks based on one or more data columns. Distinct values (for
     * strings) or ranges (for numeric attributes) must be provided in the
     * cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
     * styling parameters must be specified for each class.
     * <p>
     * All color values must be in the format RRGGBB or AARRGGBB (to specify
     * the alpha value).
     * The image is contained in the {@code imageData} field.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeImageClassbreakResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeImageClassbreakResponse visualizeImageClassbreak(VisualizeImageClassbreakRequest request) throws GPUdbException {
        VisualizeImageClassbreakResponse actualResponse_ = new VisualizeImageClassbreakResponse();
        submitRequest("/visualize/image/classbreak", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates 'class break' rasterized image tiles for an area of interest
     * using the given tables and the provided parameters.
     * <p>
     * A class break rendering is where data from one or more GPUdb tables is
     * rasterized with styling applied on a per-class basis. GPUdb supports
     * class breaks based on one or more data columns. Distinct values (for
     * strings) or ranges (for numeric attributes) must be provided in the
     * cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
     * styling parameters must be specified for each class.
     * <p>
     * All color values must be in the format RRGGBB or AARRGGBB (to specify
     * the alpha value).
     * The image is contained in the {@code imageData} field.
     * 
     * @param tableNames  Name of the table containing the data for the various
     *                    layers to be rendered.
     * @param worldTableNames  Optional name of the tables containing the data
     *                         for the entire track when the {@code tableNames}
     *                         contains only part of the track data, but the
     *                         entire track has to be rendered.
     * @param xColumnName  Name of the column containing the x coordinates.
     * @param yColumnName  Name of the column containing the y coordinates.
     * @param trackIds  Tracks from the {@code tableNames} to be rendered.
     * @param cbColumnName1  Name of the column for the first class break.
     * @param cbVals1  Comma separated list of values or ranges (e.g.
     *                 '0:5,5:10,15:30').
     * @param cbColumnName2  Optional comma seperated list of valid column
     *                       names. An empty string implies not using more than
     *                       one column for the class break. For a non-empty
     *                       list, there needs to be as many entries in the
     *                       list as there are classes for the first column
     *                       ({@code cbColumnName1}). However, the column names
     *                       can be empty to indicate that for the
     *                       corresponding class of the first attribute, no
     *                       secondary class break will be applied. All the
     *                       column names in this list must be different from
     *                       the first column {@code cbColumnName1}. For
     *                       example, 'col2,col3,col2'.
     * @param cbVals2  Comma separated list of []-enclosed lists of values or
     *                 ranges; e.g. '[0:5,5:10],[of,on,so],[-50:-20]'. Each
     *                 square bracket enclosed list describes the secondary
     *                 classes for the respective attribute in {@code
     *                 cbColumnName2} and the respective class in {@code
     *                 cbColumnName1} / {@code cbVals1}.
     * @param minX  Lower bound for the x values.
     * @param maxX  Upper bound for the x values.
     * @param minY  Lower bound for the y values.
     * @param maxY  Upper bound for the y values.
     * @param width  Width of the generated image.
     * @param height  Height of the generated image.
     * @param projection  Spatial Reference System (i.e. EPSG Code).
     * @param bgColor  Background color of the generated image.
     * @param styleOptions  Styling options for the image.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeImageClassbreakResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeImageClassbreakResponse visualizeImageClassbreak(List<String> tableNames, List<String> worldTableNames, String xColumnName, String yColumnName, List<List<String>> trackIds, String cbColumnName1, List<String> cbVals1, List<String> cbColumnName2, List<List<String>> cbVals2, double minX, double maxX, double minY, double maxY, int width, int height, String projection, long bgColor, Map<String, List<String>> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeImageClassbreakRequest actualRequest_ = new VisualizeImageClassbreakRequest(tableNames, worldTableNames, xColumnName, yColumnName, trackIds, cbColumnName1, cbVals1, cbColumnName2, cbVals2, minX, maxX, minY, maxY, width, height, projection, bgColor, styleOptions, options);
        VisualizeImageClassbreakResponse actualResponse_ = new VisualizeImageClassbreakResponse();
        submitRequest("/visualize/image/classbreak", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates rasterized heatmap image tiles for an area of interest using
     * the given tables and the provided parameters.
     * <p>
     * All color values must be in the format RRGGBB or AARRGGBB (to specify
     * the alpha value).
     * The heatmap image is contained in the {@code imageData} field.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeImageHeatmapResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeImageHeatmapResponse visualizeImageHeatmap(VisualizeImageHeatmapRequest request) throws GPUdbException {
        VisualizeImageHeatmapResponse actualResponse_ = new VisualizeImageHeatmapResponse();
        submitRequest("/visualize/image/heatmap", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates rasterized heatmap image tiles for an area of interest using
     * the given tables and the provided parameters.
     * <p>
     * All color values must be in the format RRGGBB or AARRGGBB (to specify
     * the alpha value).
     * The heatmap image is contained in the {@code imageData} field.
     * 
     * @param tableNames  Name of the table containing the data for the various
     *                    layers to be rendered.
     * @param xColumnName  Name of the column containing the x coordinates.
     * @param yColumnName  Name of the column containing the y coordinates.
     * @param valueColumnName
     * @param minX  Lower bound for the x values.
     * @param maxX  Upper bound for the x values.
     * @param minY  Lower bound for the y values.
     * @param maxY  Upper bound for the y values.
     * @param width  Width of the generated image.
     * @param height  Height of the generated image.
     * @param projection  Spatial Reference System (i.e. EPSG Code).
     * @param styleOptions  Various style related options.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeImageHeatmapResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeImageHeatmapResponse visualizeImageHeatmap(List<String> tableNames, String xColumnName, String yColumnName, String valueColumnName, double minX, double maxX, double minY, double maxY, int width, int height, String projection, Map<String, String> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeImageHeatmapRequest actualRequest_ = new VisualizeImageHeatmapRequest(tableNames, xColumnName, yColumnName, valueColumnName, minX, maxX, minY, maxY, width, height, projection, styleOptions, options);
        VisualizeImageHeatmapResponse actualResponse_ = new VisualizeImageHeatmapResponse();
        submitRequest("/visualize/image/heatmap", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates a rasterized image tile containing text labels defined by data
     * contained in the given table, suitable for overlaying onto a feature
     * image tile covering the same area (for example one generated using
     * {@link GPUdb#visualizeImage(VisualizeImageRequest)}).
     * <p>
     * All color values must be integers encoded in the format RRGGBB or
     * AARRGGBB (to specify the alpha value) when represented in hexadecimal;
     * although note that literal color values must be specified in base 10,
     * not hexadecimal.
     * <p>
     * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
     * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
     * list of words defining style, variant, weight, stretch, or gravity, and
     * SIZE is a decimal number (size in points) or optionally followed by the
     * unit modifier 'px' for absolute size. All three sub-fields are optional;
     * default values will be used for omitted sub-fields. (For example,
     * 'Helvetica Bold Italic 10' specifies Helvetica, Bold and Italic, 10
     * points.) A substitute font will be used if a requested font is not
     * installed.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeImageLabelsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeImageLabelsResponse visualizeImageLabels(VisualizeImageLabelsRequest request) throws GPUdbException {
        VisualizeImageLabelsResponse actualResponse_ = new VisualizeImageLabelsResponse();
        submitRequest("/visualize/image/labels", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates a rasterized image tile containing text labels defined by data
     * contained in the given table, suitable for overlaying onto a feature
     * image tile covering the same area (for example one generated using
     * {@link GPUdb#visualizeImage(List, List, String, String, List, double,
     * double, double, double, int, int, String, long, Map, Map)}).
     * <p>
     * All color values must be integers encoded in the format RRGGBB or
     * AARRGGBB (to specify the alpha value) when represented in hexadecimal;
     * although note that literal color values must be specified in base 10,
     * not hexadecimal.
     * <p>
     * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
     * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
     * list of words defining style, variant, weight, stretch, or gravity, and
     * SIZE is a decimal number (size in points) or optionally followed by the
     * unit modifier 'px' for absolute size. All three sub-fields are optional;
     * default values will be used for omitted sub-fields. (For example,
     * 'Helvetica Bold Italic 10' specifies Helvetica, Bold and Italic, 10
     * points.) A substitute font will be used if a requested font is not
     * installed.
     * 
     * @param tableName  Name of the table containing the data defining the
     *                   labels to render.
     * @param xColumnName  Name of the column containing the x coordinates of
     *                     the center points of the labels.
     * @param yColumnName  Name of the column containing the y coordinates of
     *                     the center points of the labels.
     * @param xOffset  Either the name of an integer column, or a single
     *                 literal integer value, defining the number of output
     *                 pixels by which the labels will be offset horizontally
     *                 from their specified x coordinates. If blank, an offset
     *                 of 0 will be used.
     * @param yOffset  Either the name of an integer column, or a single
     *                 literal integer value, defining the number of output
     *                 pixels by which the labels will be offset vertically
     *                 from their specified y coordinates. If blank, an offset
     *                 of 0 will be used.
     * @param textString  Either the name of a string column, or a single
     *                    literal string value (enclosed in double quotes),
     *                    defining the text for the labels.
     * @param font  Either the name of a string column, or a single literal
     *              string value (enclosed in double quotes), defining the
     *              fonts for the labels.
     * @param textColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the text color for the
     *                   labels. If blank, opaque black will be used.
     * @param textAngle  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the angle of clockwise
     *                   rotation (in degrees) for the labels. If blank, an
     *                   angle of 0 will be used.
     * @param textScale  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the scaling factor for
     *                   the labels. (1 is normal size, 0.5 is half size, 2 is
     *                   double size, etc.) If blank, a scaling factor of 1
     *                   will be used.
     * @param drawBox  Either the name of an integer column, or a single
     *                 literal integer value, defining a Boolean flag
     *                 indicating whether boxes will be drawn around the
     *                 labels. If blank, no boxes will be drawn.
     * @param drawLeader  Either the name of an integer column, or a single
     *                    literal integer value, defining a Boolean flag
     *                    indicating whether leader lines will be drawn from
     *                    the labels to points specified using {@code
     *                    leaderXColumnName} and {@code leaderYColumnName}. If
     *                    blank, no leader lines will be drawn.
     * @param lineWidth  Either the name of a numeric column, or a single
     *                   literal numeric value, defining the line width in
     *                   output pixels for the labels' boxes and leader lines.
     *                   If blank, a line width of 1 will be used.
     * @param lineColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the line color for the
     *                   labels' boxes and leader lines. If blank, opaque black
     *                   will be used.
     * @param fillColor  Either the name of an integer column, or a single
     *                   literal integer value, defining the fill color for the
     *                   labels' boxes. If blank, the boxes will not be filled.
     * @param leaderXColumnName  Name of the column containing the x
     *                           coordinates of the points to which the labels'
     *                           leader lines will be drawn. May be left blank
     *                           if no leader lines are to be drawn.
     * @param leaderYColumnName  Name of the column containing the y
     *                           coordinates of the points to which the labels'
     *                           leader lines will be drawn. May be left blank
     *                           if no leader lines are to be drawn.
     * @param minX  Lower bound for the x coordinates of labels to include in
     *              the image.
     * @param maxX  Upper bound for the x coordinates of labels to include in
     *              the image.
     * @param minY  Lower bound for the y coordinates of labels to include in
     *              the image.
     * @param maxY  Upper bound for the y coordinates of labels to include in
     *              the image.
     * @param width  Width of the generated image.
     * @param height  Height of the generated image.
     * @param projection  Spatial Reference System (i.e. EPSG Code).
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeImageLabelsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeImageLabelsResponse visualizeImageLabels(String tableName, String xColumnName, String yColumnName, String xOffset, String yOffset, String textString, String font, String textColor, String textAngle, String textScale, String drawBox, String drawLeader, String lineWidth, String lineColor, String fillColor, String leaderXColumnName, String leaderYColumnName, double minX, double maxX, double minY, double maxY, int width, int height, String projection, Map<String, String> options) throws GPUdbException {
        VisualizeImageLabelsRequest actualRequest_ = new VisualizeImageLabelsRequest(tableName, xColumnName, yColumnName, xOffset, yOffset, textString, font, textColor, textAngle, textScale, drawBox, drawLeader, lineWidth, lineColor, fillColor, leaderXColumnName, leaderYColumnName, minX, maxX, minY, maxY, width, height, projection, options);
        VisualizeImageLabelsResponse actualResponse_ = new VisualizeImageLabelsResponse();
        submitRequest("/visualize/image/labels", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates raster images of data in the given table based on provided input
     * parameters. Numerous parameters are required to call this function. Some
     * of the important parameters are the attributes of the generated images
     * ({@code bgColor}, {@code width}, {@code height}), the collection of
     * GPUdb table names on which this function is to be applied, for which
     * shapes (point, polygon, tracks) the images are to be created and a user
     * specified session key. This session key is later used to fetch the
     * generated images stored by GPUdb. The operation is synchronous meaning
     * that GPUdb will not return the request until the images for all the
     * frames of the video are fully available.
     * <p>
     * Once the request has been processed then the generated video frames are
     * available for download via WMS using STYLES=cached. In this request the
     * LAYERS parameter should be populated with the session key passed in
     * {@code sessionKey} of the visualize video request and the FRAME
     * parameter indicates which 0-based frame of the video should be returned.
     * All other WMS parameters are ignored for this mode.
     * <p>
     * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY'
     * was generated, the first frame could be retrieved with the URL::
     * <p>
     *      http://<gpudb-ip-
     * address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-
     * KEY&FRAME=0
     * <p>
     * and the last frame could be retrieved with::
     * <p>
     *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
     * =MY-SESSION-KEY&FRAME=19
     * The response payload provides, among other things, the number of frames
     * which were created by GPUdb.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeVideoResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeVideoResponse visualizeVideo(VisualizeVideoRequest request) throws GPUdbException {
        VisualizeVideoResponse actualResponse_ = new VisualizeVideoResponse();
        submitRequest("/visualize/video", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates raster images of data in the given table based on provided input
     * parameters. Numerous parameters are required to call this function. Some
     * of the important parameters are the attributes of the generated images
     * ({@code bgColor}, {@code width}, {@code height}), the collection of
     * GPUdb table names on which this function is to be applied, for which
     * shapes (point, polygon, tracks) the images are to be created and a user
     * specified session key. This session key is later used to fetch the
     * generated images stored by GPUdb. The operation is synchronous meaning
     * that GPUdb will not return the request until the images for all the
     * frames of the video are fully available.
     * <p>
     * Once the request has been processed then the generated video frames are
     * available for download via WMS using STYLES=cached. In this request the
     * LAYERS parameter should be populated with the session key passed in
     * {@code sessionKey} of the visualize video request and the FRAME
     * parameter indicates which 0-based frame of the video should be returned.
     * All other WMS parameters are ignored for this mode.
     * <p>
     * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY'
     * was generated, the first frame could be retrieved with the URL::
     * <p>
     *      http://<gpudb-ip-
     * address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-
     * KEY&FRAME=0
     * <p>
     * and the last frame could be retrieved with::
     * <p>
     *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
     * =MY-SESSION-KEY&FRAME=19
     * The response payload provides, among other things, the number of frames
     * which were created by GPUdb.
     * 
     * @param tableNames  Names of the tables containing the data for various
     *                    layers of the resulting video.
     * @param worldTableNames  Optional name of the tables containing the data
     *                         for the entire track when the {@code tableNames}
     *                         contains only part of the track data, but the
     *                         entire track has to be rendered. The number of
     *                         tables should match the number of tables in the
     *                         {@code tableNames}
     * @param trackIds  Tracks from the {@code tableNames} to be rendered.
     * @param xColumnName  Name of the column containing the x coordinates.
     * @param yColumnName  Name of the column containing the y coordinates.
     * @param minX  Lower bound for the x values.
     * @param maxX  Upper bound for the x values.
     * @param minY  Lower bound for the y values.
     * @param maxY  Upper bound for the y values.
     * @param width  Width of the generated image.
     * @param height  Height of the generated image.
     * @param projection  Spatial Reference System (i.e. EPSG Code).
     * @param bgColor  Background color of the generated image.
     * @param timeIntervals
     * @param videoStyle
     * @param sessionKey  User Provided session key that is later used to
     *                    retrieve the generated video from the WMS.
     * @param styleOptions  Styling options for the image.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeVideoResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeVideoResponse visualizeVideo(List<String> tableNames, List<String> worldTableNames, List<List<String>> trackIds, String xColumnName, String yColumnName, double minX, double maxX, double minY, double maxY, int width, int height, String projection, long bgColor, List<List<Double>> timeIntervals, String videoStyle, String sessionKey, Map<String, List<String>> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeVideoRequest actualRequest_ = new VisualizeVideoRequest(tableNames, worldTableNames, trackIds, xColumnName, yColumnName, minX, maxX, minY, maxY, width, height, projection, bgColor, timeIntervals, videoStyle, sessionKey, styleOptions, options);
        VisualizeVideoResponse actualResponse_ = new VisualizeVideoResponse();
        submitRequest("/visualize/video", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates raster heat-map images of table data based on input parameters.
     * Numerous parameters are required to call this function. Some of the
     * important parameters are the attributes of the generated images ({@code
     * bg_color}, {@code width}, {@code height}), the collection of GPUdb table
     * names on which this function is to be applied and a user specified
     * session key. This session key is later used to fetch the generated
     * images stored by GPUdb. The operation is synchronous meaning that GPUdb
     * will not return the request until all the images are fully available.
     * <p>
     * Once the request has been processed then the generated video frames are
     * available for download via WMS using STYLES=cached. In this request the
     * LAYERS parameter should be populated with the session key passed in
     * {@code sessionKey} of the visualize video request and the FRAME
     * parameter indicates which 0-based frame of the video should be returned.
     * All other WMS parameters are ignored for this mode.
     * <p>
     * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY'
     * was generated, the first frame could be retrieved with the URL::
     * <p>
     *      http://<gpudb-ip-
     * address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-
     * KEY&FRAME=0
     * <p>
     * and the last frame could be retrieved with::
     * <p>
     *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
     * =MY-SESSION-KEY&FRAME=19
     * <p>

     * <p>

     * The response payload provides among other things the number of frames
     * which were created by GPUdb.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeVideoHeatmapResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeVideoHeatmapResponse visualizeVideoHeatmap(VisualizeVideoHeatmapRequest request) throws GPUdbException {
        VisualizeVideoHeatmapResponse actualResponse_ = new VisualizeVideoHeatmapResponse();
        submitRequest("/visualize/video/heatmap", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates raster heat-map images of table data based on input parameters.
     * Numerous parameters are required to call this function. Some of the
     * important parameters are the attributes of the generated images ({@code
     * bg_color}, {@code width}, {@code height}), the collection of GPUdb table
     * names on which this function is to be applied and a user specified
     * session key. This session key is later used to fetch the generated
     * images stored by GPUdb. The operation is synchronous meaning that GPUdb
     * will not return the request until all the images are fully available.
     * <p>
     * Once the request has been processed then the generated video frames are
     * available for download via WMS using STYLES=cached. In this request the
     * LAYERS parameter should be populated with the session key passed in
     * {@code sessionKey} of the visualize video request and the FRAME
     * parameter indicates which 0-based frame of the video should be returned.
     * All other WMS parameters are ignored for this mode.
     * <p>
     * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY'
     * was generated, the first frame could be retrieved with the URL::
     * <p>
     *      http://<gpudb-ip-
     * address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-
     * KEY&FRAME=0
     * <p>
     * and the last frame could be retrieved with::
     * <p>
     *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
     * =MY-SESSION-KEY&FRAME=19
     * <p>

     * <p>

     * The response payload provides among other things the number of frames
     * which were created by GPUdb.
     * 
     * @param tableNames  Names of the tables containing the data for various
     *                    layers of the resulting video
     * @param xColumnName  Name of the column containing the x coordinates.
     * @param yColumnName  Name of the column containing the y coordinates.
     * @param minX  Lower bound for the x values.
     * @param maxX  Upper bound for the x values.
     * @param minY  Lower bound for the y values.
     * @param maxY  Upper bound for the y values.
     * @param timeIntervals
     * @param width  Width of the generated video.
     * @param height  Height of the generated video.
     * @param projection  Spatial Reference System (i.e. EPSG Code).
     * @param videoStyle
     * @param sessionKey  User Provided session key that is later used to
     *                    retrieve the generated video from the WMS.
     * @param styleOptions  Various style related options.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeVideoHeatmapResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeVideoHeatmapResponse visualizeVideoHeatmap(List<String> tableNames, String xColumnName, String yColumnName, double minX, double maxX, double minY, double maxY, List<List<Double>> timeIntervals, int width, int height, String projection, String videoStyle, String sessionKey, Map<String, String> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeVideoHeatmapRequest actualRequest_ = new VisualizeVideoHeatmapRequest(tableNames, xColumnName, yColumnName, minX, maxX, minY, maxY, timeIntervals, width, height, projection, videoStyle, sessionKey, styleOptions, options);
        VisualizeVideoHeatmapResponse actualResponse_ = new VisualizeVideoHeatmapResponse();
        submitRequest("/visualize/video/heatmap", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }


}