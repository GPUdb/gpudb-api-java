/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
package com.gpudb;

import com.gpudb.protocol.*;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;

/**
 * Object that provides access to a specific GPUdb server. {@code GPUdb}
 * instances are thread safe and may be used from any number of threads
 * simultaneously.
 */
public class GPUdb extends GPUdbBase {

    /**
     * Creates a {@link GPUdb} instance for the GPUdb server at the
     * specified URL using default options.  Note that these options
     * cannot be changed subsequently; to use different options, a new
     * {@link GPUdb} instance must be created.
     * 
     * @param url  The URL of the GPUdb server.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(String url) throws GPUdbException {
        super(url, new Options());
    }

    /**
     * Creates a {@link GPUdb} instance for the GPUdb server at the
     * specified URL using default options.  Note that these options
     * cannot be changed subsequently; to use different options, a new
     * {@link GPUdb} instance must be created.
     * 
     * @param url  The URL of the GPUdb server.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(URL url) throws GPUdbException {
        super(url, new Options());
    }

    /**
     * Creates a {@link GPUdb} instance for the GPUdb server with the
     * specified URLs using default options.  At any given time, one
     * URL (initially selected at random from the list) will be active
     * and used for all GPUdb calls, but in the event of failure, the
     * other URLs will be tried in order, and if a working one is found
     * it will become the new active URL.  Note that the default options
     * cannot be changed subsequently; to use different options, a new
     * {@link GPUdb} instance must be created.
     *
     * @param urls  The URLs of the GPUdb server.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(List<URL> urls) throws GPUdbException {
        super(urls, new Options());
    }

    /**
     * Creates a {@link GPUdb} instance for the GPUdb server at the
     * specified URL using the specified options.  Note that these
     * options cannot be changed subsequently; to use different options,
     * a new {@link GPUdb} instance must be created.
     * 
     * @param url  The URL of the GPUdb server.
     * 
     * @param options  The options to use.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(String url, Options options) throws GPUdbException {
        super(url, options);
    }
    /**
     * Creates a {@link GPUdb} instance for the GPUdb server at the
     * specified URL using the specified options.  Note that these
     * options cannot be changed subsequently; to use different options,
     * a new {@link GPUdb} instance must be created.
     * 
     * @param url  The URL of the GPUdb server.
     * 
     * @param options  The options to use.
     * 
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(URL url, Options options) throws GPUdbException {
        super(url, options);
    }
    /**
     * Creates a {@link GPUdb} instance for the GPUdb server with the
     * specified URLs using the specified options.  At any given time,
     * one URL (initially selected at random from the list) will be active
     * and used for all GPUdb calls, but in the event of failure, the
     * other URLs will be tried in order, and if a working one is found
     * it will become the new active URL.  Note that the specified options
     * cannot be changed subsequently; to use different options, a new
     * {@link GPUdb} instance must be created.
     *
     * @param urls  The URLs of the GPUdb server.
     *
     * @param options  The options to use.
     *
     * @throws GPUdbException if an error occurs during creation.
     */
    public GPUdb(List<URL> urls, Options options) throws GPUdbException {
        super(urls, options);
    }


    public AdminDeleteNodeResponse adminDeleteNode(AdminDeleteNodeRequest request) throws GPUdbException {
        AdminDeleteNodeResponse actualResponse_ = new AdminDeleteNodeResponse();
        submitRequest("/admin/delete/node", request, actualResponse_, false);
        return actualResponse_;
    }



    public AdminDeleteNodeResponse adminDeleteNode(int rank, String authorization, Map<String, String> options) throws GPUdbException {
        AdminDeleteNodeRequest actualRequest_ = new AdminDeleteNodeRequest(rank, authorization, options);
        AdminDeleteNodeResponse actualResponse_ = new AdminDeleteNodeResponse();
        submitRequest("/admin/delete/node", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    public AdminGetShardAssignmentsResponse adminGetShardAssignments(AdminGetShardAssignmentsRequest request) throws GPUdbException {
        AdminGetShardAssignmentsResponse actualResponse_ = new AdminGetShardAssignmentsResponse();
        submitRequest("/admin/getshardassignments", request, actualResponse_, false);
        return actualResponse_;
    }



    public AdminGetShardAssignmentsResponse adminGetShardAssignments(Map<String, String> options) throws GPUdbException {
        AdminGetShardAssignmentsRequest actualRequest_ = new AdminGetShardAssignmentsRequest(options);
        AdminGetShardAssignmentsResponse actualResponse_ = new AdminGetShardAssignmentsResponse();
        submitRequest("/admin/getshardassignments", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Take the system offline. When the system is offline, no user operations
     * can be performed with the exception of a system shutdown.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminOfflineResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminOfflineResponse adminOffline(AdminOfflineRequest request) throws GPUdbException {
        AdminOfflineResponse actualResponse_ = new AdminOfflineResponse();
        submitRequest("/admin/offline", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Take the system offline. When the system is offline, no user operations
     * can be performed with the exception of a system shutdown.
     * 
     * @param offline  Set to true if desired state is offline. Values: true,
     *                 false.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminOfflineResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminOfflineResponse adminOffline(boolean offline, Map<String, String> options) throws GPUdbException {
        AdminOfflineRequest actualRequest_ = new AdminOfflineRequest(offline, options);
        AdminOfflineResponse actualResponse_ = new AdminOfflineResponse();
        submitRequest("/admin/offline", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    public AdminRebalanceResponse adminRebalance(AdminRebalanceRequest request) throws GPUdbException {
        AdminRebalanceResponse actualResponse_ = new AdminRebalanceResponse();
        submitRequest("/admin/rebalance", request, actualResponse_, false);
        return actualResponse_;
    }



    public AdminRebalanceResponse adminRebalance(List<String> tableNames, Map<String, String> options) throws GPUdbException {
        AdminRebalanceRequest actualRequest_ = new AdminRebalanceRequest(tableNames, options);
        AdminRebalanceResponse actualResponse_ = new AdminRebalanceResponse();
        submitRequest("/admin/rebalance", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    public AdminSetShardAssignmentsResponse adminSetShardAssignments(AdminSetShardAssignmentsRequest request) throws GPUdbException {
        AdminSetShardAssignmentsResponse actualResponse_ = new AdminSetShardAssignmentsResponse();
        submitRequest("/admin/setshardassignments", request, actualResponse_, false);
        return actualResponse_;
    }



    public AdminSetShardAssignmentsResponse adminSetShardAssignments(long version, boolean partialReassignment, List<Integer> shardAssignmentsRank, List<Integer> shardAssignmentsTom, List<Integer> assignmentIndex, Map<String, String> options) throws GPUdbException {
        AdminSetShardAssignmentsRequest actualRequest_ = new AdminSetShardAssignmentsRequest(version, partialReassignment, shardAssignmentsRank, shardAssignmentsTom, assignmentIndex, options);
        AdminSetShardAssignmentsResponse actualResponse_ = new AdminSetShardAssignmentsResponse();
        submitRequest("/admin/setshardassignments", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Exits the database server application.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminShutdownResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminShutdownResponse adminShutdown(AdminShutdownRequest request) throws GPUdbException {
        AdminShutdownResponse actualResponse_ = new AdminShutdownResponse();
        submitRequest("/admin/shutdown", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Exits the database server application.
     * 
     * @param exitType  Reserved for future use. User can pass an empty string.
     * @param authorization  No longer used. User can pass an empty string.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminShutdownResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminShutdownResponse adminShutdown(String exitType, String authorization, Map<String, String> options) throws GPUdbException {
        AdminShutdownRequest actualRequest_ = new AdminShutdownRequest(exitType, authorization, options);
        AdminShutdownResponse actualResponse_ = new AdminShutdownResponse();
        submitRequest("/admin/shutdown", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Verify database is in a consistent state.  When inconsistencies or
     * errors are found, the verified_ok flag in the response is set to false
     * and the list of errors found is provided in the error_list.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminVerifyDbResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminVerifyDbResponse adminVerifyDb(AdminVerifyDbRequest request) throws GPUdbException {
        AdminVerifyDbResponse actualResponse_ = new AdminVerifyDbResponse();
        submitRequest("/admin/verifydb", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Verify database is in a consistent state.  When inconsistencies or
     * errors are found, the verified_ok flag in the response is set to false
     * and the list of errors found is provided in the error_list.
     * 
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AdminVerifyDbResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AdminVerifyDbResponse adminVerifyDb(Map<String, String> options) throws GPUdbException {
        AdminVerifyDbRequest actualRequest_ = new AdminVerifyDbRequest(options);
        AdminVerifyDbResponse actualResponse_ = new AdminVerifyDbResponse();
        submitRequest("/admin/verifydb", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates and returns the convex hull for the values in a table
     * specified by {@code tableName}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateConvexHullResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateConvexHullResponse aggregateConvexHull(AggregateConvexHullRequest request) throws GPUdbException {
        AggregateConvexHullResponse actualResponse_ = new AggregateConvexHullResponse();
        submitRequest("/aggregate/convexhull", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates and returns the convex hull for the values in a table
     * specified by {@code tableName}.
     * 
     * @param tableName  Name of Table on which the operation will be
     *                   performed. Must be an existing table.  It can not be a
     *                   collection.
     * @param xColumnName  Name of the column containing the x coordinates of
     *                     the points for the operation being performed.
     * @param yColumnName  Name of the column containing the y coordinates of
     *                     the points for the operation being performed.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateConvexHullResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateConvexHullResponse aggregateConvexHull(String tableName, String xColumnName, String yColumnName, Map<String, String> options) throws GPUdbException {
        AggregateConvexHullRequest actualRequest_ = new AggregateConvexHullRequest(tableName, xColumnName, yColumnName, options);
        AggregateConvexHullResponse actualResponse_ = new AggregateConvexHullResponse();
        submitRequest("/aggregate/convexhull", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates unique combinations (groups) of values for the given columns
     * in a given table/view/collection and computes aggregates on each unique
     * combination. This is somewhat analogous to an SQL-style SELECT...GROUP
     * BY. Any column(s) can be grouped on, but only non-string (i.e. numeric)
     * columns may be used for computing aggregates. The results can be paged
     * via the {@code offset} and {@code limit} parameters. For example, to get
     * 10 groups with the largest counts the inputs would be: limit=10,
     * options={"sort_order":"descending", "sort_by":"value"}. {@code options}
     * can be used to customize behavior of this call e.g. filtering or sorting
     * the results. To group by 'x' and 'y' and compute the number of objects
     * within each group, use column_names=['x','y','count(*)'].  To also
     * compute the sum of 'z' over each group, use
     * column_names=['x','y','count(*)','sum(z)']. Available aggregation
     * functions are: 'count(*)', 'sum', 'min', 'max', 'avg', 'mean', 'stddev',
     * 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp', 'arg_min',
     * 'arg_max' and 'count_distinct'. The response is returned as a dynamic
     * schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>. If the 'result_table' option is provided then
     * the results are stored in a table with the name given in the option and
     * the results are not returned in the response.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawAggregateGroupByResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawAggregateGroupByResponse aggregateGroupByRaw(AggregateGroupByRequest request) throws GPUdbException {
        RawAggregateGroupByResponse actualResponse_ = new RawAggregateGroupByResponse();
        submitRequest("/aggregate/groupby", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates unique combinations (groups) of values for the given columns
     * in a given table/view/collection and computes aggregates on each unique
     * combination. This is somewhat analogous to an SQL-style SELECT...GROUP
     * BY. Any column(s) can be grouped on, but only non-string (i.e. numeric)
     * columns may be used for computing aggregates. The results can be paged
     * via the {@code offset} and {@code limit} parameters. For example, to get
     * 10 groups with the largest counts the inputs would be: limit=10,
     * options={"sort_order":"descending", "sort_by":"value"}. {@code options}
     * can be used to customize behavior of this call e.g. filtering or sorting
     * the results. To group by 'x' and 'y' and compute the number of objects
     * within each group, use column_names=['x','y','count(*)'].  To also
     * compute the sum of 'z' over each group, use
     * column_names=['x','y','count(*)','sum(z)']. Available aggregation
     * functions are: 'count(*)', 'sum', 'min', 'max', 'avg', 'mean', 'stddev',
     * 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp', 'arg_min',
     * 'arg_max' and 'count_distinct'. The response is returned as a dynamic
     * schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>. If the 'result_table' option is provided then
     * the results are stored in a table with the name given in the option and
     * the results are not returned in the response.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateGroupByResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateGroupByResponse aggregateGroupBy(AggregateGroupByRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawAggregateGroupByResponse actualResponse_ = new RawAggregateGroupByResponse();
        submitRequest("/aggregate/groupby", request, actualResponse_, false);
        AggregateGroupByResponse response_ = new AggregateGroupByResponse();
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Calculates unique combinations (groups) of values for the given columns
     * in a given table/view/collection and computes aggregates on each unique
     * combination. This is somewhat analogous to an SQL-style SELECT...GROUP
     * BY. Any column(s) can be grouped on, but only non-string (i.e. numeric)
     * columns may be used for computing aggregates. The results can be paged
     * via the {@code offset} and {@code limit} parameters. For example, to get
     * 10 groups with the largest counts the inputs would be: limit=10,
     * options={"sort_order":"descending", "sort_by":"value"}. {@code options}
     * can be used to customize behavior of this call e.g. filtering or sorting
     * the results. To group by 'x' and 'y' and compute the number of objects
     * within each group, use column_names=['x','y','count(*)'].  To also
     * compute the sum of 'z' over each group, use
     * column_names=['x','y','count(*)','sum(z)']. Available aggregation
     * functions are: 'count(*)', 'sum', 'min', 'max', 'avg', 'mean', 'stddev',
     * 'stddev_pop', 'stddev_samp', 'var', 'var_pop', 'var_samp', 'arg_min',
     * 'arg_max' and 'count_distinct'. The response is returned as a dynamic
     * schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>. If the 'result_table' option is provided then
     * the results are stored in a table with the name given in the option and
     * the results are not returned in the response.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be an existing table/view/collection.
     * @param columnNames  List of one or more column names, expressions, and
     *                     aggregate expressions. Must include at least one
     *                     'grouping' column or expression.  If no aggregate is
     *                     included, count(*) will be computed as a default.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned Or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> collection_name: Name of a collection which
     *                 is to contain the table specified in 'result_table',
     *                 otherwise the table will be a top-level table. If the
     *                 collection does not allow duplicate types and it
     *                 contains a table of the same type as the given one, then
     *                 this table creation request will fail. Additionally this
     *                 option is invalid if @input{table_name} is a collection.
     *                         <li> expression: Filter expression to apply to
     *                 the table prior to computing the aggregate group by.
     *                         <li> having: Filter expression to apply to the
     *                 aggregated results.
     *                         <li> sort_order: String indicating how the
     *                 returned values should be sorted - ascending or
     *                 descending. Values: ascending, descending.
     *                         <li> sort_by: String determining how the results
     *                 are sorted. Values: key, value.
     *                         <li> result_table: The name of the table used to
     *                 store the results. Has the same naming restrictions as
     *                 <a href="../../../../concepts/tables.html"
     *                 target="_top">tables</a>. Column names (group-by and
     *                 aggregate fields) need to be given aliases e.g.
     *                 ["FChar256 as fchar256", "sum(FDouble) as sfd"].  If
     *                 present, no results are returned in the response.  This
     *                 option is not available if one of the grouping
     *                 attributes is an unrestricted string (i.e.; not charN)
     *                 type.
     *                         <li> ttl: Sets the TTL of the table specified in
     *                 'result_table'. The value must be the desired TTL in
     *                 minutes.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateGroupByResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateGroupByResponse aggregateGroupBy(String tableName, List<String> columnNames, long offset, long limit, Map<String, String> options) throws GPUdbException {
        AggregateGroupByRequest actualRequest_ = new AggregateGroupByRequest(tableName, columnNames, offset, limit, null, options);
        RawAggregateGroupByResponse actualResponse_ = new RawAggregateGroupByResponse();
        submitRequest("/aggregate/groupby", actualRequest_, actualResponse_, false);
        AggregateGroupByResponse response_ = new AggregateGroupByResponse();
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Performs a histogram calculation given a table, a column, and an
     * interval function. The {@code interval} is used to produce bins of that
     * size and the result, computed over the records falling within each bin,
     * is returned.  For each bin, the start value is inclusive, but the end
     * value is exclusive--except for the very last bin for which the end value
     * is also inclusive.  The value returned for each bin is the number of
     * records in it, except when a column name is provided as a *value_column*
     * in {@code options}.  In this latter case the sum of the values
     * corresponding to the *value_column* is used as the result instead.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateHistogramResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateHistogramResponse aggregateHistogram(AggregateHistogramRequest request) throws GPUdbException {
        AggregateHistogramResponse actualResponse_ = new AggregateHistogramResponse();
        submitRequest("/aggregate/histogram", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Performs a histogram calculation given a table, a column, and an
     * interval function. The {@code interval} is used to produce bins of that
     * size and the result, computed over the records falling within each bin,
     * is returned.  For each bin, the start value is inclusive, but the end
     * value is exclusive--except for the very last bin for which the end value
     * is also inclusive.  The value returned for each bin is the number of
     * records in it, except when a column name is provided as a *value_column*
     * in {@code options}.  In this latter case the sum of the values
     * corresponding to the *value_column* is used as the result instead.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be an existing table or collection.
     * @param columnName  Name of a column or an expression of one or more
     *                    column names over which the histogram will be
     *                    calculated.
     * @param start  Lower end value of the histogram interval, inclusive.
     * @param end  Upper end value of the histogram interval, inclusive.
     * @param interval  The size of each bin within the start and end
     *                  parameters.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> value_column: The name of the column to use
     *                 when calculating the bin values (values are summed).
     *                 The column must be a numerical type (int, double, long,
     *                 float).
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateHistogramResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateHistogramResponse aggregateHistogram(String tableName, String columnName, double start, double end, double interval, Map<String, String> options) throws GPUdbException {
        AggregateHistogramRequest actualRequest_ = new AggregateHistogramRequest(tableName, columnName, start, end, interval, options);
        AggregateHistogramResponse actualResponse_ = new AggregateHistogramResponse();
        submitRequest("/aggregate/histogram", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * This endpoint runs the k-means algorithm - a heuristic algorithm that
     * attempts to do k-means clustering.  An ideal k-means clustering
     * algorithm selects k points such that the sum of the mean squared
     * distances of each member of the set to the nearest of the k points is
     * minimized.  The k-means algorithm however does not necessarily produce
     * such an ideal cluster.   It begins with a randomly selected set of k
     * points and then refines the location of the points iteratively and
     * settles to a local minimum.  Various parameters and options are provided
     * to control the heuristic search.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateKMeansResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateKMeansResponse aggregateKMeans(AggregateKMeansRequest request) throws GPUdbException {
        AggregateKMeansResponse actualResponse_ = new AggregateKMeansResponse();
        submitRequest("/aggregate/kmeans", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * This endpoint runs the k-means algorithm - a heuristic algorithm that
     * attempts to do k-means clustering.  An ideal k-means clustering
     * algorithm selects k points such that the sum of the mean squared
     * distances of each member of the set to the nearest of the k points is
     * minimized.  The k-means algorithm however does not necessarily produce
     * such an ideal cluster.   It begins with a randomly selected set of k
     * points and then refines the location of the points iteratively and
     * settles to a local minimum.  Various parameters and options are provided
     * to control the heuristic search.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be an existing table or collection.
     * @param columnNames  List of column names on which the operation would be
     *                     performed. If n columns are provided then each of
     *                     the k result points will have n dimensions
     *                     corresponding to the n columns.
     * @param k  The number of mean points to be determined by the algorithm.
     * @param tolerance  Stop iterating when the distances between successive
     *                   points is less than the given tolerance.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> whiten: When set to 1 each of the columns
     *                 is first normalized by its stdv - default is not to
     *                 whiten.
     *                         <li> max_iters: Number of times to try to hit
     *                 the tolerance limit before giving up - default is 10.
     *                         <li> num_tries: Number of times to run the
     *                 k-means algorithm with a different randomly selected
     *                 starting points - helps avoid local minimum. Default is
     *                 1.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateKMeansResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateKMeansResponse aggregateKMeans(String tableName, List<String> columnNames, int k, double tolerance, Map<String, String> options) throws GPUdbException {
        AggregateKMeansRequest actualRequest_ = new AggregateKMeansRequest(tableName, columnNames, k, tolerance, options);
        AggregateKMeansResponse actualResponse_ = new AggregateKMeansResponse();
        submitRequest("/aggregate/kmeans", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates and returns the minimum and maximum values of a particular
     * column in a table.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateMinMaxResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateMinMaxResponse aggregateMinMax(AggregateMinMaxRequest request) throws GPUdbException {
        AggregateMinMaxResponse actualResponse_ = new AggregateMinMaxResponse();
        submitRequest("/aggregate/minmax", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates and returns the minimum and maximum values of a particular
     * column in a table.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be an existing table.
     * @param columnName  Name of a column or an expression of one or more
     *                    column on which the min-max will be calculated.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateMinMaxResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateMinMaxResponse aggregateMinMax(String tableName, String columnName, Map<String, String> options) throws GPUdbException {
        AggregateMinMaxRequest actualRequest_ = new AggregateMinMaxRequest(tableName, columnName, options);
        AggregateMinMaxResponse actualResponse_ = new AggregateMinMaxResponse();
        submitRequest("/aggregate/minmax", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates the requested statistics of a given column in a given table.
     * <p>
     * The available statistics are count (number of total objects), mean, stdv
     * (standard deviation), variance, skew, kurtosis, sum, min, max,
     * weighted_average, cardinality (unique count), estimated cardinality,
     * percentile and percentile_rank.
     * <p>
     * Estimated cardinality is calculated by using the hyperloglog
     * approximation technique.
     * <p>
     * Percentiles and percentile_ranks are approximate and are calculated
     * using the t-digest algorithm. They must include the desired
     * percentile/percentile_rank. To compute multiple percentiles each value
     * must be specified separately (i.e.
     * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
     * <p>
     * The weighted average statistic requires a weight_attribute to be
     * specified in {@code options}. The weighted average is then defined as
     * the sum of the products of {@code columnName} times the weight attribute
     * divided by the sum of the weight attribute.
     * <p>
     * The response includes a list of the statistics requested along with the
     * count of the number of items in the given set.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateStatisticsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateStatisticsResponse aggregateStatistics(AggregateStatisticsRequest request) throws GPUdbException {
        AggregateStatisticsResponse actualResponse_ = new AggregateStatisticsResponse();
        submitRequest("/aggregate/statistics", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates the requested statistics of a given column in a given table.
     * <p>
     * The available statistics are count (number of total objects), mean, stdv
     * (standard deviation), variance, skew, kurtosis, sum, min, max,
     * weighted_average, cardinality (unique count), estimated cardinality,
     * percentile and percentile_rank.
     * <p>
     * Estimated cardinality is calculated by using the hyperloglog
     * approximation technique.
     * <p>
     * Percentiles and percentile_ranks are approximate and are calculated
     * using the t-digest algorithm. They must include the desired
     * percentile/percentile_rank. To compute multiple percentiles each value
     * must be specified separately (i.e.
     * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
     * <p>
     * The weighted average statistic requires a weight_attribute to be
     * specified in {@code options}. The weighted average is then defined as
     * the sum of the products of {@code columnName} times the weight attribute
     * divided by the sum of the weight attribute.
     * <p>
     * The response includes a list of the statistics requested along with the
     * count of the number of items in the given set.
     * 
     * @param tableName  Name of the table on which the statistics operation
     *                   will be performed.
     * @param columnName  Name of the column for which the statistics are to be
     *                    calculated.
     * @param stats  Comma separated list of the statistics to calculate, e.g.
     *               "sum,mean". Values: count, mean, stdv, variance, skew,
     *               kurtosis, sum, min, max, weighted_average, cardinality,
     *               estimated_cardinality, percentile, percentile_rank.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> additional_column_names: A list of comma
     *                 separated column names over which statistics can be
     *                 accumulated along with the primary column.
     *                         <li> weight_column_name: Name of column used as
     *                 weighting attribute for the weighted average statistic.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateStatisticsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateStatisticsResponse aggregateStatistics(String tableName, String columnName, String stats, Map<String, String> options) throws GPUdbException {
        AggregateStatisticsRequest actualRequest_ = new AggregateStatisticsRequest(tableName, columnName, stats, options);
        AggregateStatisticsResponse actualResponse_ = new AggregateStatisticsResponse();
        submitRequest("/aggregate/statistics", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Divides the given set into bins and calculates statistics of the values
     * of a value-column in each bin.  The bins are based on the values of a
     * given binning-column.  The statistics that may be requested are mean,
     * stdv (standard deviation), variance, skew, kurtosis, sum, min, max,
     * first, last and weighted average. In addition to the requested
     * statistics the count of total samples in each bin is returned. This
     * counts vector is just the histogram of the column used to divide the set
     * members into bins. The weighted average statistic requires a
     * weight_column to be specified in {@code options}. The weighted average
     * is then defined as the sum of the products of the value column times the
     * weight column divided by the sum of the weight column.
     * <p>
     * There are two methods for binning the set members. In the first, which
     * can be used for numeric valued binning-columns, a min, max and interval
     * are specified. The number of bins, nbins, is the integer upper bound of
     * (max-min)/interval. Values that fall in the range
     * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
     * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In
     * the second method, {@code options} bin_values specifies a list of
     * binning column values. Binning-columns whose value matches the nth
     * member of the bin_values list are placed in the nth bin. When a list is
     * provided the binning-column must be of type string or int.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateStatisticsByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateStatisticsByRangeResponse aggregateStatisticsByRange(AggregateStatisticsByRangeRequest request) throws GPUdbException {
        AggregateStatisticsByRangeResponse actualResponse_ = new AggregateStatisticsByRangeResponse();
        submitRequest("/aggregate/statistics/byrange", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Divides the given set into bins and calculates statistics of the values
     * of a value-column in each bin.  The bins are based on the values of a
     * given binning-column.  The statistics that may be requested are mean,
     * stdv (standard deviation), variance, skew, kurtosis, sum, min, max,
     * first, last and weighted average. In addition to the requested
     * statistics the count of total samples in each bin is returned. This
     * counts vector is just the histogram of the column used to divide the set
     * members into bins. The weighted average statistic requires a
     * weight_column to be specified in {@code options}. The weighted average
     * is then defined as the sum of the products of the value column times the
     * weight column divided by the sum of the weight column.
     * <p>
     * There are two methods for binning the set members. In the first, which
     * can be used for numeric valued binning-columns, a min, max and interval
     * are specified. The number of bins, nbins, is the integer upper bound of
     * (max-min)/interval. Values that fall in the range
     * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
     * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In
     * the second method, {@code options} bin_values specifies a list of
     * binning column values. Binning-columns whose value matches the nth
     * member of the bin_values list are placed in the nth bin. When a list is
     * provided the binning-column must be of type string or int.
     * 
     * @param tableName  Name of the table on which the ranged-statistics
     *                   operation will be performed.
     * @param selectExpression  For a non-empty expression statistics are
     *                          calculated for those records for which the
     *                          expression is true.
     * @param columnName  Name of the binning-column used to divide the set
     *                    samples into bins.
     * @param valueColumnName  Name of the value-column for which statistics
     *                         are to be computed.
     * @param stats  A string of comma separated list of the statistics to
     *               calculate, e.g. 'sum,mean'. Available statistics: mean,
     *               stdv (standard deviation), variance, skew, kurtosis, sum.
     * @param start  The lower bound of the binning-column.
     * @param end  The upper bound of the binning-column.
     * @param interval  The interval of a bin. Set members fall into bin i if
     *                  the binning-column falls in the range
     *                  [start+interval``*``i, start+interval``*``(i+1)).
     * @param options  Map of optional parameters:
     *                 <ul>
     *                         <li> additional_column_names: A list of comma
     *                 separated value-column names over which statistics can
     *                 be accumulated along with the primary value_column.
     *                         <li> bin_values: A list of comma separated
     *                 binning-column values. Values that match the nth
     *                 bin_values value are placed in the nth bin.
     *                         <li> weight_column_name: Name of the column used
     *                 as weighting column for the weighted_average statistic.
     *                         <li> order_column_name: Name of the column used
     *                 for candlestick charting techniques.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateStatisticsByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateStatisticsByRangeResponse aggregateStatisticsByRange(String tableName, String selectExpression, String columnName, String valueColumnName, String stats, double start, double end, double interval, Map<String, String> options) throws GPUdbException {
        AggregateStatisticsByRangeRequest actualRequest_ = new AggregateStatisticsByRangeRequest(tableName, selectExpression, columnName, valueColumnName, stats, start, end, interval, options);
        AggregateStatisticsByRangeResponse actualResponse_ = new AggregateStatisticsByRangeResponse();
        submitRequest("/aggregate/statistics/byrange", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns all the unique values from a particular column (specified by
     * {@code columnName}) of a particular table (specified by {@code
     * tableName}). If {@code columnName} is a numeric column the values will
     * be in {@code binaryEncodedResponse}. Otherwise if {@code columnName} is
     * a string column the values will be in {@code jsonEncodedResponse}.
     * {@code offset} and {@code limit} are used to page through the results if
     * there are large numbers of unique values. To get the first 10 unique
     * values sorted in descending order {@code options} would be::
     * <p>
     * {"limit":"10","sort_order":"descending"}.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>. If the 'result_table' option is provided then
     * the results are stored in a table with the name given in the option and
     * the results are not returned in the response.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawAggregateUniqueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawAggregateUniqueResponse aggregateUniqueRaw(AggregateUniqueRequest request) throws GPUdbException {
        RawAggregateUniqueResponse actualResponse_ = new RawAggregateUniqueResponse();
        submitRequest("/aggregate/unique", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns all the unique values from a particular column (specified by
     * {@code columnName}) of a particular table (specified by {@code
     * tableName}). If {@code columnName} is a numeric column the values will
     * be in {@code binaryEncodedResponse}. Otherwise if {@code columnName} is
     * a string column the values will be in {@code jsonEncodedResponse}.
     * {@code offset} and {@code limit} are used to page through the results if
     * there are large numbers of unique values. To get the first 10 unique
     * values sorted in descending order {@code options} would be::
     * <p>
     * {"limit":"10","sort_order":"descending"}.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>. If the 'result_table' option is provided then
     * the results are stored in a table with the name given in the option and
     * the results are not returned in the response.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateUniqueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateUniqueResponse aggregateUnique(AggregateUniqueRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawAggregateUniqueResponse actualResponse_ = new RawAggregateUniqueResponse();
        submitRequest("/aggregate/unique", request, actualResponse_, false);
        AggregateUniqueResponse response_ = new AggregateUniqueResponse();
        response_.setTableName(actualResponse_.getTableName());
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Returns all the unique values from a particular column (specified by
     * {@code columnName}) of a particular table (specified by {@code
     * tableName}). If {@code columnName} is a numeric column the values will
     * be in {@code binaryEncodedResponse}. Otherwise if {@code columnName} is
     * a string column the values will be in {@code jsonEncodedResponse}.
     * {@code offset} and {@code limit} are used to page through the results if
     * there are large numbers of unique values. To get the first 10 unique
     * values sorted in descending order {@code options} would be::
     * <p>
     * {"limit":"10","sort_order":"descending"}.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>. If the 'result_table' option is provided then
     * the results are stored in a table with the name given in the option and
     * the results are not returned in the response.
     * 
     * @param tableName  Name of the table on which the operation will be
     *                   performed. Must be an existing table.
     * @param columnName  Name of the column or an expression containing one or
     *                    more column names on which the unique function would
     *                    be applied.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned. Or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> collection_name: Name of a collection which
     *                 is to contain the table specified in 'result_table',
     *                 otherwise the table will be a top-level table. If the
     *                 collection does not allow duplicate types and it
     *                 contains a table of the same type as the given one, then
     *                 this table creation request will fail.
     *                         <li> expression: Optional filter expression to
     *                 apply to the table.
     *                         <li> sort_order: String indicating how the
     *                 returned values should be sorted. Values: ascending,
     *                 descending.
     *                         <li> result_table: The name of the table used to
     *                 store the results. If present no results are returned in
     *                 the response. Has the same naming restrictions as <a
     *                 href="../../../../concepts/tables.html"
     *                 target="_top">tables</a>.
     *                         <li> ttl: Sets the TTL of the table specified in
     *                 'result_table'. The value must be the desired TTL in
     *                 minutes.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AggregateUniqueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AggregateUniqueResponse aggregateUnique(String tableName, String columnName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        AggregateUniqueRequest actualRequest_ = new AggregateUniqueRequest(tableName, columnName, offset, limit, null, options);
        RawAggregateUniqueResponse actualResponse_ = new RawAggregateUniqueResponse();
        submitRequest("/aggregate/unique", actualRequest_, actualResponse_, false);
        AggregateUniqueResponse response_ = new AggregateUniqueResponse();
        response_.setTableName(actualResponse_.getTableName());
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * The {@link GPUdb#alterSystemProperties(AlterSystemPropertiesRequest)}
     * endpoint is primarily used to simplify the testing of the system and is
     * not expected to be used during normal execution.  Commands are given
     * through the {@code propertyUpdatesMap} whose keys are commands and
     * values are strings representing integer values (for example '8000') or
     * boolean values ('true' or 'false').
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterSystemPropertiesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterSystemPropertiesResponse alterSystemProperties(AlterSystemPropertiesRequest request) throws GPUdbException {
        AlterSystemPropertiesResponse actualResponse_ = new AlterSystemPropertiesResponse();
        submitRequest("/alter/system/properties", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * The {@link GPUdb#alterSystemProperties(Map, Map)} endpoint is primarily
     * used to simplify the testing of the system and is not expected to be
     * used during normal execution.  Commands are given through the {@code
     * propertyUpdatesMap} whose keys are commands and values are strings
     * representing integer values (for example '8000') or boolean values
     * ('true' or 'false').
     * 
     * @param propertyUpdatesMap  Map containing the properties of the system
     *                            to be updated. Error if empty.
     *                            <ul>
     *                                    <li> sm_omp_threads: Set the number
     *                            of OpenMP threads that will be used to
     *                            service filter & aggregation requests against
     *                            collections to the specified integer value.
     *                                    <li> kernel_omp_threads: Set the
     *                            number of kernel OpenMP threads to the
     *                            specified integer value.
     *                                    <li> concurrent_kernel_execution:
     *                            Enables concurrent kernel execution if the
     *                            value is {@code true} and disables it if the
     *                            value is {@code false}. Values: true, false.
     *                                    <li> chunk_size: Sets the chunk size
     *                            of all new sets to the specified integer
     *                            value.
     *                                    <li> flush_to_disk: Flushes any
     *                            changes to any tables to the persistent
     *                            store.  These changes include updates to the
     *                            vector store, object store, and text search
     *                            store, Value string is ignored
     *                                    <li> clear_cache: Clears cached
     *                            results.  Useful to allow repeated timing of
     *                            endpoints. Value string is ignored
     *                                    <li> communicator_test: Invoke the
     *                            communicator test and report timing results.
     *                            Value string is is a comma separated list of
     *                            <key>=<value> expressions.  Expressions are:
     *                            num_transactions=<num> where num is the
     *                            number of request reply transactions to
     *                            invoke per test; message_size=<bytes> where
     *                            bytes is the size of the messages to send in
     *                            bytes; check_values=<enabled> where if
     *                            enabled is true the value of the messages
     *                            received are verified.
     *                                    <li> set_message_timers_enabled:
     *                            Enables the communicator test to collect
     *                            additional timing statistics when the value
     *                            string is {@code true}. Disables the
     *                            collection when the value string is {@code
     *                            false} Values: true, false.
     *                                    <li> bulk_add_test: Invoke the bulk
     *                            add test and report timing results. Value
     *                            string is ignored.
     *                                    <li> network_speed: Invoke the
     *                            network speed test and report timing results.
     *                            Value string is a semicolon-separated list of
     *                            <key>=<value> expressions.  Valid expressions
     *                            are: seconds=<time> where time is the time in
     *                            seconds to run the test; data_size=<size>
     *                            where size is the size in bytes of the block
     *                            to be transferred; threads=<number of
     *                            threads>; to_ranks=<space-separated list of
     *                            ranks> where the list of ranks is the ranks
     *                            that rank 0 will send data to and get data
     *                            from. If to_ranks is unspecified then all
     *                            worker ranks are used.
     *                                    <li> request_timeout: Number of
     *                            minutes after which filtering (e.g., {@link
     *                            GPUdb#filter(String, String, String, Map)})
     *                            and aggregating (e.g., {@link
     *                            GPUdb#aggregateGroupByRaw(AggregateGroupByRequest)})
     *                            queries will timeout.
     *                                    <li> max_get_records_size: The
     *                            maximum number of records the database will
     *                            serve for a given data retrieval call
     *                            </ul>
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterSystemPropertiesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterSystemPropertiesResponse alterSystemProperties(Map<String, String> propertyUpdatesMap, Map<String, String> options) throws GPUdbException {
        AlterSystemPropertiesRequest actualRequest_ = new AlterSystemPropertiesRequest(propertyUpdatesMap, options);
        AlterSystemPropertiesResponse actualResponse_ = new AlterSystemPropertiesResponse();
        submitRequest("/alter/system/properties", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Apply various modifications to a table or collection. Available
     * modifications include:
     * <p>
     *      Creating or deleting an index on a particular column. This can
     * speed up certain search queries (such as {@link
     * GPUdb#getRecordsRaw(GetRecordsRequest)}, {@link
     * GPUdb#deleteRecords(DeleteRecordsRequest)}, {@link
     * GPUdb#updateRecordsRaw(RawUpdateRecordsRequest)}) when using expressions
     * containing equality or relational operators on indexed columns. This
     * only applies to tables.
     * <p>
     *      Setting the time-to-live (TTL). This can be applied to tables,
     * views, or collections.  When applied to collections, every table & view
     * within the collection will have its TTL set to the given value.
     * <p>
     *      Making a table protected or not. Protected tables have their TTLs
     * set to not automatically expire. This can be applied to tables, views,
     * and collections.
     * <p>
     *      Allowing homogeneous tables within a collection.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterTableResponse alterTable(AlterTableRequest request) throws GPUdbException {
        AlterTableResponse actualResponse_ = new AlterTableResponse();
        submitRequest("/alter/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Apply various modifications to a table or collection. Available
     * modifications include:
     * <p>
     *      Creating or deleting an index on a particular column. This can
     * speed up certain search queries (such as {@link
     * GPUdb#getRecordsRaw(GetRecordsRequest)}, {@link
     * GPUdb#deleteRecords(String, List, Map)}, {@link
     * GPUdb#updateRecordsRaw(RawUpdateRecordsRequest)}) when using expressions
     * containing equality or relational operators on indexed columns. This
     * only applies to tables.
     * <p>
     *      Setting the time-to-live (TTL). This can be applied to tables,
     * views, or collections.  When applied to collections, every table & view
     * within the collection will have its TTL set to the given value.
     * <p>
     *      Making a table protected or not. Protected tables have their TTLs
     * set to not automatically expire. This can be applied to tables, views,
     * and collections.
     * <p>
     *      Allowing homogeneous tables within a collection.
     * 
     * @param tableName  Table on which the operation will be performed. Must
     *                   be an existing table, view, or collection.
     * @param action  Modification operation to be applied Values:
     *                create_index, delete_index, allow_homogeneous_tables,
     *                protected, ttl, add_column, delete_column, change_column,
     *                rename_table.
     * @param value  The value of the modification. May be a column name,
     *               'true' or 'false', or a TTL depending on {@code action}.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> column_default_value: when adding a column:
     *                 set a default value, for existing data.
     *                         <li> column_properties: when adding or changing
     *                 a column: set the column properties (strings, separated
     *                 by a comma: data, store_only, text_search, char8, int8
     *                 etc).
     *                         <li> column_type: when adding or changing a
     *                 column: set the column type (strings, separated by a
     *                 comma: int, double, string, null etc).
     *                         <li> validate_change_column: Validate the type
     *                 change before applying column_change request. Default is
     *                 true (if option is missing). If True, then validate all
     *                 values. A value too large (or too long) for the new type
     *                 will prevent any change. If False, then when a value is
     *                 too large or long, it will be truncated. Values: true,
     *                 false.
     *                         <li> copy_values_from_column: when adding or
     *                 changing a column: enter column name - from where to
     *                 copy values.
     *                         <li> rename_column: new column name (using
     *                 change_column).
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterTableResponse alterTable(String tableName, String action, String value, Map<String, String> options) throws GPUdbException {
        AlterTableRequest actualRequest_ = new AlterTableRequest(tableName, action, value, options);
        AlterTableResponse actualResponse_ = new AlterTableResponse();
        submitRequest("/alter/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Updates (adds or changes) metadata for tables. The metadata key and
     * values must both be strings. This is an easy way to annotate whole
     * tables rather than single records within tables.  Some examples of
     * metadata are owner of the table, table creation timestamp etc.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterTableMetadataResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterTableMetadataResponse alterTableMetadata(AlterTableMetadataRequest request) throws GPUdbException {
        AlterTableMetadataResponse actualResponse_ = new AlterTableMetadataResponse();
        submitRequest("/alter/table/metadata", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Updates (adds or changes) metadata for tables. The metadata key and
     * values must both be strings. This is an easy way to annotate whole
     * tables rather than single records within tables.  Some examples of
     * metadata are owner of the table, table creation timestamp etc.
     * 
     * @param tableNames  Names of the tables whose metadata will be updated.
     *                    All specified tables must exist, or an error will be
     *                    returned.
     * @param metadataMap  A map which contains the metadata of the tables that
     *                     are to be updated. Note that only one map is
     *                     provided for all the tables; so the change will be
     *                     applied to every table. If the provided map is
     *                     empty, then all existing metadata for the table(s)
     *                     will be cleared.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterTableMetadataResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterTableMetadataResponse alterTableMetadata(List<String> tableNames, Map<String, String> metadataMap, Map<String, String> options) throws GPUdbException {
        AlterTableMetadataRequest actualRequest_ = new AlterTableMetadataRequest(tableNames, metadataMap, options);
        AlterTableMetadataResponse actualResponse_ = new AlterTableMetadataResponse();
        submitRequest("/alter/table/metadata", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Alters a user.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterUserResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterUserResponse alterUser(AlterUserRequest request) throws GPUdbException {
        AlterUserResponse actualResponse_ = new AlterUserResponse();
        submitRequest("/alter/user", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Alters a user.
     * 
     * @param name  Name of the user to be altered. Must be an existing user.
     * @param action  Modification operation to be applied to the user. Values:
     *                set_password.
     * @param value  The value of the modification, depending on {@code
     *               action}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  AlterUserResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public AlterUserResponse alterUser(String name, String action, String value, Map<String, String> options) throws GPUdbException {
        AlterUserRequest actualRequest_ = new AlterUserRequest(name, action, value, options);
        AlterUserResponse actualResponse_ = new AlterUserResponse();
        submitRequest("/alter/user", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Clears (drops) one or all tables in the database cluster. The operation
     * is synchronous meaning that the table will be cleared before the
     * function returns. The response payload returns the status of the
     * operation along with the name of the table that was cleared.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTableResponse clearTable(ClearTableRequest request) throws GPUdbException {
        ClearTableResponse actualResponse_ = new ClearTableResponse();
        submitRequest("/clear/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Clears (drops) one or all tables in the database cluster. The operation
     * is synchronous meaning that the table will be cleared before the
     * function returns. The response payload returns the status of the
     * operation along with the name of the table that was cleared.
     * 
     * @param tableName  Name of the table to be cleared. Must be an existing
     *                   table. Empty string clears all available tables.
     * @param authorization  No longer used. User can pass an empty string.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTableResponse clearTable(String tableName, String authorization, Map<String, String> options) throws GPUdbException {
        ClearTableRequest actualRequest_ = new ClearTableRequest(tableName, authorization, options);
        ClearTableResponse actualResponse_ = new ClearTableResponse();
        submitRequest("/clear/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deactivates a table monitor previously created with {@link
     * GPUdb#createTableMonitor(CreateTableMonitorRequest)}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTableMonitorResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTableMonitorResponse clearTableMonitor(ClearTableMonitorRequest request) throws GPUdbException {
        ClearTableMonitorResponse actualResponse_ = new ClearTableMonitorResponse();
        submitRequest("/clear/tablemonitor", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deactivates a table monitor previously created with {@link
     * GPUdb#createTableMonitor(String, Map)}.
     * 
     * @param topicId  The topic ID returned by {@link
     *                 GPUdb#createTableMonitor(String, Map)}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTableMonitorResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTableMonitorResponse clearTableMonitor(String topicId, Map<String, String> options) throws GPUdbException {
        ClearTableMonitorRequest actualRequest_ = new ClearTableMonitorRequest(topicId, options);
        ClearTableMonitorResponse actualResponse_ = new ClearTableMonitorResponse();
        submitRequest("/clear/tablemonitor", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Clears or cancels the trigger identified by the specified handle. The
     * output returns the handle of the trigger cleared as well as indicating
     * success or failure of the trigger deactivation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTriggerResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTriggerResponse clearTrigger(ClearTriggerRequest request) throws GPUdbException {
        ClearTriggerResponse actualResponse_ = new ClearTriggerResponse();
        submitRequest("/clear/trigger", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Clears or cancels the trigger identified by the specified handle. The
     * output returns the handle of the trigger cleared as well as indicating
     * success or failure of the trigger deactivation.
     * 
     * @param triggerId  ID for the trigger to be deactivated.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ClearTriggerResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ClearTriggerResponse clearTrigger(String triggerId, Map<String, String> options) throws GPUdbException {
        ClearTriggerRequest actualRequest_ = new ClearTriggerRequest(triggerId, options);
        ClearTriggerResponse actualResponse_ = new ClearTriggerResponse();
        submitRequest("/clear/trigger", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a table that is the result of a SQL JOIN.  For details see: <a
     * href="../../../../concepts/joins.html" target="_top">join concept
     * documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateJoinTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateJoinTableResponse createJoinTable(CreateJoinTableRequest request) throws GPUdbException {
        CreateJoinTableResponse actualResponse_ = new CreateJoinTableResponse();
        submitRequest("/create/jointable", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a table that is the result of a SQL JOIN.  For details see: <a
     * href="../../../../concepts/joins.html" target="_top">join concept
     * documentation</a>.
     * 
     * @param joinTableName  Name of the join table to be created.  Has the
     *                       same naming restrictions as <a
     *                       href="../../../../concepts/tables.html"
     *                       target="_top">tables</a>.
     * @param tableNames  The list of table names making up the joined set.
     *                    Corresponds to a SQL statement FROM clause
     * @param columnNames  List of columns to be included in the join table.
     *                     Can be the column_names from the member sets if
     *                     unique or can be prefixed by the table id as
     *                     <id>.<column_name> where <id> is the table name or
     *                     alias. Can be specified as aliased via the syntax
     *                     '<column_name> as <alias>. Can use wild cards as '*'
     *                     (include all columns), or <id>.* (include all
     *                     columns from table with name or alias <id>)
     * @param expressions  An optional list of expressions to combine and
     *                     filter the joined set.  Corresponds to a SQL
     *                     statement WHERE clause. For details see: <a
     *                     href="../../../../concepts/expressions.html"
     *                     target="_top">expressions</a>.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> collection_name: Name of a collection which
     *                 is to contain the join table. If empty, then the join
     *                 table will be a top-level table.
     *                         <li> max_query_dimensions: The maximum number of
     *                 tables in a joined table that can be accessed by a query
     *                 and are not equated by a foreign-key to primary-key
     *                 equality predicate
     *                         <li> optimize_lookups: Use the applied filters
     *                 to precalculate the lookup table to get data from the
     *                 primary key sets
     *                         <li> refresh_method: Method by which the join
     *                 table can be refreshed when underlying member tables
     *                 have changed. Values: manual, on_query, on_insert.
     *                         <li> refresh: Do a manual refresh of the join
     *                 table if it exists - throws an error otherwise Values:
     *                 no_refresh, refresh, full_refresh.
     *                         <li> ttl: Sets the TTL of the table specified in
     *                 {@code joinTableName}. The value must be the desired TTL
     *                 in minutes.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateJoinTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateJoinTableResponse createJoinTable(String joinTableName, List<String> tableNames, List<String> columnNames, List<String> expressions, Map<String, String> options) throws GPUdbException {
        CreateJoinTableRequest actualRequest_ = new CreateJoinTableRequest(joinTableName, tableNames, columnNames, expressions, options);
        CreateJoinTableResponse actualResponse_ = new CreateJoinTableResponse();
        submitRequest("/create/jointable", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates an instance (proc) of the user-defined function (UDF) specified
     * by the given command, options, and files, and makes it available for
     * execution.  For details on UDFs, see: <a
     * href="../../../../concepts/udf.html" target="_top">User-Defined
     * Functions</a>
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateProcResponse createProc(CreateProcRequest request) throws GPUdbException {
        CreateProcResponse actualResponse_ = new CreateProcResponse();
        submitRequest("/create/proc", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates an instance (proc) of the user-defined function (UDF) specified
     * by the given command, options, and files, and makes it available for
     * execution.  For details on UDFs, see: <a
     * href="../../../../concepts/udf.html" target="_top">User-Defined
     * Functions</a>
     * 
     * @param procName  Name of the proc to be created. Must not be the name of
     *                  a currently existing proc.
     * @param executionMode  The execution mode of the proc. Values:
     *                       distributed, nondistributed.
     * @param files  A map of the files that make up the proc. The keys of the
     *               map are file names, and the values are the binary contents
     *               of the files. The file names may include subdirectory
     *               names (e.g. 'subdir/file') but must not resolve to a
     *               directory above the root for the proc.
     * @param command  The command (excluding arguments) that will be invoked
     *                 when the proc is executed. It will be invoked from the
     *                 directory containing the proc {@code files} and may be
     *                 any command that can be resolved from that directory. It
     *                 need not refer to a file actually in that directory; for
     *                 example, it could be 'java' if the proc is a Java
     *                 application; however, any necessary external programs
     *                 must be preinstalled on every database node. If the
     *                 command refers to a file in that directory, it must be
     *                 preceded with './' as per Linux convention. If not
     *                 specified, and exactly one file is provided in {@code
     *                 files}, that file will be invoked.
     * @param args  An array of command-line arguments that will be passed to
     *              {@code command} when the proc is executed.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateProcResponse createProc(String procName, String executionMode, Map<String, ByteBuffer> files, String command, List<String> args, Map<String, String> options) throws GPUdbException {
        CreateProcRequest actualRequest_ = new CreateProcRequest(procName, executionMode, files, command, args, options);
        CreateProcResponse actualResponse_ = new CreateProcResponse();
        submitRequest("/create/proc", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new projection of an existing table.  A projection represents
     * a subset of the columns (potentially including derived columns) of a
     * table.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateProjectionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateProjectionResponse createProjection(CreateProjectionRequest request) throws GPUdbException {
        CreateProjectionResponse actualResponse_ = new CreateProjectionResponse();
        submitRequest("/create/projection", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new projection of an existing table.  A projection represents
     * a subset of the columns (potentially including derived columns) of a
     * table.
     * 
     * @param tableName  Name of the existing table on which the projection is
     *                   to be applied.
     * @param projectionName  Name of the projection to be created. Has the
     *                        same naming restrictions as <a
     *                        href="../../../../concepts/tables.html"
     *                        target="_top">tables</a>.
     * @param columnNames  List of columns from {@code tableName} to be
     *                     included in the projection. Can include derived
     *                     columns. Can be specified as aliased via the syntax
     *                     '<column_name> as <alias>.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> collection_name: Name of a collection to
     *                 which the projection is to be assigned as a child.
     *                         <li> expression: An optional filter expression
     *                 to be applied to the source table prior to the
     *                 projection.
     *                         <li> limit: The number of records to keep.
     *                         <li> order_by: Comma-separated list of the
     *                 columns to be sorted by; e.g. 'timestamp asc, x desc'.
     *                 The columns specified must be present in {@code
     *                 columnNames}.  If any alias is given for any column
     *                 name, the alias must be used, rather than the original
     *                 column name.
     *                         <li> materialize_on_gpu: If 'true' then the
     *                 columns of the projection will be cached on the GPU.
     *                 Values: true, false.
     *                         <li> ttl: Sets the TTL of the table, view, or
     *                 collection specified in {@code tableName}. The value
     *                 must be the desired TTL in minutes.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateProjectionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateProjectionResponse createProjection(String tableName, String projectionName, List<String> columnNames, Map<String, String> options) throws GPUdbException {
        CreateProjectionRequest actualRequest_ = new CreateProjectionRequest(tableName, projectionName, columnNames, options);
        CreateProjectionResponse actualResponse_ = new CreateProjectionResponse();
        submitRequest("/create/projection", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new role.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateRoleResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateRoleResponse createRole(CreateRoleRequest request) throws GPUdbException {
        CreateRoleResponse actualResponse_ = new CreateRoleResponse();
        submitRequest("/create/role", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new role.
     * 
     * @param name  Name of the role to be created. Must contain only lowercase
     *              letters, digits, and underscores, and cannot begin with a
     *              digit. Must not be the same name as an existing user or
     *              role.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateRoleResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateRoleResponse createRole(String name, Map<String, String> options) throws GPUdbException {
        CreateRoleRequest actualRequest_ = new CreateRoleRequest(name, options);
        CreateRoleResponse actualResponse_ = new CreateRoleResponse();
        submitRequest("/create/role", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new table or collection. If a new table is being created, the
     * type of the table is given by {@code typeId}, which must the be the ID
     * of a currently registered type (i.e. one created via {@link
     * GPUdb#createType(CreateTypeRequest)}). The table will be created inside
     * a collection if the option {@code collection_name} is specified. If that
     * collection does not already exist, it will be created.

     * To create a new collection, specify the name of the collection in {@code
     * tableName} and set the {@code is_collection} option to {@code true};
     * {@code typeId} will be ignored.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTableResponse createTable(CreateTableRequest request) throws GPUdbException {
        CreateTableResponse actualResponse_ = new CreateTableResponse();
        submitRequest("/create/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new table or collection. If a new table is being created, the
     * type of the table is given by {@code typeId}, which must the be the ID
     * of a currently registered type (i.e. one created via {@link
     * GPUdb#createType(String, String, Map, Map)}). The table will be created
     * inside a collection if the option {@code collection_name} is specified.
     * If that collection does not already exist, it will be created.

     * To create a new collection, specify the name of the collection in {@code
     * tableName} and set the {@code is_collection} option to {@code true};
     * {@code typeId} will be ignored.
     * 
     * @param tableName  Name of the table to be created. Error for requests
     *                   with existing table of the same name and type id may
     *                   be suppressed by using the {@code no_error_if_exists}
     *                   option.  See <a
     *                   href="../../../../concepts/tables.html"
     *                   target="_top">Tables</a> for naming restrictions.
     * @param typeId  ID of a currently registered type. All objects added to
     *                the newly created table will be of this type.  Ignored if
     *                {@code is_collection} is {@code true}.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> no_error_if_exists: If {@code true},
     *                 prevents an error from occurring if the table already
     *                 exists and is of the given type.  If a table with the
     *                 same ID but a different type exists, it is still an
     *                 error. Values: true, false.
     *                         <li> collection_name: Name of a collection which
     *                 is to contain the newly created table. If empty, then
     *                 the newly created table will be a top-level table. If
     *                 the collection does not allow duplicate types and it
     *                 contains a table of the same type as the given one, then
     *                 this table creation request will fail.
     *                         <li> is_collection: Indicates whether the new
     *                 table to be created will be a collection. Values: true,
     *                 false.
     *                         <li> disallow_homogeneous_tables: For a
     *                 collection, indicates whether the collection prohibits
     *                 containment of multiple tables of exactly the same data
     *                 type. Values: true, false.
     *                         <li> is_replicated: For a table, indicates
     *                 whether the table is to be replicated to all the
     *                 database ranks. This may be necessary when the table is
     *                 to be joined with other tables in a query. Values: true,
     *                 false.
     *                         <li> foreign_keys: Semicolon-separated list of
     *                 foreign key constraints, of the format 'source_column
     *                 references target_table(primary_key_column)'.
     *                         <li> foreign_shard_key: Foreign shard key
     *                 description of the format: <fk_foreign_key> references
     *                 <pk_column_name> from <pk_table_name>(<pk_primary_key>)
     *                         <li> ttl: Sets the TTL of the table or
     *                 collection specified in {@code tableName}. The value
     *                 must be the desired TTL in minutes.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTableResponse createTable(String tableName, String typeId, Map<String, String> options) throws GPUdbException {
        CreateTableRequest actualRequest_ = new CreateTableRequest(tableName, typeId, options);
        CreateTableResponse actualResponse_ = new CreateTableResponse();
        submitRequest("/create/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a monitor that watches for new records inserted into a
     * particular table (identified by {@code tableName}) and forwards copies
     * to subscribers via ZMQ. After this call completes, subscribe to the
     * returned {@code topicId} on the ZMQ table monitor port (default 9002).
     * Each time an insert operation on the table completes, a multipart
     * message is published for that topic; the first part contains only the
     * topic ID, and each subsequent part contains one binary-encoded Avro
     * object that was inserted. The monitor will continue to run (regardless
     * of whether or not there are any subscribers) until deactivated with
     * {@link GPUdb#clearTableMonitor(ClearTableMonitorRequest)}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTableMonitorResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTableMonitorResponse createTableMonitor(CreateTableMonitorRequest request) throws GPUdbException {
        CreateTableMonitorResponse actualResponse_ = new CreateTableMonitorResponse();
        submitRequest("/create/tablemonitor", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a monitor that watches for new records inserted into a
     * particular table (identified by {@code tableName}) and forwards copies
     * to subscribers via ZMQ. After this call completes, subscribe to the
     * returned {@code topicId} on the ZMQ table monitor port (default 9002).
     * Each time an insert operation on the table completes, a multipart
     * message is published for that topic; the first part contains only the
     * topic ID, and each subsequent part contains one binary-encoded Avro
     * object that was inserted. The monitor will continue to run (regardless
     * of whether or not there are any subscribers) until deactivated with
     * {@link GPUdb#clearTableMonitor(String, Map)}.
     * 
     * @param tableName  Name of the table to monitor. Must not refer to a
     *                   collection.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTableMonitorResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTableMonitorResponse createTableMonitor(String tableName, Map<String, String> options) throws GPUdbException {
        CreateTableMonitorRequest actualRequest_ = new CreateTableMonitorRequest(tableName, options);
        CreateTableMonitorResponse actualResponse_ = new CreateTableMonitorResponse();
        submitRequest("/create/tablemonitor", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Sets up an area trigger mechanism for two column_names for one or more
     * tables. (This function is essentially the two-dimensional version of
     * {@link GPUdb#createTriggerByRange(CreateTriggerByRangeRequest)}.) Once
     * the trigger has been activated, any record added to the listed tables(s)
     * via {@link GPUdb#insertRecordsRaw(RawInsertRecordsRequest)} with the
     * chosen columns' values falling within the specified region will trip the
     * trigger. All such records will be queued at the trigger port (by default
     * '9001', but able to be retrieved via {@link
     * GPUdb#showSystemStatus(ShowSystemStatusRequest)}) for any listening
     * client to collect. Active triggers can be cancelled by using the {@link
     * GPUdb#clearTrigger(ClearTriggerRequest)} endpoint or by clearing all
     * relevant tables.
     * <p>
     * The output returns the trigger handle as well as indicating success or
     * failure of the trigger activation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTriggerByAreaResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTriggerByAreaResponse createTriggerByArea(CreateTriggerByAreaRequest request) throws GPUdbException {
        CreateTriggerByAreaResponse actualResponse_ = new CreateTriggerByAreaResponse();
        submitRequest("/create/trigger/byarea", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Sets up an area trigger mechanism for two column_names for one or more
     * tables. (This function is essentially the two-dimensional version of
     * {@link GPUdb#createTriggerByRange(String, List, String, double, double,
     * Map)}.) Once the trigger has been activated, any record added to the
     * listed tables(s) via {@link
     * GPUdb#insertRecordsRaw(RawInsertRecordsRequest)} with the chosen
     * columns' values falling within the specified region will trip the
     * trigger. All such records will be queued at the trigger port (by default
     * '9001', but able to be retrieved via {@link
     * GPUdb#showSystemStatus(Map)}) for any listening client to collect.
     * Active triggers can be cancelled by using the {@link
     * GPUdb#clearTrigger(String, Map)} endpoint or by clearing all relevant
     * tables.
     * <p>
     * The output returns the trigger handle as well as indicating success or
     * failure of the trigger activation.
     * 
     * @param requestId  ID for the trigger to be activated.
     * @param tableNames  Names of the tables on which the trigger will be
     *                    activated and maintained.
     * @param xColumnName  Name of a numeric column on which the trigger is
     *                     activated. Usually 'x' for geospatial data points.
     * @param xVector  The respective coordinate values for the region on which
     *                 the trigger is activated. This usually translates to the
     *                 x-coordinates of a geospatial region.
     * @param yColumnName  Name of a second numeric column on which the trigger
     *                     is activated. Usually 'y' for geospatial data
     *                     points.
     * @param yVector  The respective coordinate values for the region on which
     *                 the trigger is activated. This usually translates to the
     *                 y-coordinates of a geospatial region. Must be the same
     *                 length as xvals.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTriggerByAreaResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTriggerByAreaResponse createTriggerByArea(String requestId, List<String> tableNames, String xColumnName, List<Double> xVector, String yColumnName, List<Double> yVector, Map<String, String> options) throws GPUdbException {
        CreateTriggerByAreaRequest actualRequest_ = new CreateTriggerByAreaRequest(requestId, tableNames, xColumnName, xVector, yColumnName, yVector, options);
        CreateTriggerByAreaResponse actualResponse_ = new CreateTriggerByAreaResponse();
        submitRequest("/create/trigger/byarea", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Sets up a simple range trigger for a column_name for one or more tables.
     * Once the trigger has been activated, any record added to the listed
     * tables(s) via {@link GPUdb#insertRecordsRaw(RawInsertRecordsRequest)}
     * with the chosen column_name's value falling within the specified range
     * will trip the trigger. All such records will be queued at the trigger
     * port (by default '9001', but able to be retrieved via {@link
     * GPUdb#showSystemStatus(ShowSystemStatusRequest)}) for any listening
     * client to collect. Active triggers can be cancelled by using the {@link
     * GPUdb#clearTrigger(ClearTriggerRequest)} endpoint or by clearing all
     * relevant tables.
     * <p>
     * The output returns the trigger handle as well as indicating success or
     * failure of the trigger activation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTriggerByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTriggerByRangeResponse createTriggerByRange(CreateTriggerByRangeRequest request) throws GPUdbException {
        CreateTriggerByRangeResponse actualResponse_ = new CreateTriggerByRangeResponse();
        submitRequest("/create/trigger/byrange", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Sets up a simple range trigger for a column_name for one or more tables.
     * Once the trigger has been activated, any record added to the listed
     * tables(s) via {@link GPUdb#insertRecordsRaw(RawInsertRecordsRequest)}
     * with the chosen column_name's value falling within the specified range
     * will trip the trigger. All such records will be queued at the trigger
     * port (by default '9001', but able to be retrieved via {@link
     * GPUdb#showSystemStatus(Map)}) for any listening client to collect.
     * Active triggers can be cancelled by using the {@link
     * GPUdb#clearTrigger(String, Map)} endpoint or by clearing all relevant
     * tables.
     * <p>
     * The output returns the trigger handle as well as indicating success or
     * failure of the trigger activation.
     * 
     * @param requestId  ID for the trigger request.
     * @param tableNames  Tables on which the trigger will be active.
     * @param columnName  Name of a numeric column_name on which the trigger is
     *                    activated.
     * @param min  The lower bound (inclusive) for the trigger range.
     * @param max  The upper bound (inclusive) for the trigger range.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTriggerByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTriggerByRangeResponse createTriggerByRange(String requestId, List<String> tableNames, String columnName, double min, double max, Map<String, String> options) throws GPUdbException {
        CreateTriggerByRangeRequest actualRequest_ = new CreateTriggerByRangeRequest(requestId, tableNames, columnName, min, max, options);
        CreateTriggerByRangeResponse actualResponse_ = new CreateTriggerByRangeResponse();
        submitRequest("/create/trigger/byrange", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new type describing the layout or schema of a table. The type
     * definition is a JSON string describing the fields (i.e. columns) of the
     * type. Each field consists of a name and a data type. Supported data
     * types are: double, float, int, long, string, and bytes. In addition one
     * or more properties can be specified for each column which customize the
     * memory usage and query availability of that column.  Note that some
     * properties are mutually exclusive--i.e. they cannot be specified for any
     * given column simultaneously.  One example of mutually exclusive
     * properties are {@code data} and {@code store_only}.
     * <p>
     * To set a *primary key* on one or more columns include the property
     * 'primary_key' on the desired column_names. If a primary key is
     * specified, then a uniqueness constraint is enforced, in that only a
     * single object can exist with a given primary key. When {@link
     * GPUdb#insertRecordsRaw(RawInsertRecordsRequest) inserting} data into a
     * table with a primary key, depending on the parameters in the request,
     * incoming objects with primary keys that match existing objects will
     * either overwrite (i.e. update) the existing object or will be skipped
     * and not added into the set.
     * <p>
     * Example of a type definition with some of the parameters::
     * <p>
     *         {"type":"record",
     *         "name":"point",
     *         "fields":[{"name":"msg_id","type":"string"},
     *                         {"name":"x","type":"double"},
     *                         {"name":"y","type":"double"},
     *                         {"name":"TIMESTAMP","type":"double"},
     *                         {"name":"source","type":"string"},
     *                         {"name":"group_id","type":"string"},
     *                         {"name":"OBJECT_ID","type":"string"}]
     *         }
     * <p>
     * Properties::
     * <p>
     *         {"group_id":["store_only"],
     *         "msg_id":["store_only","text_search"]
     *         }
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTypeResponse createType(CreateTypeRequest request) throws GPUdbException {
        CreateTypeResponse actualResponse_ = new CreateTypeResponse();
        submitRequest("/create/type", request, actualResponse_, false);
        setTypeDescriptorIfMissing(actualResponse_.getTypeId(), actualResponse_.getLabel(), actualResponse_.getTypeDefinition(), actualResponse_.getProperties());
        return actualResponse_;
    }



    /**
     * Creates a new type describing the layout or schema of a table. The type
     * definition is a JSON string describing the fields (i.e. columns) of the
     * type. Each field consists of a name and a data type. Supported data
     * types are: double, float, int, long, string, and bytes. In addition one
     * or more properties can be specified for each column which customize the
     * memory usage and query availability of that column.  Note that some
     * properties are mutually exclusive--i.e. they cannot be specified for any
     * given column simultaneously.  One example of mutually exclusive
     * properties are {@code data} and {@code store_only}.
     * <p>
     * To set a *primary key* on one or more columns include the property
     * 'primary_key' on the desired column_names. If a primary key is
     * specified, then a uniqueness constraint is enforced, in that only a
     * single object can exist with a given primary key. When {@link
     * GPUdb#insertRecordsRaw(RawInsertRecordsRequest) inserting} data into a
     * table with a primary key, depending on the parameters in the request,
     * incoming objects with primary keys that match existing objects will
     * either overwrite (i.e. update) the existing object or will be skipped
     * and not added into the set.
     * <p>
     * Example of a type definition with some of the parameters::
     * <p>
     *         {"type":"record",
     *         "name":"point",
     *         "fields":[{"name":"msg_id","type":"string"},
     *                         {"name":"x","type":"double"},
     *                         {"name":"y","type":"double"},
     *                         {"name":"TIMESTAMP","type":"double"},
     *                         {"name":"source","type":"string"},
     *                         {"name":"group_id","type":"string"},
     *                         {"name":"OBJECT_ID","type":"string"}]
     *         }
     * <p>
     * Properties::
     * <p>
     *         {"group_id":["store_only"],
     *         "msg_id":["store_only","text_search"]
     *         }
     * 
     * @param typeDefinition  a JSON string describing the columns of the type
     *                        to be registered.
     * @param label  A user-defined description string which can be used to
     *               differentiate between tables and types with otherwise
     *               identical schemas.
     * @param properties  Each key-value pair specifies the properties to use
     *                    for a given column where the key is the column name.
     *                    All keys used must be relevant column names for the
     *                    given table.  Specifying any property overrides the
     *                    default properties for that column (which is based on
     *                    the column's data type).
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateTypeResponse createType(String typeDefinition, String label, Map<String, List<String>> properties, Map<String, String> options) throws GPUdbException {
        CreateTypeRequest actualRequest_ = new CreateTypeRequest(typeDefinition, label, properties, options);
        CreateTypeResponse actualResponse_ = new CreateTypeResponse();
        submitRequest("/create/type", actualRequest_, actualResponse_, false);
        setTypeDescriptorIfMissing(actualResponse_.getTypeId(), actualResponse_.getLabel(), actualResponse_.getTypeDefinition(), actualResponse_.getProperties());
        return actualResponse_;
    }



    /**
     * Creates a table that is the concatenation of one or more existing
     * tables. It is equivalent to the SQL UNION ALL operator.  Non-charN
     * 'string' and 'bytes' column types cannot be included in a union, neither
     * can columns with the property 'store_only'.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateUnionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateUnionResponse createUnion(CreateUnionRequest request) throws GPUdbException {
        CreateUnionResponse actualResponse_ = new CreateUnionResponse();
        submitRequest("/create/union", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a table that is the concatenation of one or more existing
     * tables. It is equivalent to the SQL UNION ALL operator.  Non-charN
     * 'string' and 'bytes' column types cannot be included in a union, neither
     * can columns with the property 'store_only'.
     * 
     * @param tableName  Name of the table to be created. Has the same naming
     *                   restrictions as <a
     *                   href="../../../../concepts/tables.html"
     *                   target="_top">tables</a>.
     * @param tableNames  The list of table names making up the union. Must
     *                    contain the names of one or more existing tables.
     * @param inputColumnNames  The list of columns from each of the
     *                          corresponding input tables.
     * @param outputColumnNames  The list of names of the columns to be stored
     *                           in the union.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> collection_name: Name of a collection which
     *                 is to contain the union. If empty, then the union will
     *                 be a top-level table.
     *                         <li> materialize_on_gpu: If 'true' then the
     *                 columns of the union will be cached on the GPU. Values:
     *                 true, false.
     *                         <li> mode: If 'merge_views' then this operation
     *                 will merge (i.e. union) the provided views. All
     *                 'table_names' must be views from the same underlying
     *                 base table. Values: union_all, union, union_distinct,
     *                 except, intersect, merge_views.
     *                         <li> ttl: Sets the TTL of the table specified in
     *                 {@code tableName}. The value must be the desired TTL in
     *                 minutes.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateUnionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateUnionResponse createUnion(String tableName, List<String> tableNames, List<List<String>> inputColumnNames, List<String> outputColumnNames, Map<String, String> options) throws GPUdbException {
        CreateUnionRequest actualRequest_ = new CreateUnionRequest(tableName, tableNames, inputColumnNames, outputColumnNames, options);
        CreateUnionResponse actualResponse_ = new CreateUnionResponse();
        submitRequest("/create/union", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new external user (a user whose credentials are managed by an
     * external LDAP).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateUserExternalResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateUserExternalResponse createUserExternal(CreateUserExternalRequest request) throws GPUdbException {
        CreateUserExternalResponse actualResponse_ = new CreateUserExternalResponse();
        submitRequest("/create/user/external", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new external user (a user whose credentials are managed by an
     * external LDAP).
     * 
     * @param name  Name of the user to be created. Must exactly match the
     *              user's name in the external LDAP, prefixed with a @. Must
     *              not be the same name as an existing user.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateUserExternalResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateUserExternalResponse createUserExternal(String name, Map<String, String> options) throws GPUdbException {
        CreateUserExternalRequest actualRequest_ = new CreateUserExternalRequest(name, options);
        CreateUserExternalResponse actualResponse_ = new CreateUserExternalResponse();
        submitRequest("/create/user/external", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new internal user (a user whose credentials are managed by the
     * database system).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateUserInternalResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateUserInternalResponse createUserInternal(CreateUserInternalRequest request) throws GPUdbException {
        CreateUserInternalResponse actualResponse_ = new CreateUserInternalResponse();
        submitRequest("/create/user/internal", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates a new internal user (a user whose credentials are managed by the
     * database system).
     * 
     * @param name  Name of the user to be created. Must contain only lowercase
     *              letters, digits, and underscores, and cannot begin with a
     *              digit. Must not be the same name as an existing user or
     *              role.
     * @param password  Initial password of the user to be created. May be an
     *                  empty string for no password.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  CreateUserInternalResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public CreateUserInternalResponse createUserInternal(String name, String password, Map<String, String> options) throws GPUdbException {
        CreateUserInternalRequest actualRequest_ = new CreateUserInternalRequest(name, password, options);
        CreateUserInternalResponse actualResponse_ = new CreateUserInternalResponse();
        submitRequest("/create/user/internal", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes a proc. Any currently running instances of the proc will be
     * killed.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteProcResponse deleteProc(DeleteProcRequest request) throws GPUdbException {
        DeleteProcResponse actualResponse_ = new DeleteProcResponse();
        submitRequest("/delete/proc", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes a proc. Any currently running instances of the proc will be
     * killed.
     * 
     * @param procName  Name of the proc to be deleted. Must be the name of a
     *                  currently existing proc.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteProcResponse deleteProc(String procName, Map<String, String> options) throws GPUdbException {
        DeleteProcRequest actualRequest_ = new DeleteProcRequest(procName, options);
        DeleteProcResponse actualResponse_ = new DeleteProcResponse();
        submitRequest("/delete/proc", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes record(s) matching the provided criteria from the given table.
     * The record selection criteria can either be one or more  {@code
     * expressions} (matching multiple records) or a single record identified
     * by {@code record_id} options.  Note that the two selection criteria are
     * mutually exclusive.  This operation cannot be run on a collection or a
     * view.  The operation is synchronous meaning that a response will not be
     * available until the request is completely processed and all the matching
     * records are deleted.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteRecordsResponse deleteRecords(DeleteRecordsRequest request) throws GPUdbException {
        DeleteRecordsResponse actualResponse_ = new DeleteRecordsResponse();
        submitRequest("/delete/records", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes record(s) matching the provided criteria from the given table.
     * The record selection criteria can either be one or more  {@code
     * expressions} (matching multiple records) or a single record identified
     * by {@code record_id} options.  Note that the two selection criteria are
     * mutually exclusive.  This operation cannot be run on a collection or a
     * view.  The operation is synchronous meaning that a response will not be
     * available until the request is completely processed and all the matching
     * records are deleted.
     * 
     * @param tableName  Name of the table from which to delete records. The
     *                   set must be a currently existing table and not a
     *                   collection or a view.
     * @param expressions  A list of the actual predicates, one for each
     *                     select; format should follow the guidelines provided
     *                     {@link GPUdb#filter(String, String, String, Map)
     *                     here}. Specifying one or more {@code expressions} is
     *                     mutually exclusive to specifying {@code record_id}
     *                     in the {@code options}.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> global_expression: An optional global
     *                 expression to reduce the search space of the {@code
     *                 expressions}.
     *                         <li> record_id: A record id identifying a single
     *                 record, obtained at the time of {@link
     *                 GPUdb#insertRecordsRaw(RawInsertRecordsRequest)
     *                 insertion of the record} or by calling {@link
     *                 GPUdb#getRecordsFromCollectionRaw(GetRecordsFromCollectionRequest)}
     *                 with the *return_record_ids* option.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteRecordsResponse deleteRecords(String tableName, List<String> expressions, Map<String, String> options) throws GPUdbException {
        DeleteRecordsRequest actualRequest_ = new DeleteRecordsRequest(tableName, expressions, options);
        DeleteRecordsResponse actualResponse_ = new DeleteRecordsResponse();
        submitRequest("/delete/records", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes an existing role.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteRoleResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteRoleResponse deleteRole(DeleteRoleRequest request) throws GPUdbException {
        DeleteRoleResponse actualResponse_ = new DeleteRoleResponse();
        submitRequest("/delete/role", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes an existing role.
     * 
     * @param name  Name of the role to be deleted. Must be an existing role.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteRoleResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteRoleResponse deleteRole(String name, Map<String, String> options) throws GPUdbException {
        DeleteRoleRequest actualRequest_ = new DeleteRoleRequest(name, options);
        DeleteRoleResponse actualResponse_ = new DeleteRoleResponse();
        submitRequest("/delete/role", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes an existing user.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteUserResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteUserResponse deleteUser(DeleteUserRequest request) throws GPUdbException {
        DeleteUserResponse actualResponse_ = new DeleteUserResponse();
        submitRequest("/delete/user", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Deletes an existing user.
     * 
     * @param name  Name of the user to be deleted. Must be an existing user.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  DeleteUserResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public DeleteUserResponse deleteUser(String name, Map<String, String> options) throws GPUdbException {
        DeleteUserRequest actualRequest_ = new DeleteUserRequest(name, options);
        DeleteUserResponse actualResponse_ = new DeleteUserResponse();
        submitRequest("/delete/user", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Executes a proc. This endpoint is asynchronous and does not wait for the
     * proc to complete before returning.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ExecuteProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ExecuteProcResponse executeProc(ExecuteProcRequest request) throws GPUdbException {
        ExecuteProcResponse actualResponse_ = new ExecuteProcResponse();
        submitRequest("/execute/proc", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Executes a proc. This endpoint is asynchronous and does not wait for the
     * proc to complete before returning.
     * 
     * @param procName  Name of the proc to execute. Must be the name of a
     *                  currently existing proc.
     * @param params  A map containing named parameters to pass to the proc.
     *                Each key/value pair specifies the name of a parameter and
     *                its value.
     * @param binParams  A map containing named binary parameters to pass to
     *                   the proc. Each key/value pair specifies the name of a
     *                   parameter and its value.
     * @param inputTableNames  Names of the tables containing data to be passed
     *                         to the proc. Each name specified must be the
     *                         name of a currently existing table. If no table
     *                         names are specified, no data will be passed to
     *                         the proc.
     * @param inputColumnNames  Map of table names from {@code inputTableNames}
     *                          to lists of names of columns from those tables
     *                          that will be passed to the proc. Each column
     *                          name specified must be the name of an existing
     *                          column in the corresponding table. If a table
     *                          name from {@code inputTableNames} is not
     *                          included, all columns from that table will be
     *                          passed to the proc.
     * @param outputTableNames  Names of the tables to which output data from
     *                          the proc will be written. If a specified table
     *                          does not exist, it will automatically be
     *                          created with the same schema as the
     *                          corresponding table (by order) from {@code
     *                          inputTableNames}, excluding any primary and
     *                          shard keys. If no table names are specified, no
     *                          output data can be returned from the proc.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> cache_input: A comma-delimited list of
     *                 table names from {@code inputTableNames} from which
     *                 input data will be cached for use in subsequent calls to
     *                 {@link GPUdb#executeProc(String, Map, Map, List, Map,
     *                 List, Map)} with the {@code use_cached_input} option.
     *                 Cached input data will be retained until the proc status
     *                 is cleared with the {@link GPUdb#showProcStatus(String,
     *                 Map) clear_complete} option of {@link
     *                 GPUdb#showProcStatus(String, Map)} and all proc
     *                 instances using the cached data have completed.
     *                         <li> use_cached_input: A comma-delimited list of
     *                 run IDs (as returned from prior calls to {@link
     *                 GPUdb#executeProc(String, Map, Map, List, Map, List,
     *                 Map)}) of running or completed proc instances from which
     *                 input data cached using the {@code cache_input} option
     *                 will be used. Cached input data will not be used for any
     *                 tables specified in {@code inputTableNames}, but data
     *                 from all other tables cached for the specified run IDs
     *                 will be passed to the proc. If the same table was cached
     *                 for multiple specified run IDs, the cached data from the
     *                 first run ID specified in the list that includes that
     *                 table will be used.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ExecuteProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ExecuteProcResponse executeProc(String procName, Map<String, String> params, Map<String, ByteBuffer> binParams, List<String> inputTableNames, Map<String, List<String>> inputColumnNames, List<String> outputTableNames, Map<String, String> options) throws GPUdbException {
        ExecuteProcRequest actualRequest_ = new ExecuteProcRequest(procName, params, binParams, inputTableNames, inputColumnNames, outputTableNames, options);
        ExecuteProcResponse actualResponse_ = new ExecuteProcResponse();
        submitRequest("/execute/proc", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters data based on the specified expression.  The results are stored
     * in a result set with the given {@code viewName}.
     * <p>
     * For details see <a href="../../../../concepts/expressions.html"
     * target="_top">concepts</a>.
     * <p>
     * The response message contains the number of points for which the
     * expression evaluated to be true, which is equivalent to the size of the
     * result view.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterResponse filter(FilterRequest request) throws GPUdbException {
        FilterResponse actualResponse_ = new FilterResponse();
        submitRequest("/filter", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters data based on the specified expression.  The results are stored
     * in a result set with the given {@code viewName}.
     * <p>
     * For details see <a href="../../../../concepts/expressions.html"
     * target="_top">concepts</a>.
     * <p>
     * The response message contains the number of points for which the
     * expression evaluated to be true, which is equivalent to the size of the
     * result view.
     * 
     * @param tableName  Name of the table to filter.  This may be the ID of a
     *                   collection, table or a result set (for chaining
     *                   queries).  Collections may be filtered only if all
     *                   tables within the collection have the same type ID.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param expression  The select expression to filter the specified table.
     *                    For details see <a
     *                    href="../../../../concepts/expressions.html"
     *                    target="_top">concepts</a>.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> collection_name: Name of a collection which
     *                 is to contain the newly created view, otherwise the view
     *                 will be a top-level table. If the collection does not
     *                 allow duplicate types and it contains a table of the
     *                 same type as the given one, then this table creation
     *                 request will fail.
     *                         <li> ttl: Sets the TTL of the view specified in
     *                 {@code viewName}. The value must be the desired TTL in
     *                 minutes.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterResponse filter(String tableName, String viewName, String expression, Map<String, String> options) throws GPUdbException {
        FilterRequest actualRequest_ = new FilterRequest(tableName, viewName, expression, options);
        FilterResponse actualResponse_ = new FilterResponse();
        submitRequest("/filter", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table are within a named area of
     * interest (NAI/polygon). The operation is synchronous, meaning that a
     * response will not be returned until all the matching objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new resultant set (view) which satisfies the input NAI restriction
     * specification is created with the name {@code viewName} passed in as
     * part of the input.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByAreaResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByAreaResponse filterByArea(FilterByAreaRequest request) throws GPUdbException {
        FilterByAreaResponse actualResponse_ = new FilterByAreaResponse();
        submitRequest("/filter/byarea", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table are within a named area of
     * interest (NAI/polygon). The operation is synchronous, meaning that a
     * response will not be returned until all the matching objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new resultant set (view) which satisfies the input NAI restriction
     * specification is created with the name {@code viewName} passed in as
     * part of the input.
     * 
     * @param tableName  Name of the table to filter.  This may be the name of
     *                   a collection, a table or a view (when chaining
     *                   queries).  Collections may be filtered only if all
     *                   tables within the collection have the same type ID.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param xColumnName  Name of the column containing the x values to be
     *                     filtered.
     * @param xVector  List of x coordinates of the vertices of the polygon
     *                 representing the area to be filtered.
     * @param yColumnName  Name of the column containing the y values to be
     *                     filtered.
     * @param yVector  List of y coordinates of the vertices of the polygon
     *                 representing the area to be filtered.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByAreaResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByAreaResponse filterByArea(String tableName, String viewName, String xColumnName, List<Double> xVector, String yColumnName, List<Double> yVector, Map<String, String> options) throws GPUdbException {
        FilterByAreaRequest actualRequest_ = new FilterByAreaRequest(tableName, viewName, xColumnName, xVector, yColumnName, yVector, options);
        FilterByAreaResponse actualResponse_ = new FilterByAreaResponse();
        submitRequest("/filter/byarea", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates how many objects within the given table lie in a rectangular
     * box. The operation is synchronous, meaning that a response will not be
     * returned until all the objects are fully available. The response payload
     * provides the count of the resulting set. A new resultant set which
     * satisfies the input NAI restriction specification is also created when a
     * {@code viewName} is passed in as part of the input payload.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByBoxResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByBoxResponse filterByBox(FilterByBoxRequest request) throws GPUdbException {
        FilterByBoxResponse actualResponse_ = new FilterByBoxResponse();
        submitRequest("/filter/bybox", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates how many objects within the given table lie in a rectangular
     * box. The operation is synchronous, meaning that a response will not be
     * returned until all the objects are fully available. The response payload
     * provides the count of the resulting set. A new resultant set which
     * satisfies the input NAI restriction specification is also created when a
     * {@code viewName} is passed in as part of the input payload.
     * 
     * @param tableName  Name of the table on which the bounding box operation
     *                   will be performed. Must be an existing table.
     * @param viewName  Optional name of the result view that will be created
     *                  containing the results of the query. Has the same
     *                  naming restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param xColumnName  Name of the column on which to perform the bounding
     *                     box query. If the table's data type is not a shape
     *                     type, must be a valid numeric column.
     * @param minX  Lower bound for the column chosen by {@code xColumnName}.
     *              Must be less than or equal to {@code maxX}.
     * @param maxX  Upper bound for {@code xColumnName}.  Must be greater than
     *              or equal to {@code minX}.
     * @param yColumnName  Name of a column on which to perform the bounding
     *                     box query. If the table's data type is not a shape
     *                     type, must be a valid numeric column.
     * @param minY  Lower bound for {@code yColumnName}. Must be less than or
     *              equal to {@code maxY}.
     * @param maxY  Upper bound for {@code yColumnName}. Must be greater than
     *              or equal to {@code minY}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByBoxResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByBoxResponse filterByBox(String tableName, String viewName, String xColumnName, double minX, double maxX, String yColumnName, double minY, double maxY, Map<String, String> options) throws GPUdbException {
        FilterByBoxRequest actualRequest_ = new FilterByBoxRequest(tableName, viewName, xColumnName, minX, maxX, yColumnName, minY, maxY, options);
        FilterByBoxResponse actualResponse_ = new FilterByBoxResponse();
        submitRequest("/filter/bybox", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Applies a geometry filter against a spatial column named WKT in a given
     * table, collection or view. The filtering geometry is provided by {@code
     * inputWkt}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByGeometryResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByGeometryResponse filterByGeometry(FilterByGeometryRequest request) throws GPUdbException {
        FilterByGeometryResponse actualResponse_ = new FilterByGeometryResponse();
        submitRequest("/filter/bygeometry", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Applies a geometry filter against a spatial column named WKT in a given
     * table, collection or view. The filtering geometry is provided by {@code
     * inputWkt}.
     * 
     * @param tableName  Name of the table on which the filter by geometry will
     *                   be performed.  Must be an existing table, collection
     *                   or view containing a column named WKT.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param columnName  Name of the column to be used in the filter. Must be
     *                    'WKT'
     * @param inputWkt  A geometry in WKT format that will be used to filter
     *                  the objects in {@code tableName}.
     * @param operation  The geometric filtering operation to perform Values:
     *                   contains, crosses, disjoint, equals, intersects,
     *                   overlaps, touches, within.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByGeometryResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByGeometryResponse filterByGeometry(String tableName, String viewName, String columnName, String inputWkt, String operation, Map<String, String> options) throws GPUdbException {
        FilterByGeometryRequest actualRequest_ = new FilterByGeometryRequest(tableName, viewName, columnName, inputWkt, operation, options);
        FilterByGeometryResponse actualResponse_ = new FilterByGeometryResponse();
        submitRequest("/filter/bygeometry", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which records from a table have values in the given list for
     * the corresponding column. The operation is synchronous, meaning that a
     * response will not be returned until all the objects are fully available.
     * The response payload provides the count of the resulting set. A new
     * resultant set (view) which satisfies the input filter specification is
     * also created if a {@code viewName} is passed in as part of the request.
     * <p>
     * For example, if a type definition has the columns 'x' and 'y', then a
     * filter by list query with the column map {"x":["10.1", "2.3"],
     * "y":["0.0", "-31.5", "42.0"]} will return the count of all data points
     * whose x and y values match one of the values in the respective x- and
     * y-lists. If the filter_mode option is set to 'not_in_list' then the
     * filter will match all items that are not in the provided list(s).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByListResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByListResponse filterByList(FilterByListRequest request) throws GPUdbException {
        FilterByListResponse actualResponse_ = new FilterByListResponse();
        submitRequest("/filter/bylist", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which records from a table have values in the given list for
     * the corresponding column. The operation is synchronous, meaning that a
     * response will not be returned until all the objects are fully available.
     * The response payload provides the count of the resulting set. A new
     * resultant set (view) which satisfies the input filter specification is
     * also created if a {@code viewName} is passed in as part of the request.
     * <p>
     * For example, if a type definition has the columns 'x' and 'y', then a
     * filter by list query with the column map {"x":["10.1", "2.3"],
     * "y":["0.0", "-31.5", "42.0"]} will return the count of all data points
     * whose x and y values match one of the values in the respective x- and
     * y-lists. If the filter_mode option is set to 'not_in_list' then the
     * filter will match all items that are not in the provided list(s).
     * 
     * @param tableName  Name of the table to filter.  This may be the ID of a
     *                   collection, table or a result set (for chaining
     *                   queries).  Collections may be filtered only if all
     *                   tables within the collection have the same type ID.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param columnValuesMap  List of values for the corresponding column in
     *                         the table
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> filter_mode: String indicating the filter
     *                 mode, either 'in_list' or 'not_in_list'. Values:
     *                 in_list, not_in_list.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByListResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByListResponse filterByList(String tableName, String viewName, Map<String, List<String>> columnValuesMap, Map<String, String> options) throws GPUdbException {
        FilterByListRequest actualRequest_ = new FilterByListRequest(tableName, viewName, columnValuesMap, options);
        FilterByListResponse actualResponse_ = new FilterByListResponse();
        submitRequest("/filter/bylist", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table lie within a circle with the given
     * radius and center point (i.e. circular NAI). The operation is
     * synchronous, meaning that a response will not be returned until all the
     * objects are fully available. The response payload provides the count of
     * the resulting set. A new resultant set (view) which satisfies the input
     * circular NAI restriction specification is also created if a {@code
     * viewName} is passed in as part of the request.
     * <p>
     * For track data, all track points that lie within the circle plus one
     * point on either side of the circle (if the track goes beyond the circle)
     * will be included in the result. For shapes, e.g. polygons, all polygons
     * that intersect the circle will be included (even if none of the points
     * of the polygon fall within the circle).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByRadiusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByRadiusResponse filterByRadius(FilterByRadiusRequest request) throws GPUdbException {
        FilterByRadiusResponse actualResponse_ = new FilterByRadiusResponse();
        submitRequest("/filter/byradius", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table lie within a circle with the given
     * radius and center point (i.e. circular NAI). The operation is
     * synchronous, meaning that a response will not be returned until all the
     * objects are fully available. The response payload provides the count of
     * the resulting set. A new resultant set (view) which satisfies the input
     * circular NAI restriction specification is also created if a {@code
     * viewName} is passed in as part of the request.
     * <p>
     * For track data, all track points that lie within the circle plus one
     * point on either side of the circle (if the track goes beyond the circle)
     * will be included in the result. For shapes, e.g. polygons, all polygons
     * that intersect the circle will be included (even if none of the points
     * of the polygon fall within the circle).
     * 
     * @param tableName  Name of the table on which the filter by radius
     *                   operation will be performed.  Must be an existing
     *                   table.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param xColumnName  Name of the column to be used for the x-coordinate
     *                     (the longitude) of the center.
     * @param xCenter  Value of the longitude of the center. Must be within
     *                 [-180.0, 180.0].  The minimum allowed value is -180. The
     *                 maximum allowed value is 180.
     * @param yColumnName  Name of the column to be used for the
     *                     y-coordinate-the latitude-of the center.
     * @param yCenter  Value of the latitude of the center. Must be within
     *                 [-90.0, 90.0].  The minimum allowed value is -90. The
     *                 maximum allowed value is 90.
     * @param radius  The radius of the circle within which the search will be
     *                performed. Must be a non-zero positive value. It is in
     *                meters; so, for example, a value of '42000' means 42 km.
     *                The minimum allowed value is 0. The maximum allowed value
     *                is MAX_INT.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByRadiusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByRadiusResponse filterByRadius(String tableName, String viewName, String xColumnName, double xCenter, String yColumnName, double yCenter, double radius, Map<String, String> options) throws GPUdbException {
        FilterByRadiusRequest actualRequest_ = new FilterByRadiusRequest(tableName, viewName, xColumnName, xCenter, yColumnName, yCenter, radius, options);
        FilterByRadiusResponse actualResponse_ = new FilterByRadiusResponse();
        submitRequest("/filter/byradius", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table have a column that is within the
     * given bounds. An object from the table identified by {@code tableName}
     * is added to the view {@code viewName} if its column is within [{@code
     * lowerBound}, {@code upperBound}] (inclusive). The operation is
     * synchronous. The response provides a count of the number of objects
     * which passed the bound filter.  Although this functionality can also be
     * accomplished with the standard filter function, it is more efficient.
     * <p>
     * For track objects, the count reflects how many points fall within the
     * given bounds (which may not include all the track points of any given
     * track).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByRangeResponse filterByRange(FilterByRangeRequest request) throws GPUdbException {
        FilterByRangeResponse actualResponse_ = new FilterByRangeResponse();
        submitRequest("/filter/byrange", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table have a column that is within the
     * given bounds. An object from the table identified by {@code tableName}
     * is added to the view {@code viewName} if its column is within [{@code
     * lowerBound}, {@code upperBound}] (inclusive). The operation is
     * synchronous. The response provides a count of the number of objects
     * which passed the bound filter.  Although this functionality can also be
     * accomplished with the standard filter function, it is more efficient.
     * <p>
     * For track objects, the count reflects how many points fall within the
     * given bounds (which may not include all the track points of any given
     * track).
     * 
     * @param tableName  Name of the table on which the filter by range
     *                   operation will be performed.  Must be an existing
     *                   table.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param columnName  Name of a column on which the operation would be
     *                    applied.
     * @param lowerBound  Value of the lower bound (inclusive).
     * @param upperBound  Value of the upper bound (inclusive).
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByRangeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByRangeResponse filterByRange(String tableName, String viewName, String columnName, double lowerBound, double upperBound, Map<String, String> options) throws GPUdbException {
        FilterByRangeRequest actualRequest_ = new FilterByRangeRequest(tableName, viewName, columnName, lowerBound, upperBound, options);
        FilterByRangeResponse actualResponse_ = new FilterByRangeResponse();
        submitRequest("/filter/byrange", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters objects matching all points of the given track (works only on
     * track type data).  It allows users to specify a particular track to find
     * all other points in the table that fall within specified ranges-spatial
     * and temporal-of all points of the given track. Additionally, the user
     * can specify another track to see if the two intersect (or go close to
     * each other within the specified ranges). The user also has the
     * flexibility of using different metrics for the spatial distance
     * calculation: Euclidean (flat geometry) or Great Circle (spherical
     * geometry to approximate the Earth's surface distances). The filtered
     * points are stored in a newly created result set. The return value of the
     * function is the number of points in the resultant set (view).
     * <p>
     * This operation is synchronous, meaning that a response will not be
     * returned until all the objects are fully available.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterBySeriesResponse filterBySeries(FilterBySeriesRequest request) throws GPUdbException {
        FilterBySeriesResponse actualResponse_ = new FilterBySeriesResponse();
        submitRequest("/filter/byseries", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters objects matching all points of the given track (works only on
     * track type data).  It allows users to specify a particular track to find
     * all other points in the table that fall within specified ranges-spatial
     * and temporal-of all points of the given track. Additionally, the user
     * can specify another track to see if the two intersect (or go close to
     * each other within the specified ranges). The user also has the
     * flexibility of using different metrics for the spatial distance
     * calculation: Euclidean (flat geometry) or Great Circle (spherical
     * geometry to approximate the Earth's surface distances). The filtered
     * points are stored in a newly created result set. The return value of the
     * function is the number of points in the resultant set (view).
     * <p>
     * This operation is synchronous, meaning that a response will not be
     * returned until all the objects are fully available.
     * 
     * @param tableName  Name of the table on which the filter by track
     *                   operation will be performed. Must be a currently
     *                   existing table with track semantic type.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param trackId  The ID of the track which will act as the filtering
     *                 points. Must be an existing track within the given
     *                 table.
     * @param targetTrackIds  Up to one track ID to intersect with the "filter"
     *                        track. If any provided, it must be an valid track
     *                        ID within the given set.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> spatial_radius: A positive number passed as
     *                 a string representing the radius of the search area
     *                 centered around each track point's geospatial
     *                 coordinates. The value is interpreted in meters.
     *                 Required parameter.
     *                         <li> time_radius: A positive number passed as a
     *                 string representing the maximum allowable time
     *                 difference between the timestamps of a filtered object
     *                 and the given track's points. The value is interpreted
     *                 in seconds. Required parameter.
     *                         <li> spatial_distance_metric: A string
     *                 representing the coordinate system to use for the
     *                 spatial search criteria. Acceptable values are
     *                 'euclidean' and 'great_circle'. Optional parameter;
     *                 default is 'euclidean'. Values: euclidean, great_circle.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterBySeriesResponse filterBySeries(String tableName, String viewName, String trackId, List<String> targetTrackIds, Map<String, String> options) throws GPUdbException {
        FilterBySeriesRequest actualRequest_ = new FilterBySeriesRequest(tableName, viewName, trackId, targetTrackIds, options);
        FilterBySeriesResponse actualResponse_ = new FilterBySeriesResponse();
        submitRequest("/filter/byseries", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table, collection, or view match a
     * string expression for the given string columns. The 'mode' may be:

     * * search : full text search query with wildcards and boolean operators,
     * e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no column
     * can be specified in {@code columnNames}; all string columns of the table
     * that have text search enabled will be searched. Also, the first
     * character of a search term cannot be a wildcard (* or ?), and search
     * terms cannot be any of the following:  "a", "an", "and", "are", "as",
     * "at", "be", "but", "by", "for", "if", "in", "into", "is", "it", "no",
     * "not", "of", "on", "or", "such", "that", "the", "their", "then",
     * "there", "these", "they", "this", "to", "was", "will", "with".
     *     Search query types:
     *         * Multiple search terms
     *             ex. perfect union - will match any record containing
     * "perfect", "union", or both.
     *         * Exact phrases
     *             ex. "Perfect Union" - will only match the exact phrase
     * "Perfect Union"
     *         * Boolean (NOT, AND, OR, parentheses. OR assumed if no operator
     * specified)
     *             ex. justice AND tranquility - will match only those records
     * containing both justice and tranquility
     *         * Zero or more char wildcard - (specified with '*')
     *             ex, est*is* - will match any records containing a word that
     * starts with "est" and ends with "sh", such as "establish",
     * "establishable", and "establishment"
     *         * Exactly one char wildcard - (specified with ?)
     *             ex. est???is* - will only match strings that start with
     * "est", followed by exactly three letters, followed by "is", followed by
     * one more letter.  This would only match "establish"
     *         * Fuzzy search (term~)
     *             ex. rear~ will match rear,fear,bear,read,etc.
     *         * Proximity - match two words within a specified distance of
     * eachother
     *             ex. "Union Tranquility"~10 will match any record that has
     * the words Union and Tranquility within 10 words of eachother
     *         * Range - inclusive [<term1> TO <term2>] and exclusive {<term1>
     * TO <term2>}.  Note: This is a string search, so numbers will be seen as
     * a string of numeric characters, not as a number.  Ex. 2 > 123
     *             ex. [100 TO 200] will find all strings between 100 and 200
     * inclusive.
     *             ex. {alpha to beta} will find all strings between alpha and
     * beta, but not the words alpha or beta
     *         * escaping special characters - Special characters are escaped
     * with a backslash(\), special characters are: + - && || ! ( ) { } [ ] ^ "
     * ~ * ? : \
     * <p>
     * * equals: exact whole-string match (accelerated)
     * * contains: partial substring match (not accelerated).  If the column is
     * a string type (non-charN) and the number of records is too large, it
     * will return 0.
     * * starts_with: strings that start with the given expression (not
     * accelerated), If the column is a string type (non-charN) and the number
     * of records is too large, it will return 0.
     * * regex: full regular expression search (not accelerated). If the column
     * is a string type (non-charN) and the number of records is too large, it
     * will return 0.
     * <p>
     * The options 'case_sensitive' can be used to modify the behavior for all
     * modes except 'search'
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByStringResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByStringResponse filterByString(FilterByStringRequest request) throws GPUdbException {
        FilterByStringResponse actualResponse_ = new FilterByStringResponse();
        submitRequest("/filter/bystring", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table, collection, or view match a
     * string expression for the given string columns. The 'mode' may be:

     * * search : full text search query with wildcards and boolean operators,
     * e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no column
     * can be specified in {@code columnNames}; all string columns of the table
     * that have text search enabled will be searched. Also, the first
     * character of a search term cannot be a wildcard (* or ?), and search
     * terms cannot be any of the following:  "a", "an", "and", "are", "as",
     * "at", "be", "but", "by", "for", "if", "in", "into", "is", "it", "no",
     * "not", "of", "on", "or", "such", "that", "the", "their", "then",
     * "there", "these", "they", "this", "to", "was", "will", "with".
     *     Search query types:
     *         * Multiple search terms
     *             ex. perfect union - will match any record containing
     * "perfect", "union", or both.
     *         * Exact phrases
     *             ex. "Perfect Union" - will only match the exact phrase
     * "Perfect Union"
     *         * Boolean (NOT, AND, OR, parentheses. OR assumed if no operator
     * specified)
     *             ex. justice AND tranquility - will match only those records
     * containing both justice and tranquility
     *         * Zero or more char wildcard - (specified with '*')
     *             ex, est*is* - will match any records containing a word that
     * starts with "est" and ends with "sh", such as "establish",
     * "establishable", and "establishment"
     *         * Exactly one char wildcard - (specified with ?)
     *             ex. est???is* - will only match strings that start with
     * "est", followed by exactly three letters, followed by "is", followed by
     * one more letter.  This would only match "establish"
     *         * Fuzzy search (term~)
     *             ex. rear~ will match rear,fear,bear,read,etc.
     *         * Proximity - match two words within a specified distance of
     * eachother
     *             ex. "Union Tranquility"~10 will match any record that has
     * the words Union and Tranquility within 10 words of eachother
     *         * Range - inclusive [<term1> TO <term2>] and exclusive {<term1>
     * TO <term2>}.  Note: This is a string search, so numbers will be seen as
     * a string of numeric characters, not as a number.  Ex. 2 > 123
     *             ex. [100 TO 200] will find all strings between 100 and 200
     * inclusive.
     *             ex. {alpha to beta} will find all strings between alpha and
     * beta, but not the words alpha or beta
     *         * escaping special characters - Special characters are escaped
     * with a backslash(\), special characters are: + - && || ! ( ) { } [ ] ^ "
     * ~ * ? : \
     * <p>
     * * equals: exact whole-string match (accelerated)
     * * contains: partial substring match (not accelerated).  If the column is
     * a string type (non-charN) and the number of records is too large, it
     * will return 0.
     * * starts_with: strings that start with the given expression (not
     * accelerated), If the column is a string type (non-charN) and the number
     * of records is too large, it will return 0.
     * * regex: full regular expression search (not accelerated). If the column
     * is a string type (non-charN) and the number of records is too large, it
     * will return 0.
     * <p>
     * The options 'case_sensitive' can be used to modify the behavior for all
     * modes except 'search'
     * 
     * @param tableName  Name of the table on which the filter operation will
     *                   be performed.  Must be an existing table, collection
     *                   or view.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param expression  The expression with which to filter the table.
     * @param mode  The string filtering mode to apply. See above for details.
     *              Values: search, equals, contains, starts_with, regex.
     * @param columnNames  List of columns on which to apply the filter.
     *                     Ignored for 'search' mode.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> case_sensitive: If 'false' then string
     *                 filtering will ignore case. Does not apply to 'search'
     *                 mode. Values: true, false.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByStringResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByStringResponse filterByString(String tableName, String viewName, String expression, String mode, List<String> columnNames, Map<String, String> options) throws GPUdbException {
        FilterByStringRequest actualRequest_ = new FilterByStringRequest(tableName, viewName, expression, mode, columnNames, options);
        FilterByStringResponse actualResponse_ = new FilterByStringResponse();
        submitRequest("/filter/bystring", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters objects in one table based on objects in another table. The user
     * must specify matching column types from the two tables (i.e. the target
     * table from which objects will be filtered and the source table based on
     * which the filter will be created); the column names need not be the
     * same. If a {@code viewName} is specified, then the filtered objects will
     * then be put in a newly created view. The operation is synchronous,
     * meaning that a response will not be returned until all objects are fully
     * available in the result view. The return value contains the count (i.e.
     * the size) of the resulting view.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByTableResponse filterByTable(FilterByTableRequest request) throws GPUdbException {
        FilterByTableResponse actualResponse_ = new FilterByTableResponse();
        submitRequest("/filter/bytable", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Filters objects in one table based on objects in another table. The user
     * must specify matching column types from the two tables (i.e. the target
     * table from which objects will be filtered and the source table based on
     * which the filter will be created); the column names need not be the
     * same. If a {@code viewName} is specified, then the filtered objects will
     * then be put in a newly created view. The operation is synchronous,
     * meaning that a response will not be returned until all objects are fully
     * available in the result view. The return value contains the count (i.e.
     * the size) of the resulting view.
     * 
     * @param tableName  Name of the table whose data will be filtered. Must be
     *                   an existing table.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param columnName  Name of the column by whose value the data will be
     *                    filtered from the table designated by {@code
     *                    tableName}.
     * @param sourceTableName  Name of the table whose data will be compared
     *                         against in the table called {@code tableName}.
     *                         Must be an existing table.
     * @param sourceTableColumnName  Name of the column in the {@code
     *                               sourceTableName} whose values will be used
     *                               as the filter for table {@code tableName}.
     *                               Must match the type of the {@code
     *                               columnName}.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> filter_mode: String indicating the filter
     *                 mode, either {@code in_table} or {@code not_in_table}.
     *                 Values: in_table, not_in_table.
     *                         <li> mode: Mode - should be either {@code
     *                 spatial} or {@code normal}. Values: normal, spatial.
     *                         <li> buffer: Buffer size, in meters. Only
     *                 relevant for {@code spatial} mode.
     *                         <li> buffer_method: Method used to buffer
     *                 polygons.  Only relevant for {@code spatial} mode.
     *                 Values: normal, geos.
     *                         <li> max_partition_size: Maximum number of
     *                 points in a partition. Only relevant for {@code spatial}
     *                 mode.
     *                         <li> max_partition_score: Maximum number of
     *                 points * edges in a partition. Only relevant for {@code
     *                 spatial} mode.
     *                         <li> x_column_name: Name of column containing x
     *                 value of point being filtered in {@code spatial} mode.
     *                         <li> y_column_name: Name of column containing y
     *                 value of point being filtered in {@code spatial} mode.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByTableResponse filterByTable(String tableName, String viewName, String columnName, String sourceTableName, String sourceTableColumnName, Map<String, String> options) throws GPUdbException {
        FilterByTableRequest actualRequest_ = new FilterByTableRequest(tableName, viewName, columnName, sourceTableName, sourceTableColumnName, options);
        FilterByTableResponse actualResponse_ = new FilterByTableResponse();
        submitRequest("/filter/bytable", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table has a particular value for a
     * particular column. The input parameters provide a way to specify either
     * a String or a Double valued column and a desired value for the column on
     * which the filter is performed. The operation is synchronous, meaning
     * that a response will not be returned until all the objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new result view which satisfies the input filter restriction
     * specification is also created with a view name passed in as part of the
     * input payload.  Although this functionality can also be accomplished
     * with the standard filter function, it is more efficient.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByValueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByValueResponse filterByValue(FilterByValueRequest request) throws GPUdbException {
        FilterByValueResponse actualResponse_ = new FilterByValueResponse();
        submitRequest("/filter/byvalue", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Calculates which objects from a table has a particular value for a
     * particular column. The input parameters provide a way to specify either
     * a String or a Double valued column and a desired value for the column on
     * which the filter is performed. The operation is synchronous, meaning
     * that a response will not be returned until all the objects are fully
     * available. The response payload provides the count of the resulting set.
     * A new result view which satisfies the input filter restriction
     * specification is also created with a view name passed in as part of the
     * input payload.  Although this functionality can also be accomplished
     * with the standard filter function, it is more efficient.
     * 
     * @param tableName  Name of an existing table on which to perform the
     *                   calculation.
     * @param viewName  If provided, then this will be the name of the view
     *                  containing the results. Has the same naming
     *                  restrictions as <a
     *                  href="../../../../concepts/tables.html"
     *                  target="_top">tables</a>.
     * @param isString  Indicates whether the value being searched for is
     *                  string or numeric.
     * @param value  The value to search for.
     * @param valueStr  The string value to search for.
     * @param columnName  Name of a column on which the filter by value would
     *                    be applied.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  FilterByValueResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public FilterByValueResponse filterByValue(String tableName, String viewName, boolean isString, double value, String valueStr, String columnName, Map<String, String> options) throws GPUdbException {
        FilterByValueRequest actualRequest_ = new FilterByValueRequest(tableName, viewName, isString, value, valueStr, columnName, options);
        FilterByValueResponse actualResponse_ = new FilterByValueResponse();
        submitRequest("/filter/byvalue", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can be performed on
     * tables, views, or on homogeneous collections (collections containing
     * tables of all the same type). Records can be returned encoded as binary
     * or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawGetRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawGetRecordsResponse getRecordsRaw(GetRecordsRequest request) throws GPUdbException {
        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can be performed on
     * tables, views, or on homogeneous collections (collections containing
     * tables of all the same type). Records can be returned encoded as binary
     * or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsResponse<TResponse> getRecords(Object typeDescriptor, GetRecordsRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", request, actualResponse_, false);
        GetRecordsResponse<TResponse> response_ = new GetRecordsResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeName(actualResponse_.getTypeName());
        response_.setTypeSchema(actualResponse_.getTypeSchema());
        response_.setData(this.<TResponse>decode(typeDescriptor, actualResponse_.getRecordsBinary()));
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can be performed on
     * tables, views, or on homogeneous collections (collections containing
     * tables of all the same type). Records can be returned encoded as binary
     * or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param tableName  Name of the table from which the records will be
     *                   fetched. Must be a table, view or homogeneous
     *                   collection.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned. Or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options
     *                 <ul>
     *                         <li> expression: Optional filter expression to
     *                 apply to the table.
     *                         <li> fast_index_lookup: Indicates if indexes
     *                 should be used to perform the lookup for a given
     *                 expression if possible. Only applicable if there is no
     *                 sorting, the expression contains only equivalence
     *                 comparisons based on existing tables indexes and the
     *                 range of requested values is from [0 to END_OF_SET]. The
     *                 default value is true.
     *                         <li> sort_by: Optional column that the data
     *                 should be sorted by. Empty by default (i.e. no sorting
     *                 is applied).
     *                         <li> sort_order: String indicating how the
     *                 returned values should be sorted - ascending or
     *                 descending. If sort_order is provided, sort_by has to be
     *                 provided. Values: ascending, descending.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsResponse<TResponse> getRecords(Object typeDescriptor, String tableName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsRequest actualRequest_ = new GetRecordsRequest(tableName, offset, limit, null, options);
        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", actualRequest_, actualResponse_, false);
        GetRecordsResponse<TResponse> response_ = new GetRecordsResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeName(actualResponse_.getTypeName());
        response_.setTypeSchema(actualResponse_.getTypeSchema());
        response_.setData(this.<TResponse>decode(typeDescriptor, actualResponse_.getRecordsBinary()));
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can be performed on
     * tables, views, or on homogeneous collections (collections containing
     * tables of all the same type). Records can be returned encoded as binary
     * or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsResponse<TResponse> getRecords(GetRecordsRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", request, actualResponse_, false);
        GetRecordsResponse<TResponse> response_ = new GetRecordsResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeName(actualResponse_.getTypeName());
        response_.setTypeSchema(actualResponse_.getTypeSchema());
        response_.setData(this.<TResponse>decode(actualResponse_.getTypeName(), actualResponse_.getRecordsBinary()));
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Retrieves records from a given table, optionally filtered by an
     * expression and/or sorted by a column. This operation can be performed on
     * tables, views, or on homogeneous collections (collections containing
     * tables of all the same type). Records can be returned encoded as binary
     * or json.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters. Note that when paging through a table, if
     * the table (or the underlying table in case of a view) is updated
     * (records are inserted, deleted or modified) the records retrieved may
     * differ between calls based on the updates applied.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param tableName  Name of the table from which the records will be
     *                   fetched. Must be a table, view or homogeneous
     *                   collection.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned. Or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options
     *                 <ul>
     *                         <li> expression: Optional filter expression to
     *                 apply to the table.
     *                         <li> fast_index_lookup: Indicates if indexes
     *                 should be used to perform the lookup for a given
     *                 expression if possible. Only applicable if there is no
     *                 sorting, the expression contains only equivalence
     *                 comparisons based on existing tables indexes and the
     *                 range of requested values is from [0 to END_OF_SET]. The
     *                 default value is true.
     *                         <li> sort_by: Optional column that the data
     *                 should be sorted by. Empty by default (i.e. no sorting
     *                 is applied).
     *                         <li> sort_order: String indicating how the
     *                 returned values should be sorted - ascending or
     *                 descending. If sort_order is provided, sort_by has to be
     *                 provided. Values: ascending, descending.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsResponse<TResponse> getRecords(String tableName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsRequest actualRequest_ = new GetRecordsRequest(tableName, offset, limit, null, options);
        RawGetRecordsResponse actualResponse_ = new RawGetRecordsResponse();
        submitRequest("/get/records", actualRequest_, actualResponse_, false);
        GetRecordsResponse<TResponse> response_ = new GetRecordsResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeName(actualResponse_.getTypeName());
        response_.setTypeSchema(actualResponse_.getTypeSchema());
        response_.setData(this.<TResponse>decode(actualResponse_.getTypeName(), actualResponse_.getRecordsBinary()));
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * For a given table, retrieves the values of the given columns within a
     * given range. It returns maps of column name to the vector of values for
     * each supported data type (double, float, long, int and string). This
     * operation supports pagination feature, i.e. values that are retrieved
     * are those associated with the indices between the start (offset) and end
     * value (offset + limit) parameters (inclusive). If there are num_points
     * values in the table then each of the indices between 0 and num_points-1
     * retrieves a unique value.
     * <p>
     * Note that when using the pagination feature, if the table (or the
     * underlying table in case of a view) is updated (records are inserted,
     * deleted or modified) the records or values retrieved may differ between
     * calls (discontiguous or overlap) based on the type of the update.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawGetRecordsByColumnResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawGetRecordsByColumnResponse getRecordsByColumnRaw(GetRecordsByColumnRequest request) throws GPUdbException {
        RawGetRecordsByColumnResponse actualResponse_ = new RawGetRecordsByColumnResponse();
        submitRequest("/get/records/bycolumn", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * For a given table, retrieves the values of the given columns within a
     * given range. It returns maps of column name to the vector of values for
     * each supported data type (double, float, long, int and string). This
     * operation supports pagination feature, i.e. values that are retrieved
     * are those associated with the indices between the start (offset) and end
     * value (offset + limit) parameters (inclusive). If there are num_points
     * values in the table then each of the indices between 0 and num_points-1
     * retrieves a unique value.
     * <p>
     * Note that when using the pagination feature, if the table (or the
     * underlying table in case of a view) is updated (records are inserted,
     * deleted or modified) the records or values retrieved may differ between
     * calls (discontiguous or overlap) based on the type of the update.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsByColumnResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GetRecordsByColumnResponse getRecordsByColumn(GetRecordsByColumnRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawGetRecordsByColumnResponse actualResponse_ = new RawGetRecordsByColumnResponse();
        submitRequest("/get/records/bycolumn", request, actualResponse_, false);
        GetRecordsByColumnResponse response_ = new GetRecordsByColumnResponse();
        response_.setTableName(actualResponse_.getTableName());
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * For a given table, retrieves the values of the given columns within a
     * given range. It returns maps of column name to the vector of values for
     * each supported data type (double, float, long, int and string). This
     * operation supports pagination feature, i.e. values that are retrieved
     * are those associated with the indices between the start (offset) and end
     * value (offset + limit) parameters (inclusive). If there are num_points
     * values in the table then each of the indices between 0 and num_points-1
     * retrieves a unique value.
     * <p>
     * Note that when using the pagination feature, if the table (or the
     * underlying table in case of a view) is updated (records are inserted,
     * deleted or modified) the records or values retrieved may differ between
     * calls (discontiguous or overlap) based on the type of the update.
     * <p>
     * The response is returned as a dynamic schema. For details see: <a
     * href="../../../../concepts/dynamic_schemas.html" target="_top">dynamic
     * schemas documentation</a>.
     * 
     * @param tableName  Name of the table on which this operation will be
     *                   performed. The table cannot be a parent set.
     * @param columnNames  The list of column values to retrieve.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned (if not provided the default is
     *               10000), or END_OF_SET (-9999) to indicate that the maximum
     *               number of results allowed by the server should be
     *               returned.
     * @param options
     *                 <ul>
     *                         <li> expression: Optional filter expression to
     *                 apply to the table.
     *                         <li> sort_by: Optional column that the data
     *                 should be sorted by. Empty by default (i.e. no sorting
     *                 is applied).
     *                         <li> sort_order: String indicating how the
     *                 returned values should be sorted - ascending or
     *                 descending. Default is 'ascending'. If sort_order is
     *                 provided, sort_by has to be provided. Values: ascending,
     *                 descending.
     *                         <li> order_by: Comma-separated list of the
     *                 columns to be sorted by; e.g. 'timestamp asc, x desc'.
     *                 The columns specified must be present in {@code
     *                 columnNames}.  If any alias is given for any column
     *                 name, the alias must be used, rather than the original
     *                 column name.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsByColumnResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GetRecordsByColumnResponse getRecordsByColumn(String tableName, List<String> columnNames, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsByColumnRequest actualRequest_ = new GetRecordsByColumnRequest(tableName, columnNames, offset, limit, null, options);
        RawGetRecordsByColumnResponse actualResponse_ = new RawGetRecordsByColumnResponse();
        submitRequest("/get/records/bycolumn", actualRequest_, actualResponse_, false);
        GetRecordsByColumnResponse response_ = new GetRecordsByColumnResponse();
        response_.setTableName(actualResponse_.getTableName());
        response_.setData( DynamicTableRecord.transpose( actualResponse_.getResponseSchemaStr(), actualResponse_.getBinaryEncodedResponse() ) );
        response_.setTotalNumberOfRecords(actualResponse_.getTotalNumberOfRecords());
        response_.setHasMoreRecords(actualResponse_.getHasMoreRecords());
        return response_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track information contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecordsRaw(GetRecordsRequest)} this
     * returns records grouped by series/track. So if {@code offset} is 0 and
     * {@code limit} is 5 this operation would return the first 5 series/tracks
     * in {@code tableName}. Each series/track will be returned sorted by their
     * TIMESTAMP column.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawGetRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawGetRecordsBySeriesResponse getRecordsBySeriesRaw(GetRecordsBySeriesRequest request) throws GPUdbException {
        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track information contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecords(Object, GetRecordsRequest)} this
     * returns records grouped by series/track. So if {@code offset} is 0 and
     * {@code limit} is 5 this operation would return the first 5 series/tracks
     * in {@code tableName}. Each series/track will be returned sorted by their
     * TIMESTAMP column.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsBySeriesResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsBySeriesResponse<TResponse> getRecordsBySeries(Object typeDescriptor, GetRecordsBySeriesRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", request, actualResponse_, false);
        GetRecordsBySeriesResponse<TResponse> response_ = new GetRecordsBySeriesResponse<>();
        response_.setTableNames(actualResponse_.getTableNames());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setTypeSchemas(actualResponse_.getTypeSchemas());
        response_.setData(this.<TResponse>decodeMultiple(typeDescriptor, actualResponse_.getListRecordsBinary()));
        return response_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track information contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecords(Object, String, long, long, Map)}
     * this returns records grouped by series/track. So if {@code offset} is 0
     * and {@code limit} is 5 this operation would return the first 5
     * series/tracks in {@code tableName}. Each series/track will be returned
     * sorted by their TIMESTAMP column.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param tableName  Name of the collection/table/view for which
     *                   series/tracks will be fetched.
     * @param worldTableName  Name of the table containing the complete
     *                        series/track information to be returned for the
     *                        tracks present in the {@code tableName}.
     *                        Typically this is used when retrieving
     *                        series/tracks from a view (which contains partial
     *                        series/tracks) but the user wants to retrieve the
     *                        entire original series/tracks. Can be blank.
     * @param offset  A positive integer indicating the number of initial
     *                series/tracks to skip (useful for paging through the
     *                results).  The minimum allowed value is 0. The maximum
     *                allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               series/tracks to be returned. Or END_OF_SET (-9999) to
     *               indicate that the max number of results should be
     *               returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsBySeriesResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsBySeriesResponse<TResponse> getRecordsBySeries(Object typeDescriptor, String tableName, String worldTableName, int offset, int limit, Map<String, String> options) throws GPUdbException {
        GetRecordsBySeriesRequest actualRequest_ = new GetRecordsBySeriesRequest(tableName, worldTableName, offset, limit, null, options);
        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
        GetRecordsBySeriesResponse<TResponse> response_ = new GetRecordsBySeriesResponse<>();
        response_.setTableNames(actualResponse_.getTableNames());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setTypeSchemas(actualResponse_.getTypeSchemas());
        response_.setData(this.<TResponse>decodeMultiple(typeDescriptor, actualResponse_.getListRecordsBinary()));
        return response_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track information contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecords(GetRecordsRequest)} this returns
     * records grouped by series/track. So if {@code offset} is 0 and {@code
     * limit} is 5 this operation would return the first 5 series/tracks in
     * {@code tableName}. Each series/track will be returned sorted by their
     * TIMESTAMP column.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsBySeriesResponse<TResponse> getRecordsBySeries(GetRecordsBySeriesRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", request, actualResponse_, false);
        GetRecordsBySeriesResponse<TResponse> response_ = new GetRecordsBySeriesResponse<>();
        response_.setTableNames(actualResponse_.getTableNames());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setTypeSchemas(actualResponse_.getTypeSchemas());
        response_.setData(this.<TResponse>decodeMultiple(actualResponse_.getTypeNames(), actualResponse_.getListRecordsBinary()));
        return response_;
    }



    /**
     * Retrieves the complete series/track records from the given {@code
     * worldTableName} based on the partial track information contained in the
     * {@code tableName}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * In contrast to {@link GPUdb#getRecords(String, long, long, Map)} this
     * returns records grouped by series/track. So if {@code offset} is 0 and
     * {@code limit} is 5 this operation would return the first 5 series/tracks
     * in {@code tableName}. Each series/track will be returned sorted by their
     * TIMESTAMP column.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param tableName  Name of the collection/table/view for which
     *                   series/tracks will be fetched.
     * @param worldTableName  Name of the table containing the complete
     *                        series/track information to be returned for the
     *                        tracks present in the {@code tableName}.
     *                        Typically this is used when retrieving
     *                        series/tracks from a view (which contains partial
     *                        series/tracks) but the user wants to retrieve the
     *                        entire original series/tracks. Can be blank.
     * @param offset  A positive integer indicating the number of initial
     *                series/tracks to skip (useful for paging through the
     *                results).  The minimum allowed value is 0. The maximum
     *                allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               series/tracks to be returned. Or END_OF_SET (-9999) to
     *               indicate that the max number of results should be
     *               returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsBySeriesResponse<TResponse> getRecordsBySeries(String tableName, String worldTableName, int offset, int limit, Map<String, String> options) throws GPUdbException {
        GetRecordsBySeriesRequest actualRequest_ = new GetRecordsBySeriesRequest(tableName, worldTableName, offset, limit, null, options);
        RawGetRecordsBySeriesResponse actualResponse_ = new RawGetRecordsBySeriesResponse();
        submitRequest("/get/records/byseries", actualRequest_, actualResponse_, false);
        GetRecordsBySeriesResponse<TResponse> response_ = new GetRecordsBySeriesResponse<>();
        response_.setTableNames(actualResponse_.getTableNames());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setTypeSchemas(actualResponse_.getTypeSchemas());
        response_.setData(this.<TResponse>decodeMultiple(actualResponse_.getTypeNames(), actualResponse_.getListRecordsBinary()));
        return response_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(DeleteRecordsRequest)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RawGetRecordsFromCollectionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RawGetRecordsFromCollectionResponse getRecordsFromCollectionRaw(GetRecordsFromCollectionRequest request) throws GPUdbException {
        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(DeleteRecordsRequest)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsFromCollectionResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection(Object typeDescriptor, GetRecordsFromCollectionRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", request, actualResponse_, false);
        GetRecordsFromCollectionResponse<TResponse> response_ = new GetRecordsFromCollectionResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setData(this.<TResponse>decode(typeDescriptor, actualResponse_.getRecordsBinary()));
        response_.setRecordIds(actualResponse_.getRecordIds());
        return response_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(String, List, Map)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param typeDescriptor  Type descriptor used for decoding returned
     *                        objects.
     * @param tableName  Name of the collection or table from which records are
     *                   to be retrieved. Must be an existing collection or
     *                   table.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned, or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options
     *                 <ul>
     *                         <li> return_record_ids: If 'true' then return
     *                 the internal record ID along with each returned record.
     *                 Default is 'false'. Values: true, false.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsFromCollectionResponse
     * 
     * @throws IllegalArgumentException  if {@code typeDescriptor} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection(Object typeDescriptor, String tableName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsFromCollectionRequest actualRequest_ = new GetRecordsFromCollectionRequest(tableName, offset, limit, null, options);
        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
        GetRecordsFromCollectionResponse<TResponse> response_ = new GetRecordsFromCollectionResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setData(this.<TResponse>decode(typeDescriptor, actualResponse_.getRecordsBinary()));
        response_.setRecordIds(actualResponse_.getRecordIds());
        return response_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(DeleteRecordsRequest)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsFromCollectionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection(GetRecordsFromCollectionRequest request) throws GPUdbException {
        if ( !request.getEncoding().equals( "binary" ))
            throw new GPUdbException( "This method only supports binary encoding." );

        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", request, actualResponse_, false);
        GetRecordsFromCollectionResponse<TResponse> response_ = new GetRecordsFromCollectionResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setData(this.<TResponse>decode(actualResponse_.getTypeNames(), actualResponse_.getRecordsBinary()));
        response_.setRecordIds(actualResponse_.getRecordIds());
        return response_;
    }



    /**
     * Retrieves records from a collection. The operation can optionally return
     * the record IDs which can be used in certain queries such as {@link
     * GPUdb#deleteRecords(String, List, Map)}.
     * <p>
     * This operation supports paging through the data via the {@code offset}
     * and {@code limit} parameters.
     * <p>
     * Note that when using the Java API, it is not possible to retrieve
     * records from join tables using this operation.
     * 
     * @param <TResponse>  The type of object being retrieved.
     * @param tableName  Name of the collection or table from which records are
     *                   to be retrieved. Must be an existing collection or
     *                   table.
     * @param offset  A positive integer indicating the number of initial
     *                results to skip (this can be useful for paging through
     *                the results).  The minimum allowed value is 0. The
     *                maximum allowed value is MAX_INT.
     * @param limit  A positive integer indicating the maximum number of
     *               results to be returned, or END_OF_SET (-9999) to indicate
     *               that the max number of results should be returned.
     * @param options
     *                 <ul>
     *                         <li> return_record_ids: If 'true' then return
     *                 the internal record ID along with each returned record.
     *                 Default is 'false'. Values: true, false.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GetRecordsFromCollectionResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TResponse> GetRecordsFromCollectionResponse<TResponse> getRecordsFromCollection(String tableName, long offset, long limit, Map<String, String> options) throws GPUdbException {
        GetRecordsFromCollectionRequest actualRequest_ = new GetRecordsFromCollectionRequest(tableName, offset, limit, null, options);
        RawGetRecordsFromCollectionResponse actualResponse_ = new RawGetRecordsFromCollectionResponse();
        submitRequest("/get/records/fromcollection", actualRequest_, actualResponse_, false);
        GetRecordsFromCollectionResponse<TResponse> response_ = new GetRecordsFromCollectionResponse<>();
        response_.setTableName(actualResponse_.getTableName());
        response_.setTypeNames(actualResponse_.getTypeNames());
        response_.setData(this.<TResponse>decode(actualResponse_.getTypeNames(), actualResponse_.getRecordsBinary()));
        response_.setRecordIds(actualResponse_.getRecordIds());
        return response_;
    }



    /**
     * Grants a system-level permission to a user or role.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GrantPermissionSystemResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GrantPermissionSystemResponse grantPermissionSystem(GrantPermissionSystemRequest request) throws GPUdbException {
        GrantPermissionSystemResponse actualResponse_ = new GrantPermissionSystemResponse();
        submitRequest("/grant/permission/system", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Grants a system-level permission to a user or role.
     * 
     * @param name  Name of the user or role to which the permission will be
     *              granted. Must be an existing user or role.
     * @param permission  Permission to grant to the user or role. Values:
     *                    system_admin, system_write, system_read.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GrantPermissionSystemResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GrantPermissionSystemResponse grantPermissionSystem(String name, String permission, Map<String, String> options) throws GPUdbException {
        GrantPermissionSystemRequest actualRequest_ = new GrantPermissionSystemRequest(name, permission, options);
        GrantPermissionSystemResponse actualResponse_ = new GrantPermissionSystemResponse();
        submitRequest("/grant/permission/system", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Grants a table-level permission to a user or role.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GrantPermissionTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GrantPermissionTableResponse grantPermissionTable(GrantPermissionTableRequest request) throws GPUdbException {
        GrantPermissionTableResponse actualResponse_ = new GrantPermissionTableResponse();
        submitRequest("/grant/permission/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Grants a table-level permission to a user or role.
     * 
     * @param name  Name of the user or role to which the permission will be
     *              granted. Must be an existing user or role.
     * @param permission  Permission to grant to the user or role. Values:
     *                    table_admin, table_insert, table_update,
     *                    table_delete, table_read.
     * @param tableName  Name of the table to which the permission grants
     *                   access. Must be an existing table, collection, or
     *                   view. If a collection, the permission also applies to
     *                   tables and views in the collection.
     * @param filterExpression  Reserved for future use.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GrantPermissionTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GrantPermissionTableResponse grantPermissionTable(String name, String permission, String tableName, String filterExpression, Map<String, String> options) throws GPUdbException {
        GrantPermissionTableRequest actualRequest_ = new GrantPermissionTableRequest(name, permission, tableName, filterExpression, options);
        GrantPermissionTableResponse actualResponse_ = new GrantPermissionTableResponse();
        submitRequest("/grant/permission/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Grants membership in a role to a user or role.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GrantRoleResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GrantRoleResponse grantRole(GrantRoleRequest request) throws GPUdbException {
        GrantRoleResponse actualResponse_ = new GrantRoleResponse();
        submitRequest("/grant/role", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Grants membership in a role to a user or role.
     * 
     * @param role  Name of the role in which membership will be granted. Must
     *              be an existing role.
     * @param member  Name of the user or role that will be granted membership
     *                in {@code role}. Must be an existing user or role.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  GrantRoleResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public GrantRoleResponse grantRole(String role, String member, Map<String, String> options) throws GPUdbException {
        GrantRoleRequest actualRequest_ = new GrantRoleRequest(role, member, options);
        GrantRoleResponse actualResponse_ = new GrantRoleResponse();
        submitRequest("/grant/role", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Checks the existence of a proc with the given name.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasProcResponse hasProc(HasProcRequest request) throws GPUdbException {
        HasProcResponse actualResponse_ = new HasProcResponse();
        submitRequest("/has/proc", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Checks the existence of a proc with the given name.
     * 
     * @param procName  Name of the proc to check for existence.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasProcResponse hasProc(String procName, Map<String, String> options) throws GPUdbException {
        HasProcRequest actualRequest_ = new HasProcRequest(procName, options);
        HasProcResponse actualResponse_ = new HasProcResponse();
        submitRequest("/has/proc", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Checks for the existence of a table with the given name.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasTableResponse hasTable(HasTableRequest request) throws GPUdbException {
        HasTableResponse actualResponse_ = new HasTableResponse();
        submitRequest("/has/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Checks for the existence of a table with the given name.
     * 
     * @param tableName  Name of the table to check for existence.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasTableResponse hasTable(String tableName, Map<String, String> options) throws GPUdbException {
        HasTableRequest actualRequest_ = new HasTableRequest(tableName, options);
        HasTableResponse actualResponse_ = new HasTableResponse();
        submitRequest("/has/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Check for the existence of a type.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasTypeResponse hasType(HasTypeRequest request) throws GPUdbException {
        HasTypeResponse actualResponse_ = new HasTypeResponse();
        submitRequest("/has/type", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Check for the existence of a type.
     * 
     * @param typeId  Id of the type returned in response to {@link
     *                GPUdb#createType(String, String, Map, Map)} request.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  HasTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public HasTypeResponse hasType(String typeId, Map<String, String> options) throws GPUdbException {
        HasTypeRequest actualRequest_ = new HasTypeRequest(typeId, options);
        HasTypeResponse actualResponse_ = new HasTypeResponse();
        submitRequest("/has/type", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous, meaning that a response will not be returned until all the
     * records are fully inserted and available. The response payload provides
     * the counts of the number of records actually inserted and/or updated,
     * and can provide the unique identifier of each added record.
     * <p>
     * The {@code options} parameter can be used to customize this function's
     * behavior.  The {@code update_on_existing_pk} option specifies the
     * primary-key collision policy.  If the table has a {@link
     * GPUdb#createType(CreateTypeRequest) primary key} and if {@code
     * update_on_existing_pk} is {@code true}, then if any of the records being
     * added have the same primary key as existing records, the existing
     * records are replaced (i.e. updated) with the given records.  If {@code
     * update_on_existing_pk} is {@code false} and if the records being added
     * have the same primary key as existing records, they are ignored (the
     * existing records are left unchanged).  It is quite possible that in this
     * case some of the given records will be inserted and some (those having
     * existing primary keys) will be ignored (or updated).  If the specified
     * table does not have a primary key column, then the {@code
     * update_on_existing_pk} option is ignored.
     * <p>
     * The {@code return_record_ids} option indicates that the database should
     * return the unique identifiers of inserted records.
     * <p>
     * The {@code route_to_address} option directs that inserted records should
     * be targeted for a particular database node.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertRecordsResponse insertRecordsRaw(RawInsertRecordsRequest request) throws GPUdbException {
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", request, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous, meaning that a response will not be returned until all the
     * records are fully inserted and available. The response payload provides
     * the counts of the number of records actually inserted and/or updated,
     * and can provide the unique identifier of each added record.
     * <p>
     * The {@code options} parameter can be used to customize this function's
     * behavior.  The {@code update_on_existing_pk} option specifies the
     * primary-key collision policy.  If the table has a {@link
     * GPUdb#createType(CreateTypeRequest) primary key} and if {@code
     * update_on_existing_pk} is {@code true}, then if any of the records being
     * added have the same primary key as existing records, the existing
     * records are replaced (i.e. updated) with the given records.  If {@code
     * update_on_existing_pk} is {@code false} and if the records being added
     * have the same primary key as existing records, they are ignored (the
     * existing records are left unchanged).  It is quite possible that in this
     * case some of the given records will be inserted and some (those having
     * existing primary keys) will be ignored (or updated).  If the specified
     * table does not have a primary key column, then the {@code
     * update_on_existing_pk} option is ignored.
     * <p>
     * The {@code return_record_ids} option indicates that the database should
     * return the unique identifiers of inserted records.
     * <p>
     * The {@code route_to_address} option directs that inserted records should
     * be targeted for a particular database node.
     * 
     * @param <TRequest>  The type of object being added.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> InsertRecordsResponse insertRecords(InsertRecordsRequest<TRequest> request) throws GPUdbException {
        RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest(request.getTableName(), this.encode( request.getData() ), null, null, request.getOptions());
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous, meaning that a response will not be returned until all the
     * records are fully inserted and available. The response payload provides
     * the counts of the number of records actually inserted and/or updated,
     * and can provide the unique identifier of each added record.
     * <p>
     * The {@code options} parameter can be used to customize this function's
     * behavior.  The {@code update_on_existing_pk} option specifies the
     * primary-key collision policy.  If the table has a {@link
     * GPUdb#createType(CreateTypeRequest) primary key} and if {@code
     * update_on_existing_pk} is {@code true}, then if any of the records being
     * added have the same primary key as existing records, the existing
     * records are replaced (i.e. updated) with the given records.  If {@code
     * update_on_existing_pk} is {@code false} and if the records being added
     * have the same primary key as existing records, they are ignored (the
     * existing records are left unchanged).  It is quite possible that in this
     * case some of the given records will be inserted and some (those having
     * existing primary keys) will be ignored (or updated).  If the specified
     * table does not have a primary key column, then the {@code
     * update_on_existing_pk} option is ignored.
     * <p>
     * The {@code return_record_ids} option indicates that the database should
     * return the unique identifiers of inserted records.
     * <p>
     * The {@code route_to_address} option directs that inserted records should
     * be targeted for a particular database node.
     * 
     * @param <TRequest>  The type of object being added.
     * @param typeObjectMap  Type object map used for encoding input objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeObjectMap} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> InsertRecordsResponse insertRecords(TypeObjectMap<TRequest> typeObjectMap, InsertRecordsRequest<TRequest> request) throws GPUdbException {
        RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest(request.getTableName(), this.encode( typeObjectMap, request.getData() ), null, null, request.getOptions());
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous, meaning that a response will not be returned until all the
     * records are fully inserted and available. The response payload provides
     * the counts of the number of records actually inserted and/or updated,
     * and can provide the unique identifier of each added record.
     * <p>
     * The {@code options} parameter can be used to customize this function's
     * behavior.  The {@code update_on_existing_pk} option specifies the
     * primary-key collision policy.  If the table has a {@link
     * GPUdb#createType(String, String, Map, Map) primary key} and if {@code
     * update_on_existing_pk} is {@code true}, then if any of the records being
     * added have the same primary key as existing records, the existing
     * records are replaced (i.e. updated) with the given records.  If {@code
     * update_on_existing_pk} is {@code false} and if the records being added
     * have the same primary key as existing records, they are ignored (the
     * existing records are left unchanged).  It is quite possible that in this
     * case some of the given records will be inserted and some (those having
     * existing primary keys) will be ignored (or updated).  If the specified
     * table does not have a primary key column, then the {@code
     * update_on_existing_pk} option is ignored.
     * <p>
     * The {@code return_record_ids} option indicates that the database should
     * return the unique identifiers of inserted records.
     * <p>
     * The {@code route_to_address} option directs that inserted records should
     * be targeted for a particular database node.
     * 
     * @param <TRequest>  The type of object being added.
     * @param tableName  Table to which the records are to be added. Must be an
     *                   existing table.
     * @param data  An array of binary-encoded data for the records to be
     *              added. All records must be of the same type as that of the
     *              table. Empty array if {@code listEncoding} is {@code json}.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> update_on_existing_pk: If the table has a
     *                 {@link GPUdb#createType(String, String, Map, Map)
     *                 primary key}, then if the value is {@code true} then if
     *                 any of the records being added have the same primary key
     *                 as existing records, the existing records are replaced
     *                 (i.e. updated) with the given records. If {@code false},
     *                 and if the records being added have the same primary key
     *                 as existing records, they are ignored (the existing
     *                 records are left unchanged).  It is quite possible that
     *                 in this case some of the given records will be inserted
     *                 and some (those having existing primary keys) will be
     *                 ignored (or updated). If the specified table does not
     *                 have a primary key column then this optional parameter
     *                 is ignored. Values: true, false.
     *                         <li> return_record_ids: If {@code true} then
     *                 return the internal record id along for each inserted
     *                 record. Values: true, false.
     *                         <li> route_to_address: Route to a specific
     *                 rank/tom. Option not suitable for tables using
     *                 primary/shard keys
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> InsertRecordsResponse insertRecords(String tableName, List<TRequest> data, Map<String, String> options) throws GPUdbException {
        RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest(tableName, this.encode( data ), null, null, options);
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Adds multiple records to the specified table. The operation is
     * synchronous, meaning that a response will not be returned until all the
     * records are fully inserted and available. The response payload provides
     * the counts of the number of records actually inserted and/or updated,
     * and can provide the unique identifier of each added record.
     * <p>
     * The {@code options} parameter can be used to customize this function's
     * behavior.  The {@code update_on_existing_pk} option specifies the
     * primary-key collision policy.  If the table has a {@link
     * GPUdb#createType(String, String, Map, Map) primary key} and if {@code
     * update_on_existing_pk} is {@code true}, then if any of the records being
     * added have the same primary key as existing records, the existing
     * records are replaced (i.e. updated) with the given records.  If {@code
     * update_on_existing_pk} is {@code false} and if the records being added
     * have the same primary key as existing records, they are ignored (the
     * existing records are left unchanged).  It is quite possible that in this
     * case some of the given records will be inserted and some (those having
     * existing primary keys) will be ignored (or updated).  If the specified
     * table does not have a primary key column, then the {@code
     * update_on_existing_pk} option is ignored.
     * <p>
     * The {@code return_record_ids} option indicates that the database should
     * return the unique identifiers of inserted records.
     * <p>
     * The {@code route_to_address} option directs that inserted records should
     * be targeted for a particular database node.
     * 
     * @param <TRequest>  The type of object being added.
     * @param typeObjectMap  Type object map used for encoding input objects.
     * @param tableName  Table to which the records are to be added. Must be an
     *                   existing table.
     * @param data  An array of binary-encoded data for the records to be
     *              added. All records must be of the same type as that of the
     *              table. Empty array if {@code listEncoding} is {@code json}.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> update_on_existing_pk: If the table has a
     *                 {@link GPUdb#createType(String, String, Map, Map)
     *                 primary key}, then if the value is {@code true} then if
     *                 any of the records being added have the same primary key
     *                 as existing records, the existing records are replaced
     *                 (i.e. updated) with the given records. If {@code false},
     *                 and if the records being added have the same primary key
     *                 as existing records, they are ignored (the existing
     *                 records are left unchanged).  It is quite possible that
     *                 in this case some of the given records will be inserted
     *                 and some (those having existing primary keys) will be
     *                 ignored (or updated). If the specified table does not
     *                 have a primary key column then this optional parameter
     *                 is ignored. Values: true, false.
     *                         <li> return_record_ids: If {@code true} then
     *                 return the internal record id along for each inserted
     *                 record. Values: true, false.
     *                         <li> route_to_address: Route to a specific
     *                 rank/tom. Option not suitable for tables using
     *                 primary/shard keys
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeObjectMap} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> InsertRecordsResponse insertRecords(TypeObjectMap<TRequest> typeObjectMap, String tableName, List<TRequest> data, Map<String, String> options) throws GPUdbException {
        RawInsertRecordsRequest actualRequest_ = new RawInsertRecordsRequest(tableName, this.encode( typeObjectMap, data ), null, null, options);
        InsertRecordsResponse actualResponse_ = new InsertRecordsResponse();
        submitRequest("/insert/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Generates a specified number of random records and adds them to the
     * given table. There is an optional parameter that allows the user to
     * customize the ranges of the column values. It also allows the user to
     * specify linear profiles for some or all columns in which case linear
     * values are generated rather than random ones. Only individual tables are
     * supported for this operation.
     * <p>
     * This operation is synchronous, meaning that a response will not be
     * returned until all random records are fully available.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsRandomResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertRecordsRandomResponse insertRecordsRandom(InsertRecordsRandomRequest request) throws GPUdbException {
        InsertRecordsRandomResponse actualResponse_ = new InsertRecordsRandomResponse();
        submitRequest("/insert/records/random", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Generates a specified number of random records and adds them to the
     * given table. There is an optional parameter that allows the user to
     * customize the ranges of the column values. It also allows the user to
     * specify linear profiles for some or all columns in which case linear
     * values are generated rather than random ones. Only individual tables are
     * supported for this operation.
     * <p>
     * This operation is synchronous, meaning that a response will not be
     * returned until all random records are fully available.
     * 
     * @param tableName  Table to which random records will be added. Must be
     *                   an existing table.  Also, must be an individual table,
     *                   not a collection of tables, nor a view of a table.
     * @param count  Number of records to generate.
     * @param options  Optional parameter to pass in specifications for the
     *                 randomness of the values.  This map is different from
     *                 the *options* parameter of most other endpoints in that
     *                 it is a map of string to map of string to doubles, while
     *                 most others are maps of string to string.  In this map,
     *                 the top level keys represent which column's parameters
     *                 are being specified, while the internal keys represents
     *                 which parameter is being specified.  The parameters that
     *                 can be specified are: *min*, *max*, and *interval*.
     *                 These parameters take on different meanings depending on
     *                 the type of the column.  Below follows a more detailed
     *                 description of the map:
     *                 <ul>
     *                         <li> seed: If provided, the internal random
     *                 number generator will be initialized with the given
     *                 value.  The minimum is 0.  This allows for the same set
     *                 of random numbers to be generated across invocation of
     *                 this endpoint in case the user wants to repeat the test.
     *                 Since {@code options}, is a map of maps, we need an
     *                 internal map to provide the seed value.  For example, to
     *                 pass 100 as the seed value through this parameter, you
     *                 need something equivalent to: 'options' = {'seed': {
     *                 'value': 100 } }
     *                 <ul>
     *                         <li> value: Pass the seed value here.
     *                 </ul>
     *                         <li> all: This key indicates that the
     *                 specifications relayed in the internal map are to be
     *                 applied to all columns of the records.
     *                 <ul>
     *                         <li> min: For numerical columns, the minimum of
     *                 the generated values is set to this value.  Default is
     *                 -99999.  For point, shape, and track semantic types, min
     *                 for numeric 'x' and 'y' columns needs to be within
     *                 [-180, 180] and [-90, 90], respectively. The default
     *                 minimum possible values for these columns in such cases
     *                 are -180.0 and -90.0. For the 'TIMESTAMP' column, the
     *                 default minimum corresponds to Jan 1, 2010.
     *                 For string columns, the minimum length of the randomly
     *                 generated strings is set to this value (default is 1).
     *                 If both minimum and maximum are provided, minimum must
     *                 be less than or equal to max. Value needs to be within
     *                 [1, 200].
     *                 If the min is outside the accepted ranges for strings
     *                 columns and 'x' and 'y' columns for point/shape/track
     *                 types, then those parameters will not be set; however,
     *                 an error will not be thrown in such a case. It is the
     *                 responsibility of the user to use the {@code all}
     *                 parameter judiciously.
     *                         <li> max: For numerical columns, the maximum of
     *                 the generated values is set to this value. Default is
     *                 99999. For point, shape, and track semantic types, max
     *                 for numeric 'x' and 'y' columns needs to be within
     *                 [-180, 180] and [-90, 90], respectively. The default
     *                 minimum possible values for these columns in such cases
     *                 are 180.0 and 90.0.
     *                 For string columns, the maximum length of the randomly
     *                 generated strings is set to this value (default is 200).
     *                 If both minimum and maximum are provided, *max* must be
     *                 greater than or equal to *min*. Value needs to be within
     *                 [1, 200].
     *                 If the *max* is outside the accepted ranges for strings
     *                 columns and 'x' and 'y' columns for point/shape/track
     *                 types, then those parameters will not be set; however,
     *                 an error will not be thrown in such a case. It is the
     *                 responsibility of the user to use the {@code all}
     *                 parameter judiciously.
     *                         <li> interval: If specified, then generate
     *                 values for all columns linearly and evenly spaced with
     *                 the given interval value starting at the minimum value
     *                 (instead of generating random data). *Any provided max
     *                 value is disregarded.*  For string-type columns, the
     *                 interval value is ignored but the string values would be
     *                 generated following the pattern:
     *                 'attrname_creationIndex#', i.e. the column name suffixed
     *                 with an underscore and a running counter (starting at
     *                 0).  No nulls would be generated for nullable columns.
     *                         <li> null_percentage: If specified, then
     *                 generate the given percentage of the count as nulls for
     *                 all nullable columns.  This option will be ignored for
     *                 non-nullable columns.  The value must be within the
     *                 range [0, 1.0].  The default value is 5% (0.05).
     *                 </ul>
     *                         <li> attr_name: Set the following parameters for
     *                 the column specified by the key. This overrides any
     *                 parameter set by {@code all}.
     *                 <ul>
     *                         <li> min: For numerical columns, the minimum of
     *                 the generated values is set to this value.  Default is
     *                 -99999.  For point, shape, and track semantic types, min
     *                 for numeric 'x' and 'y' columns needs to be within
     *                 [-180, 180] and [-90, 90], respectively. The default
     *                 minimum possible values for these columns in such cases
     *                 are -180.0 and -90.0. For the 'TIMESTAMP' column, the
     *                 default minimum corresponds to Jan 1, 2010.
     *                 For string columns, the minimum length of the randomly
     *                 generated strings is set to this value (default is 1).
     *                 If both minimum and maximum are provided, minimum must
     *                 be less than or equal to max. Value needs to be within
     *                 [1, 200].
     *                 If the min is outside the accepted ranges for strings
     *                 columns and 'x' and 'y' columns for point/shape/track
     *                 types, then those parameters will not be set; however,
     *                 an error will not be thrown in such a case. It is the
     *                 responsibility of the user to use the {@code all}
     *                 parameter judiciously.
     *                         <li> max: For numerical columns, the maximum of
     *                 the generated values is set to this value. Default is
     *                 99999. For point, shape, and track semantic types, max
     *                 for numeric 'x' and 'y' columns needs to be within
     *                 [-180, 180] and [-90, 90], respectively. The default
     *                 minimum possible values for these columns in such cases
     *                 are 180.0 and 90.0.
     *                 For string columns, the maximum length of the randomly
     *                 generated strings is set to this value (default is 200).
     *                 If both minimum and maximum are provided, *max* must be
     *                 greater than or equal to *min*. Value needs to be within
     *                 [1, 200].
     *                 If the *max* is outside the accepted ranges for strings
     *                 columns and 'x' and 'y' columns for point/shape/track
     *                 types, then those parameters will not be set; however,
     *                 an error will not be thrown in such a case. It is the
     *                 responsibility of the user to use the {@code all}
     *                 parameter judiciously.
     *                         <li> interval: If specified, then generate
     *                 values for all columns linearly and evenly spaced with
     *                 the given interval value starting at the minimum value
     *                 (instead of generating random data). *Any provided max
     *                 value is disregarded.*  For string-type columns, the
     *                 interval value is ignored but the string values would be
     *                 generated following the pattern:
     *                 'attrname_creationIndex#', i.e. the column name suffixed
     *                 with an underscore and a running counter (starting at
     *                 0).  No nulls would be generated for nullable columns.
     *                         <li> null_percentage: If specified and if this
     *                 column is nullable, then generate the given percentage
     *                 of the count as nulls.  This option will result in an
     *                 error if the column is not nullable.  The value must be
     *                 within the range [0, 1.0].  The default value is 5%
     *                 (0.05).
     *                 </ul>
     *                         <li> track_length: This key-map pair is only
     *                 valid for track type data sets (an error is thrown
     *                 otherwise).  No nulls would be generated for nullable
     *                 columns.
     *                 <ul>
     *                         <li> min: Minimum possible length for generated
     *                 series; default is 100 records per series. Must be an
     *                 integral value within the range [1, 500]. If both min
     *                 and max are specified, min must be less than or equal to
     *                 max.
     *                         <li> max: Maximum possible length for generated
     *                 series; default is 500 records per series. Must be an
     *                 integral value within the range [1, 500]. If both min
     *                 and max are specified, max must be greater than or equal
     *                 to min.
     *                 </ul>
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertRecordsRandomResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertRecordsRandomResponse insertRecordsRandom(String tableName, long count, Map<String, Map<String, Double>> options) throws GPUdbException {
        InsertRecordsRandomRequest actualRequest_ = new InsertRecordsRandomRequest(tableName, count, options);
        InsertRecordsRandomResponse actualResponse_ = new InsertRecordsRandomResponse();
        submitRequest("/insert/records/random", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Adds a symbol or icon (i.e. an image) to represent data points when data
     * is rendered visually. Users must provide the symbol identifier (string),
     * a format (currently supported: 'svg' and 'svg_path'), the data for the
     * symbol, and any additional optional parameter (e.g. color). To have a
     * symbol used for rendering create a table with a string column named
     * 'SYMBOLCODE' (along with 'x' or 'y' for example). Then when the table is
     * rendered (via <a href="../../../../api/rest/wms_rest.html"
     * target="_top">WMS</a>) if the 'dosymbology' parameter is 'true' then the
     * value of the 'SYMBOLCODE' column is used to pick the symbol displayed
     * for each point.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertSymbolResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertSymbolResponse insertSymbol(InsertSymbolRequest request) throws GPUdbException {
        InsertSymbolResponse actualResponse_ = new InsertSymbolResponse();
        submitRequest("/insert/symbol", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Adds a symbol or icon (i.e. an image) to represent data points when data
     * is rendered visually. Users must provide the symbol identifier (string),
     * a format (currently supported: 'svg' and 'svg_path'), the data for the
     * symbol, and any additional optional parameter (e.g. color). To have a
     * symbol used for rendering create a table with a string column named
     * 'SYMBOLCODE' (along with 'x' or 'y' for example). Then when the table is
     * rendered (via <a href="../../../../api/rest/wms_rest.html"
     * target="_top">WMS</a>) if the 'dosymbology' parameter is 'true' then the
     * value of the 'SYMBOLCODE' column is used to pick the symbol displayed
     * for each point.
     * 
     * @param symbolId  The id of the symbol being added. This is the same id
     *                  that should be in the 'SYMBOLCODE' column for objects
     *                  using this symbol
     * @param symbolFormat  Specifies the symbol format. Must be either 'svg'
     *                      or 'svg_path'. Values: svg, svg_path.
     * @param symbolData  The actual symbol data. If {@code symbolFormat} is
     *                    'svg' then this should be the raw bytes representing
     *                    an svg file. If {@code symbolFormat} is svg path then
     *                    this should be an svg path string, for example:
     *                    'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> color: If {@code symbolFormat} is 'svg'
     *                 this is ignored. If {@code symbolFormat} is 'svg_path'
     *                 then this option specifies the color (in RRGGBB hex
     *                 format) of the path. For example, to have the path
     *                 rendered in red, used 'FF0000'. If 'color' is not
     *                 provided then '00FF00' (i.e. green) is used by default.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  InsertSymbolResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public InsertSymbolResponse insertSymbol(String symbolId, String symbolFormat, ByteBuffer symbolData, Map<String, String> options) throws GPUdbException {
        InsertSymbolRequest actualRequest_ = new InsertSymbolRequest(symbolId, symbolFormat, symbolData, options);
        InsertSymbolResponse actualResponse_ = new InsertSymbolResponse();
        submitRequest("/insert/symbol", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Kills a running proc instance.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  KillProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public KillProcResponse killProc(KillProcRequest request) throws GPUdbException {
        KillProcResponse actualResponse_ = new KillProcResponse();
        submitRequest("/kill/proc", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Kills a running proc instance.
     * 
     * @param runId  The run ID of the running proc instance. If the run ID is
     *               not found or the proc instance has already completed, this
     *               does nothing. If not specified, all running proc instances
     *               will be killed.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  KillProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public KillProcResponse killProc(String runId, Map<String, String> options) throws GPUdbException {
        KillProcRequest actualRequest_ = new KillProcRequest(runId, options);
        KillProcResponse actualResponse_ = new KillProcResponse();
        submitRequest("/kill/proc", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Manages global access to a table's data.  By default a table has a
     * {@code lockType} of {@code unlock}, indicating all operations are
     * permitted.  A user may request a {@code read-only} or a {@code
     * write-only} lock, after which only read or write operations,
     * respectively, are permitted on the table until the lock is removed.
     * When {@code lockType} is {@code disable} then no operations are
     * permitted on the table.  The lock status can be queried by setting
     * {@code lockType} to {@code status}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  LockTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public LockTableResponse lockTable(LockTableRequest request) throws GPUdbException {
        LockTableResponse actualResponse_ = new LockTableResponse();
        submitRequest("/lock/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Manages global access to a table's data.  By default a table has a
     * {@code lockType} of {@code unlock}, indicating all operations are
     * permitted.  A user may request a {@code read-only} or a {@code
     * write-only} lock, after which only read or write operations,
     * respectively, are permitted on the table until the lock is removed.
     * When {@code lockType} is {@code disable} then no operations are
     * permitted on the table.  The lock status can be queried by setting
     * {@code lockType} to {@code status}.
     * 
     * @param tableName  Name of the table to be locked. It must be a currently
     *                   existing table, collection, or view.
     * @param lockType  The type of lock being applied to the table. Setting it
     *                  to {@code status} will return the current lock status
     *                  of the table without changing it. Values: status,
     *                  disable, read-only, write-only, unlock.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  LockTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public LockTableResponse lockTable(String tableName, String lockType, Map<String, String> options) throws GPUdbException {
        LockTableRequest actualRequest_ = new LockTableRequest(tableName, lockType, options);
        LockTableResponse actualResponse_ = new LockTableResponse();
        submitRequest("/lock/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Revokes a system-level permission from a user or role.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RevokePermissionSystemResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RevokePermissionSystemResponse revokePermissionSystem(RevokePermissionSystemRequest request) throws GPUdbException {
        RevokePermissionSystemResponse actualResponse_ = new RevokePermissionSystemResponse();
        submitRequest("/revoke/permission/system", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Revokes a system-level permission from a user or role.
     * 
     * @param name  Name of the user or role from which the permission will be
     *              revoked. Must be an existing user or role.
     * @param permission  Permission to revoke from the user or role. Values:
     *                    system_admin, system_write, system_read.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RevokePermissionSystemResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RevokePermissionSystemResponse revokePermissionSystem(String name, String permission, Map<String, String> options) throws GPUdbException {
        RevokePermissionSystemRequest actualRequest_ = new RevokePermissionSystemRequest(name, permission, options);
        RevokePermissionSystemResponse actualResponse_ = new RevokePermissionSystemResponse();
        submitRequest("/revoke/permission/system", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Revokes a table-level permission from a user or role.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RevokePermissionTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RevokePermissionTableResponse revokePermissionTable(RevokePermissionTableRequest request) throws GPUdbException {
        RevokePermissionTableResponse actualResponse_ = new RevokePermissionTableResponse();
        submitRequest("/revoke/permission/table", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Revokes a table-level permission from a user or role.
     * 
     * @param name  Name of the user or role from which the permission will be
     *              revoked. Must be an existing user or role.
     * @param permission  Permission to revoke from the user or role. Values:
     *                    table_admin, table_insert, table_update,
     *                    table_delete, table_read.
     * @param tableName  Name of the table to which the permission grants
     *                   access. Must be an existing table, collection, or
     *                   view.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RevokePermissionTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RevokePermissionTableResponse revokePermissionTable(String name, String permission, String tableName, Map<String, String> options) throws GPUdbException {
        RevokePermissionTableRequest actualRequest_ = new RevokePermissionTableRequest(name, permission, tableName, options);
        RevokePermissionTableResponse actualResponse_ = new RevokePermissionTableResponse();
        submitRequest("/revoke/permission/table", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Revokes membership in a role from a user or role.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RevokeRoleResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RevokeRoleResponse revokeRole(RevokeRoleRequest request) throws GPUdbException {
        RevokeRoleResponse actualResponse_ = new RevokeRoleResponse();
        submitRequest("/revoke/role", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Revokes membership in a role from a user or role.
     * 
     * @param role  Name of the role in which membership will be revoked. Must
     *              be an existing role.
     * @param member  Name of the user or role that will be revoked membership
     *                in {@code role}. Must be an existing user or role.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  RevokeRoleResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public RevokeRoleResponse revokeRole(String role, String member, Map<String, String> options) throws GPUdbException {
        RevokeRoleRequest actualRequest_ = new RevokeRoleRequest(role, member, options);
        RevokeRoleResponse actualResponse_ = new RevokeRoleResponse();
        submitRequest("/revoke/role", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Shows information about a proc.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowProcResponse showProc(ShowProcRequest request) throws GPUdbException {
        ShowProcResponse actualResponse_ = new ShowProcResponse();
        submitRequest("/show/proc", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Shows information about a proc.
     * 
     * @param procName  Name of the proc to show information about. If
     *                  specified, must be the name of a currently existing
     *                  proc. If not specified, information about all procs
     *                  will be returned.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> include_files: If set to {@code true}, the
     *                 files that make up the proc will be returned. If set to
     *                 {@code false}, the files will not be returned. Values:
     *                 true, false.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowProcResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowProcResponse showProc(String procName, Map<String, String> options) throws GPUdbException {
        ShowProcRequest actualRequest_ = new ShowProcRequest(procName, options);
        ShowProcResponse actualResponse_ = new ShowProcResponse();
        submitRequest("/show/proc", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Shows the statuses of running or completed proc instances. Results are
     * grouped by run ID (as returned from {@link
     * GPUdb#executeProc(ExecuteProcRequest)}) and data segment ID (each
     * invocation of the proc command on a data segment is assigned a data
     * segment ID).
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowProcStatusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowProcStatusResponse showProcStatus(ShowProcStatusRequest request) throws GPUdbException {
        ShowProcStatusResponse actualResponse_ = new ShowProcStatusResponse();
        submitRequest("/show/proc/status", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Shows the statuses of running or completed proc instances. Results are
     * grouped by run ID (as returned from {@link GPUdb#executeProc(String,
     * Map, Map, List, Map, List, Map)}) and data segment ID (each invocation
     * of the proc command on a data segment is assigned a data segment ID).
     * 
     * @param runId  The run ID of a specific running or completed proc
     *               instance for which the status will be returned. If the run
     *               ID is not found, nothing will be returned. If not
     *               specified, the statuses of all running and completed proc
     *               instances will be returned.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> clear_complete: If set to {@code true}, if
     *                 a proc instance has completed (either successfully or
     *                 unsuccessfully) then its status will be cleared and no
     *                 longer returned in subsequent calls. Values: true,
     *                 false.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowProcStatusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowProcStatusResponse showProcStatus(String runId, Map<String, String> options) throws GPUdbException {
        ShowProcStatusRequest actualRequest_ = new ShowProcStatusRequest(runId, options);
        ShowProcStatusResponse actualResponse_ = new ShowProcStatusResponse();
        submitRequest("/show/proc/status", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Shows security information relating to users and/or roles. If the caller
     * is not a system administrator, only information relating to the caller
     * and their roles is returned.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSecurityResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSecurityResponse showSecurity(ShowSecurityRequest request) throws GPUdbException {
        ShowSecurityResponse actualResponse_ = new ShowSecurityResponse();
        submitRequest("/show/security", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Shows security information relating to users and/or roles. If the caller
     * is not a system administrator, only information relating to the caller
     * and their roles is returned.
     * 
     * @param names  A list of names of users and/or roles about which security
     *               information is requested. If none are provided,
     *               information about all users and roles will be returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSecurityResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSecurityResponse showSecurity(List<String> names, Map<String, String> options) throws GPUdbException {
        ShowSecurityRequest actualRequest_ = new ShowSecurityRequest(names, options);
        ShowSecurityResponse actualResponse_ = new ShowSecurityResponse();
        submitRequest("/show/security", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns server configuration and version related information to the
     * caller. The admin tool uses it to present server related information to
     * the user.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemPropertiesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemPropertiesResponse showSystemProperties(ShowSystemPropertiesRequest request) throws GPUdbException {
        ShowSystemPropertiesResponse actualResponse_ = new ShowSystemPropertiesResponse();
        submitRequest("/show/system/properties", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns server configuration and version related information to the
     * caller. The admin tool uses it to present server related information to
     * the user.
     * 
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> properties: A list of comma separated names
     *                 of properties requested. If not specified, all
     *                 properties will be returned.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemPropertiesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemPropertiesResponse showSystemProperties(Map<String, String> options) throws GPUdbException {
        ShowSystemPropertiesRequest actualRequest_ = new ShowSystemPropertiesRequest(options);
        ShowSystemPropertiesResponse actualResponse_ = new ShowSystemPropertiesResponse();
        submitRequest("/show/system/properties", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Provides server configuration and health related status to the caller.
     * The admin tool uses it to present server related information to the
     * user.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemStatusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemStatusResponse showSystemStatus(ShowSystemStatusRequest request) throws GPUdbException {
        ShowSystemStatusResponse actualResponse_ = new ShowSystemStatusResponse();
        submitRequest("/show/system/status", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Provides server configuration and health related status to the caller.
     * The admin tool uses it to present server related information to the
     * user.
     * 
     * @param options  Optional parameters, currently unused.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemStatusResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemStatusResponse showSystemStatus(Map<String, String> options) throws GPUdbException {
        ShowSystemStatusRequest actualRequest_ = new ShowSystemStatusRequest(options);
        ShowSystemStatusResponse actualResponse_ = new ShowSystemStatusResponse();
        submitRequest("/show/system/status", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns the last 100 database requests along with the request timing and
     * internal job id. The admin tool uses it to present request timing
     * information to the user.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemTimingResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemTimingResponse showSystemTiming(ShowSystemTimingRequest request) throws GPUdbException {
        ShowSystemTimingResponse actualResponse_ = new ShowSystemTimingResponse();
        submitRequest("/show/system/timing", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Returns the last 100 database requests along with the request timing and
     * internal job id. The admin tool uses it to present request timing
     * information to the user.
     * 
     * @param options  Optional parameters, currently unused.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowSystemTimingResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowSystemTimingResponse showSystemTiming(Map<String, String> options) throws GPUdbException {
        ShowSystemTimingRequest actualRequest_ = new ShowSystemTimingRequest(options);
        ShowSystemTimingResponse actualResponse_ = new ShowSystemTimingResponse();
        submitRequest("/show/system/timing", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves detailed information about a table, view, or collection,
     * specified in {@code tableName}. If the supplied {@code tableName} is a
     * collection, the call can return information about either the collection
     * itself or the tables and views it contains. If {@code tableName} is
     * empty, information about all collections and top-level tables and views
     * can be returned.
     * <p>
     * If the option {@code get_sizes} is set to {@code true}, then the sizes
     * (objects and elements) of each table are returned (in {@code sizes} and
     * {@code fullSizes}), along with the total number of objects in the
     * requested table (in {@code totalSize} and {@code totalFullSize}).
     * <p>
     * For a collection, setting the {@code show_children} option to {@code
     * false} returns only information about the collection itself; setting
     * {@code show_children} to {@code true} returns a list of tables and views
     * contained in the collection, along with their description, type id,
     * schema, type label, type properties, and additional information
     * including TTL.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTableResponse showTable(ShowTableRequest request) throws GPUdbException {
        ShowTableResponse actualResponse_ = new ShowTableResponse();
        submitRequest("/show/table", request, actualResponse_, false);

        for (int i_ = 0; i_ < actualResponse_.getTypeIds().size(); i_++) {
            setTypeDescriptorIfMissing(actualResponse_.getTypeIds().get(i_), actualResponse_.getTypeLabels().get(i_), actualResponse_.getTypeSchemas().get(i_), actualResponse_.getProperties().get(i_));
        }

        return actualResponse_;
    }



    /**
     * Retrieves detailed information about a table, view, or collection,
     * specified in {@code tableName}. If the supplied {@code tableName} is a
     * collection, the call can return information about either the collection
     * itself or the tables and views it contains. If {@code tableName} is
     * empty, information about all collections and top-level tables and views
     * can be returned.
     * <p>
     * If the option {@code get_sizes} is set to {@code true}, then the sizes
     * (objects and elements) of each table are returned (in {@code sizes} and
     * {@code fullSizes}), along with the total number of objects in the
     * requested table (in {@code totalSize} and {@code totalFullSize}).
     * <p>
     * For a collection, setting the {@code show_children} option to {@code
     * false} returns only information about the collection itself; setting
     * {@code show_children} to {@code true} returns a list of tables and views
     * contained in the collection, along with their description, type id,
     * schema, type label, type properties, and additional information
     * including TTL.
     * 
     * @param tableName  Name of the table for which to retrieve the
     *                   information. If blank, then information about all
     *                   collections and top-level tables and views is
     *                   returned.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> get_sizes: If {@code true} then the table
     *                 sizes will be returned; blank, otherwise. Values: true,
     *                 false.
     *                         <li> show_children: If {@code tableName} is a
     *                 collection, then {@code true} will return information
     *                 about the children of the collection, and {@code false}
     *                 will return information about the collection itself. If
     *                 {@code tableName} is a table or view, {@code
     *                 show_children} must be {@code false}. If {@code
     *                 tableName} is empty, then {@code show_children} must be
     *                 {@code true}. Values: true, false.
     *                         <li> no_error_if_not_exists: If {@code false}
     *                 will return an error if the provided {@code tableName}
     *                 does not exist. If {@code true} then it will return an
     *                 empty result. Values: true, false.
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTableResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTableResponse showTable(String tableName, Map<String, String> options) throws GPUdbException {
        ShowTableRequest actualRequest_ = new ShowTableRequest(tableName, options);
        ShowTableResponse actualResponse_ = new ShowTableResponse();
        submitRequest("/show/table", actualRequest_, actualResponse_, false);

        for (int i_ = 0; i_ < actualResponse_.getTypeIds().size(); i_++) {
            setTypeDescriptorIfMissing(actualResponse_.getTypeIds().get(i_), actualResponse_.getTypeLabels().get(i_), actualResponse_.getTypeSchemas().get(i_), actualResponse_.getProperties().get(i_));
        }

        return actualResponse_;
    }



    /**
     * Retrieves the user provided metadata for the specified tables.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTableMetadataResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTableMetadataResponse showTableMetadata(ShowTableMetadataRequest request) throws GPUdbException {
        ShowTableMetadataResponse actualResponse_ = new ShowTableMetadataResponse();
        submitRequest("/show/table/metadata", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves the user provided metadata for the specified tables.
     * 
     * @param tableNames  Tables whose metadata will be fetched. All provided
     *                    tables must exist, or an error is returned.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTableMetadataResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTableMetadataResponse showTableMetadata(List<String> tableNames, Map<String, String> options) throws GPUdbException {
        ShowTableMetadataRequest actualRequest_ = new ShowTableMetadataRequest(tableNames, options);
        ShowTableMetadataResponse actualResponse_ = new ShowTableMetadataResponse();
        submitRequest("/show/table/metadata", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Gets names of the tables whose type matches the given criteria. Each
     * table has a particular type. This type is made out of the type label,
     * schema of the table, and the semantic type of the table. This function
     * allows a look up of the existing tables based on full or partial type
     * information. The operation is synchronous.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTablesByTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTablesByTypeResponse showTablesByType(ShowTablesByTypeRequest request) throws GPUdbException {
        ShowTablesByTypeResponse actualResponse_ = new ShowTablesByTypeResponse();
        submitRequest("/show/tables/bytype", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Gets names of the tables whose type matches the given criteria. Each
     * table has a particular type. This type is made out of the type label,
     * schema of the table, and the semantic type of the table. This function
     * allows a look up of the existing tables based on full or partial type
     * information. The operation is synchronous.
     * 
     * @param typeId  Type id returned by a call to {@link
     *                GPUdb#createType(String, String, Map, Map)}.
     * @param label  Optional user supplied label which can be used instead of
     *               the type_id to retrieve all tables with the given label.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTablesByTypeResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTablesByTypeResponse showTablesByType(String typeId, String label, Map<String, String> options) throws GPUdbException {
        ShowTablesByTypeRequest actualRequest_ = new ShowTablesByTypeRequest(typeId, label, options);
        ShowTablesByTypeResponse actualResponse_ = new ShowTablesByTypeResponse();
        submitRequest("/show/tables/bytype", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves information regarding the specified triggers or all existing
     * triggers currently active.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTriggersResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTriggersResponse showTriggers(ShowTriggersRequest request) throws GPUdbException {
        ShowTriggersResponse actualResponse_ = new ShowTriggersResponse();
        submitRequest("/show/triggers", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves information regarding the specified triggers or all existing
     * triggers currently active.
     * 
     * @param triggerIds  List of IDs of the triggers whose information to be
     *                    retrieved. Empty list means retrieve information on
     *                    all active triggers.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTriggersResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTriggersResponse showTriggers(List<String> triggerIds, Map<String, String> options) throws GPUdbException {
        ShowTriggersRequest actualRequest_ = new ShowTriggersRequest(triggerIds, options);
        ShowTriggersResponse actualResponse_ = new ShowTriggersResponse();
        submitRequest("/show/triggers", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Retrieves information for the specified data type. Given a type ID, the
     * database returns the data type schema, the label, and the semantic type
     * along with the type ID. If the user provides any combination of label
     * and semantic type, then the database returns the pertinent information
     * for all data types that match the input criteria.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTypesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTypesResponse showTypes(ShowTypesRequest request) throws GPUdbException {
        ShowTypesResponse actualResponse_ = new ShowTypesResponse();
        submitRequest("/show/types", request, actualResponse_, false);

        for (int i_ = 0; i_ < actualResponse_.getTypeIds().size(); i_++) {
            setTypeDescriptorIfMissing(actualResponse_.getTypeIds().get(i_), actualResponse_.getLabels().get(i_), actualResponse_.getTypeSchemas().get(i_), actualResponse_.getProperties().get(i_));
        }

        return actualResponse_;
    }



    /**
     * Retrieves information for the specified data type. Given a type ID, the
     * database returns the data type schema, the label, and the semantic type
     * along with the type ID. If the user provides any combination of label
     * and semantic type, then the database returns the pertinent information
     * for all data types that match the input criteria.
     * 
     * @param typeId  Type Id returned in response to a call to {@link
     *                GPUdb#createType(String, String, Map, Map)}.
     * @param label  Option string that was supplied by user in a call to
     *               {@link GPUdb#createType(String, String, Map, Map)}.
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  ShowTypesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public ShowTypesResponse showTypes(String typeId, String label, Map<String, String> options) throws GPUdbException {
        ShowTypesRequest actualRequest_ = new ShowTypesRequest(typeId, label, options);
        ShowTypesResponse actualResponse_ = new ShowTypesResponse();
        submitRequest("/show/types", actualRequest_, actualResponse_, false);

        for (int i_ = 0; i_ < actualResponse_.getTypeIds().size(); i_++) {
            setTypeDescriptorIfMissing(actualResponse_.getTypeIds().get(i_), actualResponse_.getLabels().get(i_), actualResponse_.getTypeSchemas().get(i_), actualResponse_.getProperties().get(i_));
        }

        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public UpdateRecordsResponse updateRecordsRaw(RawUpdateRecordsRequest request) throws GPUdbException {
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", request, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param <TRequest>  The type of object being added.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> UpdateRecordsResponse updateRecords(UpdateRecordsRequest<TRequest> request) throws GPUdbException {
        RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest(request.getTableName(), request.getExpressions(), request.getNewValuesMaps(), this.encode( request.getData() ), null, null, request.getOptions());
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param <TRequest>  The type of object being added.
     * @param typeObjectMap  Type object map used for encoding input objects.
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeObjectMap} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> UpdateRecordsResponse updateRecords(TypeObjectMap<TRequest> typeObjectMap, UpdateRecordsRequest<TRequest> request) throws GPUdbException {
        RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest(request.getTableName(), request.getExpressions(), request.getNewValuesMaps(), this.encode( typeObjectMap, request.getData() ), null, null, request.getOptions());
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param <TRequest>  The type of object being added.
     * @param tableName  Table to be updated. Must be a currently existing
     *                   table and not a collection or view.
     * @param expressions  A list of the actual predicates, one for each
     *                     update; format should follow the guidelines {@link
     *                     GPUdb#filter(String, String, String, Map) here}.
     * @param newValuesMaps  List of new values for the matching records.  Each
     *                       element is a map with (key, value) pairs where the
     *                       keys are the names of the columns whose values are
     *                       to be updated; the values are the new values.  The
     *                       number of elements in the list should match the
     *                       length of {@code expressions}.
     * @param data  An *optional* list of new binary-avro encoded records to
     *              insert, one for each update.  If one of {@code expressions}
     *              does not yield a matching record to be updated, then the
     *              corresponding element from this list will be added to the
     *              table.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> global_expression: An optional global
     *                 expression to reduce the search space of the predicates
     *                 listed in {@code expressions}.
     *                         <li> bypass_safety_checks: When set to 'true',
     *                 all predicates are available for primary key updates.
     *                 Keep in mind that it is possible to destroy data in this
     *                 case, since a single predicate may match multiple
     *                 objects (potentially all of records of a table), and
     *                 then updating all of those records to have the same
     *                 primary key will, due to the primary key uniqueness
     *                 constraints, effectively delete all but one of those
     *                 updated records. Values: true, false.
     *                         <li> update_on_existing_pk: Can be used to
     *                 customize behavior when the updated primary key value
     *                 already exists, as described in {@link
     *                 GPUdb#insertRecords(String, List, Map)}. Values: true,
     *                 false.
     *                         <li> record_id: ID of a single record to be
     *                 updated (returned in the call to {@link
     *                 GPUdb#insertRecords(String, List, Map)} or {@link
     *                 GPUdb#getRecordsFromCollection(Object, String, long,
     *                 long, Map)}).
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> UpdateRecordsResponse updateRecords(String tableName, List<String> expressions, List<Map<String, String>> newValuesMaps, List<TRequest> data, Map<String, String> options) throws GPUdbException {
        RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest(tableName, expressions, newValuesMaps, this.encode( data ), null, null, options);
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Runs multiple predicate-based updates in a single call.  With the list
     * of given expressions, any matching record's column values will be
     * updated as provided in {@code newValuesMaps}.  There is also an optional
     * 'upsert' capability where if a particular predicate doesn't match any
     * existing record, then a new record can be inserted.
     * <p>
     * Note that this operation can only be run on an original table and not on
     * a collection or a result view.
     * <p>
     * This operation can update primary key values.  By default only 'pure
     * primary key' predicates are allowed when updating primary key values. If
     * the primary key for a table is the column 'attr1', then the operation
     * will only accept predicates of the form: "attr1 == 'foo'" if the attr1
     * column is being updated.  For a composite primary key (e.g. columns
     * 'attr1' and 'attr2') then this operation will only accept predicates of
     * the form: "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary
     * key columns must appear in an equality predicate in the expressions.
     * Furthermore each 'pure primary key' predicate must be unique within a
     * given request.  These restrictions can be removed by utilizing some
     * available options through {@code options}.
     * 
     * @param <TRequest>  The type of object being added.
     * @param typeObjectMap  Type object map used for encoding input objects.
     * @param tableName  Table to be updated. Must be a currently existing
     *                   table and not a collection or view.
     * @param expressions  A list of the actual predicates, one for each
     *                     update; format should follow the guidelines {@link
     *                     GPUdb#filter(String, String, String, Map) here}.
     * @param newValuesMaps  List of new values for the matching records.  Each
     *                       element is a map with (key, value) pairs where the
     *                       keys are the names of the columns whose values are
     *                       to be updated; the values are the new values.  The
     *                       number of elements in the list should match the
     *                       length of {@code expressions}.
     * @param data  An *optional* list of new binary-avro encoded records to
     *              insert, one for each update.  If one of {@code expressions}
     *              does not yield a matching record to be updated, then the
     *              corresponding element from this list will be added to the
     *              table.
     * @param options  Optional parameters.
     *                 <ul>
     *                         <li> global_expression: An optional global
     *                 expression to reduce the search space of the predicates
     *                 listed in {@code expressions}.
     *                         <li> bypass_safety_checks: When set to 'true',
     *                 all predicates are available for primary key updates.
     *                 Keep in mind that it is possible to destroy data in this
     *                 case, since a single predicate may match multiple
     *                 objects (potentially all of records of a table), and
     *                 then updating all of those records to have the same
     *                 primary key will, due to the primary key uniqueness
     *                 constraints, effectively delete all but one of those
     *                 updated records. Values: true, false.
     *                         <li> update_on_existing_pk: Can be used to
     *                 customize behavior when the updated primary key value
     *                 already exists, as described in {@link
     *                 GPUdb#insertRecords(TypeObjectMap, String, List, Map)}.
     *                 Values: true, false.
     *                         <li> record_id: ID of a single record to be
     *                 updated (returned in the call to {@link
     *                 GPUdb#insertRecords(TypeObjectMap, String, List, Map)}
     *                 or {@link GPUdb#getRecordsFromCollection(Object, String,
     *                 long, long, Map)}).
     *                 </ul>
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsResponse
     * 
     * @throws IllegalArgumentException  if {@code typeObjectMap} is not an
     *                                   instance of one of the following:
     *                                   {@link Type}, {@link TypeObjectMap},
     *                                   {@link org.apache.avro.Schema}, or a
     *                                   {@link Class} that implements {@link
     *                                   org.apache.avro.generic.IndexedRecord}
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public <TRequest> UpdateRecordsResponse updateRecords(TypeObjectMap<TRequest> typeObjectMap, String tableName, List<String> expressions, List<Map<String, String>> newValuesMaps, List<TRequest> data, Map<String, String> options) throws GPUdbException {
        RawUpdateRecordsRequest actualRequest_ = new RawUpdateRecordsRequest(tableName, expressions, newValuesMaps, this.encode( typeObjectMap, data ), null, null, options);
        UpdateRecordsResponse actualResponse_ = new UpdateRecordsResponse();
        submitRequest("/update/records", actualRequest_, actualResponse_, true);
        return actualResponse_;
    }



    /**
     * Updates the view specified by {@code tableName} to include full series
     * (track) information from the {@code worldTableName} for the series
     * (tracks) present in the {@code viewName}.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public UpdateRecordsBySeriesResponse updateRecordsBySeries(UpdateRecordsBySeriesRequest request) throws GPUdbException {
        UpdateRecordsBySeriesResponse actualResponse_ = new UpdateRecordsBySeriesResponse();
        submitRequest("/update/records/byseries", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Updates the view specified by {@code tableName} to include full series
     * (track) information from the {@code worldTableName} for the series
     * (tracks) present in the {@code viewName}.
     * 
     * @param tableName  Name of the view on which the update operation will be
     *                   performed. Must be an existing view.
     * @param worldTableName  Name of the table containing the complete series
     *                        (track) information.
     * @param viewName  Optional name of the view containing the series
     *                  (tracks) which have to be updated.
     * @param reserved
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  UpdateRecordsBySeriesResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public UpdateRecordsBySeriesResponse updateRecordsBySeries(String tableName, String worldTableName, String viewName, List<String> reserved, Map<String, String> options) throws GPUdbException {
        UpdateRecordsBySeriesRequest actualRequest_ = new UpdateRecordsBySeriesRequest(tableName, worldTableName, viewName, reserved, options);
        UpdateRecordsBySeriesResponse actualResponse_ = new UpdateRecordsBySeriesResponse();
        submitRequest("/update/records/byseries", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeImageResponse visualizeImage(VisualizeImageRequest request) throws GPUdbException {
        VisualizeImageResponse actualResponse_ = new VisualizeImageResponse();
        submitRequest("/visualize/image", request, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeImageResponse visualizeImage(List<String> tableNames, List<String> worldTableNames, String xColumnName, String yColumnName, List<List<String>> trackIds, double minX, double maxX, double minY, double maxY, int width, int height, String projection, long bgColor, Map<String, List<String>> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeImageRequest actualRequest_ = new VisualizeImageRequest(tableNames, worldTableNames, xColumnName, yColumnName, trackIds, minX, maxX, minY, maxY, width, height, projection, bgColor, styleOptions, options);
        VisualizeImageResponse actualResponse_ = new VisualizeImageResponse();
        submitRequest("/visualize/image", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeImageClassbreakResponse visualizeImageClassbreak(VisualizeImageClassbreakRequest request) throws GPUdbException {
        VisualizeImageClassbreakResponse actualResponse_ = new VisualizeImageClassbreakResponse();
        submitRequest("/visualize/image/classbreak", request, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeImageClassbreakResponse visualizeImageClassbreak(List<String> tableNames, List<String> worldTableNames, String xColumnName, String yColumnName, List<List<String>> trackIds, String cbColumnName1, List<String> cbVals1, List<String> cbColumnName2, List<List<String>> cbVals2, double minX, double maxX, double minY, double maxY, int width, int height, String projection, long bgColor, Map<String, List<String>> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeImageClassbreakRequest actualRequest_ = new VisualizeImageClassbreakRequest(tableNames, worldTableNames, xColumnName, yColumnName, trackIds, cbColumnName1, cbVals1, cbColumnName2, cbVals2, minX, maxX, minY, maxY, width, height, projection, bgColor, styleOptions, options);
        VisualizeImageClassbreakResponse actualResponse_ = new VisualizeImageClassbreakResponse();
        submitRequest("/visualize/image/classbreak", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeImageHeatmapResponse visualizeImageHeatmap(VisualizeImageHeatmapRequest request) throws GPUdbException {
        VisualizeImageHeatmapResponse actualResponse_ = new VisualizeImageHeatmapResponse();
        submitRequest("/visualize/image/heatmap", request, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeImageHeatmapResponse visualizeImageHeatmap(List<String> tableNames, String xColumnName, String yColumnName, String valueColumnName, double minX, double maxX, double minY, double maxY, int width, int height, String projection, Map<String, String> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeImageHeatmapRequest actualRequest_ = new VisualizeImageHeatmapRequest(tableNames, xColumnName, yColumnName, valueColumnName, minX, maxX, minY, maxY, width, height, projection, styleOptions, options);
        VisualizeImageHeatmapResponse actualResponse_ = new VisualizeImageHeatmapResponse();
        submitRequest("/visualize/image/heatmap", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeImageLabelsResponse visualizeImageLabels(VisualizeImageLabelsRequest request) throws GPUdbException {
        VisualizeImageLabelsResponse actualResponse_ = new VisualizeImageLabelsResponse();
        submitRequest("/visualize/image/labels", request, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeImageLabelsResponse visualizeImageLabels(String tableName, String xColumnName, String yColumnName, String xOffset, String yOffset, String textString, String font, String textColor, String textAngle, String textScale, String drawBox, String drawLeader, String lineWidth, String lineColor, String fillColor, String leaderXColumnName, String leaderYColumnName, double minX, double maxX, double minY, double maxY, int width, int height, String projection, Map<String, String> options) throws GPUdbException {
        VisualizeImageLabelsRequest actualRequest_ = new VisualizeImageLabelsRequest(tableName, xColumnName, yColumnName, xOffset, yOffset, textString, font, textColor, textAngle, textScale, drawBox, drawLeader, lineWidth, lineColor, fillColor, leaderXColumnName, leaderYColumnName, minX, maxX, minY, maxY, width, height, projection, options);
        VisualizeImageLabelsResponse actualResponse_ = new VisualizeImageLabelsResponse();
        submitRequest("/visualize/image/labels", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates raster images of data in the given table based on provided input
     * parameters. Numerous parameters are required to call this function. Some
     * of the important parameters are the attributes of the generated images
     * ({@code bgColor}, {@code width}, {@code height}), the collection of
     * table names on which this function is to be applied, for which shapes
     * (point, polygon, tracks) the images are to be created and a user
     * specified session key. This session key is later used to fetch the
     * generated images. The operation is synchronous, meaning that a response
     * will not be returned until the images for all the frames of the video
     * are fully available.
     * <p>
     * Once the request has been processed then the generated video frames are
     * available for download via WMS using STYLES=cached. In this request the
     * LAYERS parameter should be populated with the session key passed in
     * {@code sessionKey} of the visualize video request and the FRAME
     * parameter indicates which 0-based frame of the video should be returned.
     * All other WMS parameters are ignored for this mode.
     * <p>
     * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY'
     * was generated, the first frame could be retrieved with the URL:
     * <p>
     *     <a href="../../../rest/wms_rest.html"
     * target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0</a>
     * <p>
     * and the last frame could be retrieved with:
     * <p>
     *     <a href="../../../rest/wms_rest.html"
     * target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19</a>
     * <p>
     * The response payload provides, among other things, the number of frames
     * which were created.
     * 
     * @param request  Request object containing the parameters for the
     *                 operation.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeVideoResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeVideoResponse visualizeVideo(VisualizeVideoRequest request) throws GPUdbException {
        VisualizeVideoResponse actualResponse_ = new VisualizeVideoResponse();
        submitRequest("/visualize/video", request, actualResponse_, false);
        return actualResponse_;
    }



    /**
     * Creates raster images of data in the given table based on provided input
     * parameters. Numerous parameters are required to call this function. Some
     * of the important parameters are the attributes of the generated images
     * ({@code bgColor}, {@code width}, {@code height}), the collection of
     * table names on which this function is to be applied, for which shapes
     * (point, polygon, tracks) the images are to be created and a user
     * specified session key. This session key is later used to fetch the
     * generated images. The operation is synchronous, meaning that a response
     * will not be returned until the images for all the frames of the video
     * are fully available.
     * <p>
     * Once the request has been processed then the generated video frames are
     * available for download via WMS using STYLES=cached. In this request the
     * LAYERS parameter should be populated with the session key passed in
     * {@code sessionKey} of the visualize video request and the FRAME
     * parameter indicates which 0-based frame of the video should be returned.
     * All other WMS parameters are ignored for this mode.
     * <p>
     * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY'
     * was generated, the first frame could be retrieved with the URL:
     * <p>
     *     <a href="../../../rest/wms_rest.html"
     * target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=0</a>
     * <p>
     * and the last frame could be retrieved with:
     * <p>
     *     <a href="../../../rest/wms_rest.html"
     * target="_top">http://<hostname/ipAddress>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-SESSION-KEY&FRAME=19</a>
     * <p>
     * The response payload provides, among other things, the number of frames
     * which were created.
     * 
     * @param tableNames  Names of the tables containing the data for various
     *                    layers of the resulting video.
     * @param worldTableNames  Optional name of the tables containing the data
     *                         for the entire track when the {@code tableNames}
     *                         contains only part of the track data, but the
     *                         entire track has to be rendered. The number of
     *                         tables should match the number of tables in the
     *                         {@code tableNames}
     * @param trackIds  Tracks from the {@code tableNames} to be rendered.
     * @param xColumnName  Name of the column containing the x coordinates.
     * @param yColumnName  Name of the column containing the y coordinates.
     * @param minX  Lower bound for the x values.
     * @param maxX  Upper bound for the x values.
     * @param minY  Lower bound for the y values.
     * @param maxY  Upper bound for the y values.
     * @param width  Width of the generated image.
     * @param height  Height of the generated image.
     * @param projection  Spatial Reference System (i.e. EPSG Code). Values:
     *                    EPSG:4326, PLATE_CARREE, 900913, EPSG:900913, 102100,
     *                    EPSG:102100, 3857, EPSG:3857, WEB_MERCATOR.
     * @param bgColor  Background color of the generated image.
     * @param timeIntervals
     * @param videoStyle
     * @param sessionKey  User Provided session key that is later used to
     *                    retrieve the generated video from the WMS.
     * @param styleOptions  Styling options for the image.
     *                      <ul>
     *                              <li> do_points: Rasterize point data
     *                      toggle. Values: true, false.
     *                              <li> do_shapes: Rasterize shapes toggle.
     *                      Values: true, false.
     *                              <li> do_tracks: Rasterize tracks toggle.
     *                      Values: true, false.
     *                              <li> pointcolors: RGB color value in hex
     *                      for the points.
     *                              <li> pointsizes: Size of points.
     *                              <li> pointshapes: Shape of the point.
     *                      Values: none, circle, square, diamond,
     *                      hollowcircle, hollowsquare, hollowdiamond,
     *                      SYMBOLCODE.
     *                              <li> shapelinewidths: Width of the lines.
     *                              <li> shapelinecolors: RGB color values in
     *                      hex for the line.
     *                              <li> shapefillcolors: RGB color values in
     *                      hex for the fill color of the shapes. Use '-1' for
     *                      no fill.
     *                              <li> tracklinewidths: Width of the track
     *                      lines. '0' implies do not draw track lines.
     *                              <li> tracklinecolors: RGB color values for
     *                      the track lines.
     *                              <li> trackmarkersizes: Size of the track
     *                      point markers.
     *                              <li> trackmarkercolors: Color of the track
     *                      point markers.
     *                              <li> trackmarkershapes: Shape of track
     *                      point markers. Values: none, circle, square,
     *                      diamond, hollowcircle, hollowsquare, hollowdiamond,
     *                      SYMBOLCODE.
     *                              <li> trackheadcolors: Color of track head
     *                      markers.
     *                              <li> trackheadsizes: Size of track head
     *                      markers.
     *                              <li> trackheadshapes: Shape of track head
     *                      markers. Values: none, circle, square, diamond,
     *                      hollowcircle, hollowsquare, hollowdiamond,
     *                      SYMBOLCODE.
     *                      </ul>
     * @param options  Optional parameters.
     * 
     * @return Response object containing the results of the operation.
     * 
     * @see  VisualizeVideoResponse
     * 
     * @throws GPUdbException  if an error occurs during the operation.
     * 
     */
    public VisualizeVideoResponse visualizeVideo(List<String> tableNames, List<String> worldTableNames, List<List<String>> trackIds, String xColumnName, String yColumnName, double minX, double maxX, double minY, double maxY, int width, int height, String projection, long bgColor, List<List<Double>> timeIntervals, String videoStyle, String sessionKey, Map<String, List<String>> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeVideoRequest actualRequest_ = new VisualizeVideoRequest(tableNames, worldTableNames, trackIds, xColumnName, yColumnName, minX, maxX, minY, maxY, width, height, projection, bgColor, timeIntervals, videoStyle, sessionKey, styleOptions, options);
        VisualizeVideoResponse actualResponse_ = new VisualizeVideoResponse();
        submitRequest("/visualize/video", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeVideoHeatmapResponse visualizeVideoHeatmap(VisualizeVideoHeatmapRequest request) throws GPUdbException {
        VisualizeVideoHeatmapResponse actualResponse_ = new VisualizeVideoHeatmapResponse();
        submitRequest("/visualize/video/heatmap", request, actualResponse_, false);
        return actualResponse_;
    }



    public VisualizeVideoHeatmapResponse visualizeVideoHeatmap(List<String> tableNames, String xColumnName, String yColumnName, double minX, double maxX, double minY, double maxY, List<List<Double>> timeIntervals, int width, int height, String projection, String videoStyle, String sessionKey, Map<String, String> styleOptions, Map<String, String> options) throws GPUdbException {
        VisualizeVideoHeatmapRequest actualRequest_ = new VisualizeVideoHeatmapRequest(tableNames, xColumnName, yColumnName, minX, maxX, minY, maxY, timeIntervals, width, height, projection, videoStyle, sessionKey, styleOptions, options);
        VisualizeVideoHeatmapResponse actualResponse_ = new VisualizeVideoHeatmapResponse();
        submitRequest("/visualize/video/heatmap", actualRequest_, actualResponse_, false);
        return actualResponse_;
    }


}